Table of Contents:
- Welcome
- [[#Compiled Binaries]] - static vs dynamically linked binary?
	- [[#Binary Memory Management]]
	- [[#Statically Linked Binaries]]
	- [[#Dynamically Linked Binaries]]
- [[#Binary Memory Layout]] - Text, Data, Stack, Heap
	- [[#ASLR]] - what is this
	- [[#PIE]] - what is this
	- [[#Symbols]] - what are they? Examples?
- [[#Pwntools]]
- [[#Recitation]]
- [[#Notes on Emulation]]

Welcome to Introduction to Offensive Security! We start with just thatâ€”an introduction. Before we can dive into reverse engineering, binary exploitation, and more, we need to review a few key concepts and potentially introduce some new information. The goal of this lesson is to provide a foundation upon which we can buildâ€”to set us up for success in this course and give a taste of what is to come.

We deal with particularly low level systems here, perhaps much lower than our prior experience. We care about how programs and libraries are organized in memory. We will learn how data flows between memory (RAM) and CPU registers and how bits are stored and interpreted by the CPU. And we will understand how changing one or more bits of data impacts program state and execution.Â First, we need to understand more about what a compiled binary is and how it works.

## Compiled Binaries

Most of this course revolves around understanding how binary executables work in the Linux operating system. We will refer to "binaries" as compiled executables that are run without a virtual machine or interpreter. For example:

Binaries:
- Compiled C codeÂ 
- Compiled C++ code
- Compiled Rust code
- Compiled Go code
- Compiled Linux shared libraries (e.g., `libc.so` aka glibc)

Not binaries:
- Javascript scripts
- Python scripts
- Java programs run in the Java interpreter

You will note that colloquially a scripting languageâ€”such as Python or Javascriptâ€”does not produce a compiled binary by default. Instead, a virtual machine or interpreter reads the source code, reduces it to an intermediate bytecode, and translates that bytecode into CPU instructions. In contrast, compiled code requires, surprise, a *compiler*. For Linux that is typically `gcc` for C programs, `g++` for C++ programs, and `cargo` for Rust programs.

Note that this course focuses on C programs onlyâ€”C++, Go, and Rust compiled binaries can get very unwieldy and are an exercise left to those looking for a challenge. However, the concepts we learn in this course are applicable to reverse engineering and exploitation of any compiled program.

### Binary Memory Management

A program consists of source code (one or more files) compiled into the resulting executable. Are the executable's instructions the only code executed by the CPU during execution? Unfortunately the answer is almost certainly, "no." Anyone who has written C or C++ will recognize the familiar `#include <...>` or `#include "..."` statements that typically start a source code file. These tell the compiler that the program uses imported functionalityâ€”whether that be variables, constants, or functionsâ€”that are defined elsewhere. Linking these files can happen in one of two ways: dynamically or statically.

> [!TLDR]
> - Program files usually import other files
> - How do we "link" these imported files?
> 	- def (link)
>			- != compilation, which is translating higher-level source code to binary machine code (as object files .o)
			>- **program consists of many files. Each file gets compiled into their own object files. Now, to run the overall program, I need to <u>combine all these object files into one single executable.</u> This process of combination is called "linking"**
			>- 2 ways to link
			>	- 1. Dynamically
			>		- when linking, include references to imported things from libraries like glibc. the output executable contains these refs
			>	- 2. Statically
			>		- when linking, include the actual code of imported things from glibc. the output executable contains this code


#### Dynamically Linked Binaries

For the simple toy project, consider the following the [[hello_world.c]] code:

```c
#include "stdlib.h"
#include "stdio.h"

int main() {
	puts("Hello world");
Â Â Â Â return 0;
}
```

And then compile this with the following `gcc` command:

```sh
gcc hello_world.c -o dynamic
```
Note: gcc is a compiler used to compile C and C++ (turns src code into object files)


The compiled binary output ([[dynamic]]) is dynamically linked against glibc. `gcc` links against glibc automatically whenever a standard import is defined in the source file (e.g., `stdlib.h`). Dynamic linking is the default option for `gcc` unless otherwise specified. This makes the binary small, containing only the code that is defined in the source file(s). Then, at runtime, the loader/linker (`ld.so`) is responsible for fetching and dynamically loading the required dependent libraries into memory. 

>[!Note on glibc]
>-  C library
>-  stands for GNU C library
>- contains libraries like the standard library
>	- provides commonly used functions like malloc, printf, open ...
>	- How? by providing header files that we can include in our C programs, like <stdio.h>, <stdlib.h>, <string.h>

There are pros and cons to this methodology:

Pros
- Size: output binary is small and its `code` and `data` sections (more on these later) contain only instructions and data from the source code file(s)
- ASLR security: ASLR stands for Address Space Layout Randomization. We will talk about this more in depth later, but essentially every shared library required to fulfill the imported functionality exists at a unique, random address in memory. The stack is also randomized to a different address range every execution. This means an attacker has to go through much more work to locate potentially necessary code for an exploit (boo!)

Cons
- Potential Linking Errors: this is usually not the case for standard libraries like `glibc` on Linux, as they are generally tested to be thoroughly backwards compatible. However, compiling code against unique shared libraries or different target systems (e.g. `uClibc` for embedded devices) may lead to inconsistencies in functionality and compiler/linker errors

#### Statically Linked Binaries

Using the same source code from [[hello_world.c]], we can statically compile with the `-static` flag to create the [[static]] binary:

```sh
gcc hello_world.c -o static -static
```

This means that all included objects (or "libraries") are included in the resulting output file. There are pros and cons to this approach:

ðŸ’š Pros
- Portability: 
	- all the possible code to be executed is included in the binary. This means a binary can be executed on different systems that do not have the shared functionality (libraries) upon which the program depends
- Plug-and-play: useful for shipping a final product that the end user can "plug and play"

ðŸ‘¹ Cons
- Bloat: Your executable file might be very BIG. 
	- the compiler does not discriminate between shared functionality that is used or not used *within the required library*. <U>Therefore, importing a single function from a library includes the entire library in the output.</U> Standard libraries are especially large :(
- Loses ASLR mitigations: 
	- the entire binary and all linked libraries are combined into a single executable, which starts at a single (potentially random) address in memory. Therefore, an attacker which identifies that address has access to ALL executable code, data, etc. at their disposal. This effectively nullifies the benefit of ASLR

#### Identifying Compilation Choice

So how do we know what compilation choice was made by the developer?

We can trivially identify the type of binary (static vs dynamic) using the `file` command on Linux:

```console
# static binary
$ file static
static: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=999627fbdd7a5936c3f5b4df6f0ecbe4f2fb786b, for GNU/Linux 3.2.0, not stripped

# dynamic binary
$ file dynamic
dynamic: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=34fe4d667e21a22ba260042dc359bb34242a1daf, for GNU/Linux 3.2.0, not stripped
```

There is a lot of information in this output, some of which is very useful to us (in addition to the static vs dynamic distinction). Letâ€™s briefly review:
- ELF: the general file type for executables and shared libraries in Linux. This is ~equivalent to PE when talking about Windows binaries. All files we analyze in this course will be ELFs
- 64-bit: the bitness of the system. We will only focus on 64-bit binaries in this course
- LSB: Least Significant Bit first, as opposed to MSB (Most Significant Bit). This distinction is extremely important for us as reverse engineers and exploit devs. This means that every number, whether it be 1-8 bytes, has the least significant bit/byte first. For instance, the value `0xdeadbeef` will have its least significant byte (`0xef`) stored in memory before the second least significant byte `0xbe`. We will show this distinction more next week when we introduce GDB and memory dumping
- pie: PIE is turned on ([[#PIE|more on this in a bit]]). Notice this is not applied for the static binary
- x86-64: the architecture, which dictates the instructions within the binary. Other options could be MIPS, ARM, AARCH64, etc. We will only reverse engineer `x86_64` binaries in this course
- Version 1 (SYSV): the binary uses the System V ABI format, which defines specific program parameters such as the calling convention into functions. We will review the specifics in more detail as they become relevant
- Statically/Dynamically linked: as discussed in this section
- Interpreter `/ld-linux-x86-64.so.2`: the specific linker to be used (for dynamic executables only)
- BuildID: the binaryâ€™s SHA1 sum
- Stripped/not stripped: whether or not the symbol (function and data) names have been removed from the binary. We will talk about this in [[4. Stripped Binaries and Protocols|we will talk about this]] in more detail later in the reverse engineering unit

We can also see the shared object dependencies with the `ldd` command. 

```console
# static binary
$ ldd static
not a dynamic executable

# dynamic binary
$ ldd dynamic
linux-vdso.so.1 (0x00007ffe887bd000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f27cd200000)
/lib64/ld-linux-x86-64.so.2 (0x00007f27cd4af000)
```

As expected, the static library does not have any dynamic dependencies. Meanwhile, the dynamic executable has three listed dependencies:
- `linux-vdso.so.1`: a virtual dynamic shared object mapped into the programâ€™s address space by the kernel. We will not focus on the kernel in this course
- `libc.so.6`: affectionately known as `glibc` when working with common Linux kernels. This has a lot of standard library functionality we need to write C programs, like `stdio.h`, `stdlib.h`, etc.
- `ld-linux-x86-64.so.2`: the linker/loader, responsible for fetching all the other shared objects and mapping them into the address space

Great! Now we know more about what we are investigating. We will get into the impact of these decisions on reverse engineering and exploitation later in the course. For now, it is important to remember that the choice of static vs dynamic compilation may change/limit our exploitation approach and can drastically change the scope of functionality we desire to reverse engineer.

## Binary Memory Layout  

> [!TL;DR]
> 1. Memory Layout
> 	- Where are these elements found?
> 		- these elements live in the RAM, not the CPU! CPU interacts with RAM using pointers
> 		- cache does live in CPU. Think of it as quick storage. But cache is separate from stack, heap, text...
> 		- all these elements are per-process
> 			- one stack per process ("single-threaded"). same for all others
> 	- Note on high/low memory addr
> 		- high/low in virtual memory, not physical space
> 		- low means towards addr 0
> 		- high means towards the limit of the OS's memory ceiling
> 	- stack
> 		- memory used by program; auto-allocated
> 			- accurately: for storing temp things
> 				- function calls, local vars
> 		- when a function gets called, it gets pushed onto the stack
> 		- when a function finishes, it gets popped off the stack
> 		- grows from high to low memory addr
> 			- start from highest possible memory addr?
> 	- heap
> 		- dynamic memory; as-needed memory space
> 		- allocated by the programmer (in C, keyword **malloc**)
> 		- things also need to be explicitly removed by the programmer
> 	- text
> 		- ???
> 		- executable code of the program
> 	- data
> 		- global vars + static vars
> 		- 2 sections: declared but uninitialized AND initialized vars
> 	- stuff in the middle??
> 	- kernel
> 		- core part of OS
> 		- manages the system's resources
>
> 2. ASLR (address space layout randomization)
> 	- randomize the start addr of stack, heap
> 		- Note: stack still grows down and heap still grows upwards. Just where they start in memory is random. 
> 	- in dynamically-linked files, randomize where the shared libs things get mapped into memory at runtime
> 3. PIE
> 	- 
> 4. Symbols
> 	- 


Curiosity Questions
- Why did we design it this way: stack grows downward and heap grows upwards
	- to use memory efficiently in the system
		- if you fix the heap at the "bottom" and the stack somewhere above it also growing upwards, then you limit how large the heap can be, which is especially bad if you don't have much on the stack (wasted space)
		- whereas if you make both grow towards each other, you allow them as much memory space as they need without interfering with each other



Let us now review the programâ€™s virtual (vs physical; virtual b.c. we think of this as a concept?) address space, taking into account the information presented up to this point. Recall that the operating system (OS) exposes a "Virtual Address Space" to each user land program running on the system. This gives the program the illusion that it has far more memory at its disposal than may actually exist in hardware. As reverse engineers and exploit devs working at the user land level, we can take this abstraction at face value without diving too deeply into the OSâ€™s page table translation and mappings from physical to virtual address. However, it is important to understand where things live in memory, so that we can better understand how the system executes and where useful data might reside.

You might also recall that the kernel is "mapped" into every processâ€™s address space at a predetermined offset. This code is unreachable by the process without a system call, and typically begins at `0xffff888000000000` on `x86_64` machines (defined in the `PAGE_OFFSET` kernel configuration option). We will not concern ourselves with kernel code in this course, but it is important to note that it exists.
- Kernel
	- def
		- the OS itself?

User land programs are then organized by a general layout, which varies depending on some OS configuration choices and program-specific information (such as shared libraries).Â 

The top (higher) addresses in the virtual memory space are reserved for the stack, which grows downward to lower addresses. For our purposes, the stack is normally located somewhere around `0x00007ffXXXXXX000`. Moving downward from there are the shared libraries and the linker, if used. Each library against which the binary is linked (remember `gcc` links against glibc by default) is mapped into memory by the loader separately and generally non-contiguously. Finally, after a large gap, is the program heap which grows upward toward larger memory addresses. Where the stack is useful for known-sized data (static arrays, primitives, pointers, etc.), the heap is used whenever we need memory that may vary in size. Finally, at the lowest addresses in the address space is the binary itself.Â Again, a lot of this is a quick review of [operating systems fundamentals](https://www.kernel.org/doc/gorman/html/understand/understand007.html). 

![[memory_map.png]]

Each sectionâ€™s address range generally varies (depending on system configurations) to enhance program security. We will investigate the impact of this in more detail throughout the semester, but it is still worthwhile to introduce it now.Â 

### ASLR
- applies to BOTH static and dynamically linked files
	- static: things imported from shared libs like the standard library are actually included as code in the executable
	- dynamic: things imported from shared libs are only included as references; their actual code does not go towards forming the executable
- How ASLR impacts...
	- dynamically linked
		- when things from shared libs are mapped into memory <u>at runtime</u>, ASLR randomizes where they get mapped
	- statically linked
		- code from shared libs exist in the executable itself
		- shared libs things are in effect still randomized, bc ASLR also randomizes where the stack, heap live

As mentioned previously, ASLR stands for Address Space Layout Randomization. Effectively, the linker maps all shared libraries into memory at unique random addresses and defines a unique address range for the stack for each program execution. ASLR prevents an attacker from knowing, before runtime, where certain librariesâ€”and the associated code and data in those librariesâ€”will exist in memory. It makes exploitation much harder, typically requiring one or more "leak primitives" during exploitation to shed light on the addresses of these libraries. We will discuss "leak primitives" in detail during the binary exploitation portion of this class.

ASLR is configured in the `/proc/sys/kernel/randomize_va_space` file that is only writable by sudoers. A value of 0 means it is turned off, 1 provides partial randomization, and 2 allows for randomization of shared libraries and the stack.

```console
$ cat /proc/sys/kernel/randomize_va_space
2
```

#### PIE
- "Position Independent Executable" is a type of executable
- it is designed to be loaded in at any given memory addr
- PIE vs ASLR
	  - ASLR does the random positioning
	  - PIE is a type of thing that allows the thing to be randomly positioned

PIE stands for Position Independent Executable. It should be noted that ASLR does NOT randomize the location of the program executable. That is what PIE is for. Essentially, the compiler implements PIE by stubbing out code jumps to offsets from a randomized base address that is generated at runtime. In non-PIE binaries, these jumps are hard-coded to a known address since no randomization is performed. You can effectively think of PIE as ASLR for the binary. Similarly, it makes attacking the program harder because we do not know where the binary exists in memory at runtime and therefore often require a "leak primitive" to identify its addresses, if needed.

No-PIE is designated by a compilation flag `-no-pie -fno-pic`, otherwise **PIE is on by default for modern GCC**. We can determine whether or not PIE is on using aÂ `pwntools` utility (more on that in a bit), but it is also presented in the `file` output we saw earlier. Notice the distinction between theÂ `LSB pie executable` and `LSB executable` output: a `PIE` binary (like [[dynamic]]) is listed specifically as `pie` while [[no_pie]] does not have this designation:

```console
# no-PIE
$ gcc example.c otherlib.o -o no_pie -fno-pic -no-pie 
$ file no-pie
no_pie: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=4beb1356c6d336916f1734f2ee740b3f7bc67c82, for GNU/Linux 3.2.0, not stripped

# PIE
$ file dynamic
pie: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=edf3d1330300aa1b4952fb17b76adb96531d59c4, for GNU/Linux 3.2.0, not stripped
```

### Symbols
#### TLDR
- symbol table
	- mapping between a piece of binary code and what it means
		- e.g. 0101010 <---> the global var called GLOBAL_VAR in our program
	- created by the compiler, during compilation (source code --> machine binary code)
	- How to understand:
		- 
- symbol
	- e.g. you write a program that involves a function called calculateSum(), inside of which is a local variable called sum
		- "calculateSum" is a symbol
		- "sum" is a symbol
	- in the symbol table, symbols are listed along with where the actual thing lives in memory
	- Every compilation of a program (even if on the same computer) may result in a different memory address for each symbol (rmb: ASLR!)


#### Detailed Notes
Every compiled binary, whether it be a shared library or executable itself, has symbols. Symbols include a number of things, but for our purposes weâ€™re mainly concerned with functions and objects. Functions are self explanatory. Objects are typically variables, specifically exported or global variables. The symbols in the binary are their addresses: addresses of executable code and addresses of variables, respectively.Â 

> We should say _nearly_ every compiled binary has symbols; stripped and static binaries will output no symbols, since there are completely self-composed and stripped of all symbol information. We will talk about these binaries and how to approach them in a later lesson.

Linux has a number of utilities for viewing symbols, each with advantages and disadvantages. Weâ€™ll use the `readelf` utility with its `-Ws` flag to show symbols in a binary. For the following [[symbols.c]] code:

```c
#include "stdlib.h"
#include "stdio.h"
#include "string.h"

// compile with `gcc symbols.c -o symbols`
  
const char HELLO[6] = "Hello\0";
  
int main() {
Â Â Â Â char buf[0x10];
Â Â Â Â printf("What is your name?\n> ");
Â Â Â Â fgets(buf, sizeof(buf), stdin);
Â Â Â Â char* newline = strchr(buf, (int)'\n');
Â Â Â Â if (newline) { *newline = '\0'; }
Â Â Â Â printf("%s %s, your name is %ld letters long\n", HELLO, buf, strlen(buf));
Â Â Â Â puts("Goodbye!");
Â Â Â Â return 0;
}
```

We see the functions used in the compiled [[symbols]], including `strlen, puts, printf, fgets, strchr` as part of the `dynsym` table. This is because they are dynamically linked imports from glibc. Also the type for these are `FUNC`, as expected since they are functions. If we scroll down the `.symtab` table, which includes both local and imported symbols, we see our global variable, `HELLO`, defined as an `OBJECT` and `main` defined as a `FUNC`.

##### Understanding a symbol table
- Value
	- hex memory addr of this thing
	- 0 doesn't mean it's stored at memory addr 0. It means it's undefined and will be resolved at runtime
		- (See field Ndx - should be UND for undefined)
		- applies to say functions you borrow from standard libraries. In the binary of your particular file, this symbol would be undefined
		- at runtime, the dynamic linker/loader is the agent that finds the actual correct memory addr for these undefined symbols and set the value to it
- Size
	- size (bytes) of this thing
- Type
	- What is this thing? 
		- Function, Object (variable), NOTYPE (undefined)
- Bind
	- Global means this symbol is visible to other object files
		- rmb you might be looking at an object file that is part of many which collectively form the entire program!
	- Local means the symbol is only visible within this object file

```
$ readelf -Ws symbols

Symbol table '.dynsym' contains 13 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.34 (2)
     2: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTable
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 (3)
     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strlen@GLIBC_2.2.5 (3)
     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4 (4)
     6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strchr@GLIBC_2.2.5 (3)
     7: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.2.5 (3)
     8: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND fgets@GLIBC_2.2.5 (3)
     9: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
    10: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
    11: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.2.5 (3)
    12: 0000000000004010     8 OBJECT  GLOBAL DEFAULT   26 stdin@GLIBC_2.2.5 (3)

Symbol table '.symtab' contains 43 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
	# ... snip ...
    20: 0000000000004000     0 NOTYPE  WEAK   DEFAULT   25 data_start
    21: 0000000000002008     6 OBJECT  GLOBAL DEFAULT   18 HELLO
    22: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5
    23: 0000000000004010     8 OBJECT  GLOBAL DEFAULT   26 stdin@GLIBC_2.2.5
    24: 0000000000004010     0 NOTYPE  GLOBAL DEFAULT   25 _edata
    25: 00000000000012b4     0 FUNC    GLOBAL HIDDEN    17 _fini
    26: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strlen@GLIBC_2.2.5
    27: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4
    28: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strchr@GLIBC_2.2.5
    29: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.2.5
    30: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND fgets@GLIBC_2.2.5
    31: 0000000000004000     0 NOTYPE  GLOBAL DEFAULT   25 __data_start
    32: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
    33: 0000000000004008     0 OBJECT  GLOBAL HIDDEN    25 __dso_handle
    34: 0000000000002000     4 OBJECT  GLOBAL DEFAULT   18 _IO_stdin_used
    35: 0000000000004020     0 NOTYPE  GLOBAL DEFAULT   26 _end
    36: 0000000000001100    38 FUNC    GLOBAL DEFAULT   16 _start
    37: 0000000000004010     0 NOTYPE  GLOBAL DEFAULT   26 __bss_start
    38: 00000000000011e9   203 FUNC    GLOBAL DEFAULT   16 main
	# ... snip ...
```

##### What about "offsets"?

**Using offsets:**
Remember how when things get loaded in, under PIE and ASLR, where in memory they're loaded into can get randomized? Specifically, the **base address** of an executable and things from a shared library. 

The "value" column in the symbol table shows not the absolute memory addr of the thing, but the offset. 

The actual memory addr of thing = base address + thing's offset

e.g. you are using the "printf" function from the C standard library.
actual memory of "printf" = glibc base address + "printf"'s offset value
- glibc base address is where glibc gets loaded into memory when the program runs

**Not using offsets:**
Aka using absolute memory addr. Every symbol has an absolute memory addr. That is the exact memory addr it gets loaded into, as shown in the "value" column in the symbol table.

Every time you run this program, things get loaded into these specified memory addr



Some of these symbols, including `main` and `HELLO`, have addresses, and it is important to consider what these values mean. Are they virtual memory offsets or the absolute virtual memory addresses that end up in memory? Well, it depends.

For shared libraries like glibc, they are offsets.  All linked objects in the runtime, such as glibc and the linker/loader, end up with a randomized base address from ASLR. Therefore, their `readelf` output values are all offsets from the libraryâ€™s base address. `ld` first loads the shared object into the virtual memory space with a randomized base address, and then links all symbols using the virtual address `address = base + offset`. Since the `base` changes every time, the resulting `address` is always random. However the `offset` is always staticâ€”provided we are looking at the same version of a library/executable.

![[base_offset.png]]

For an executable, the answer is it depends on PIE. If PIE is on, the same situation as a shared object arises: PIE randomizes the base address and thus the binary has been compiled with relative offsets for its symbols. This is shown by our [[symbols]] example aboveâ€”**all addresses shown are relative to the randomized base addresses.**

If PIE is off, then the binary has hardcoded addresses for its symbols. This means the addresses shown by `readelf` are absolute addresses, and the functions/variables are always mapped into memory with those addresses. This typically leads to large addresses in the `0x400000` range, as shown with the [[no_pie]] binary:

```console
$ readelf -Ws no_pie 

Symbol table '.dynsym' contains 4 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.34 (2)
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.2.5 (3)
     3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__

Symbol table '.symtab' contains 36 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
	# ... snip ...
    20: 0000000000404008     0 NOTYPE  WEAK   DEFAULT   25 data_start
    21: 000000000040401c     0 NOTYPE  GLOBAL DEFAULT   25 _edata
    22: 000000000040115c     0 FUNC    GLOBAL HIDDEN    16 _fini
    23: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.2.5
    24: 0000000000404018     4 OBJECT  GLOBAL DEFAULT   25 OTHERLIB_VAR
    25: 0000000000404008     0 NOTYPE  GLOBAL DEFAULT   25 __data_start
    26: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
    27: 0000000000404010     0 OBJECT  GLOBAL HIDDEN    25 __dso_handle
    28: 0000000000402000     4 OBJECT  GLOBAL DEFAULT   17 _IO_stdin_used
    29: 0000000000404020     0 NOTYPE  GLOBAL DEFAULT   26 _end
    30: 0000000000401080     5 FUNC    GLOBAL HIDDEN    15 _dl_relocate_static_pie
    31: 0000000000401050    38 FUNC    GLOBAL DEFAULT   15 _start
    32: 000000000040401c     0 NOTYPE  GLOBAL DEFAULT   26 __bss_start
    33: 0000000000401136    38 FUNC    GLOBAL DEFAULT   15 main
    34: 0000000000404020     0 OBJECT  GLOBAL HIDDEN    25 __TMC_END__
    35: 0000000000401000     0 FUNC    GLOBAL HIDDEN    12 _init
```

Say we, as exploit developers, want to call a function that has some interesting behavior. If PIE is off then we know the exact function address (provided we have access to the target executable). However if PIE is on, we need more information. How would we find a PIE binary's function addresses?

`address = base + offset` is true in reverse. Say we have a "leak primitive," as mentioned earlier, that gives us that address of a global variable in the binary. Even if we are not interested in that variable, if it is a symbol in the binary then we can use its address to calculate the base using `base = address - offset`. Now, with the base address calculated, we can find the function of interest using its offset: `base = address2 - offset2`.

We see why PIE/ASLR are such important protectionsâ€”without them we know exactly where interesting addresses would end up in memory. But with them, we typically need at least one "leak primitive" to orient ourselves first!

#### To Be Continued...

What we just covered was a conceptual overview of virtual memory layouts, but next lesson we concretely look at these implementations with the dynamic analysis tool, GDB.

## Pwntools

Next, we introduce and familiarize ourselves with an incredibly powerful tool for binary invocation, analysis, and debugging. In almost all scenarios, we need to interact with a running binary to analyze its behavior, test hypotheses, and demonstrate our exploits. The Python [`pwntools` library]([https://docs.pwntools.com/en/stable/](https://docs.pwntools.com/en/stable/)) allows us to do all that, and more. We cover some of the base functionality in this lesson, and continue to introduce additional features as they become relevant to our current content later in this course.

Let's consider a simple example program, [[pwntools_example_fgets.c]], as shown below:

```c
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "unistd.h"

// replace newline character at end of input with a null byte
void replace_nl(char* buf) {
    char* nl = strchr(buf, '\n');
    if (nl) { *nl = '\0'; }
}

// get number from user and convert to long
long get_number() {
    char buf[0x10];
    fgets(buf, 0x10, stdin);
    replace_nl(buf);
    return strtol(buf, NULL, 10);
}

int main() {
    // set all fds to be newline buffered
    setvbuf(stdin, NULL, _IOLBF, 0);
    setvbuf(stdout, NULL, _IOLBF, 0);
    setvbuf(stderr, NULL, _IOLBF, 0);

    char buf[0x10];
    long x, y;
    puts("Give me two numbers that add up to 23!");
    printf(" > ");
    fflush(stdout);
    x = get_number();
    printf(" > ");
    fflush(stdout);
    y = get_number();
    printf("\n%ld + %ld = %ld\n", x, y, x + y);
    if (x + y == 23) {
        puts("Yes, you win!");
    } else {
        printf("Nope, those add to %ld!\n", x + y);
    }
    return 0;
}
```

The program is relatively simple: it asks the user for two inputs, converts those input from ASCII characters (e.g., `"12"`) to an integer value (e.g., `0xc`). It then adds the two integers together and compares the result to the integer `23`. If we satisfy this condition with our input, we "win." Otherwise, the program prints the result of our addition to the console and terminates.

> `"12"` above is wrapped in quotes to indicate two separate characters, `'1'` and `'2'`, as we would generate by pressing the `1` and `2` keys on our keyboard. When we enter values via a terminal, each character is its own byte. [[1. Reverse Engineering Tools|We will talk about bytes and characters and primitive data types in the next lesson]], but it is important to understand that the example `"12"` input on the terminal generates two bytes, the character `'1'` and `'2'`. `strtol` converts a series of characters into their representation as a number, combining multiple character bytes into a `long`. The result in memory after the conversion is the number `12`, or `0xc` in hexadecimal.

Let's confirm our understanding by running the compiled [[pwntools_example_fgets]] program on the command line and attempting to solve it. Inputting `"10"` and `"13"`, we see that we do, in fact, solve the challenge:

```console
./pwntools_example_fgets 
Give me two numbers that add up to 23!
 > 10
 > 13

10 + 13 = 23
Yes, you win!
```

This is such a trivial example it does not necessarily warrant a solver script. But, let's use it to introduce and practice `pwntools`, which will be essential when our challenges get more complicated and when we want to send raw bytes (e.g., `12`) instead of the character representation of those bytes (e.g., `"12"`). 

We `pip3 install pwntools` and start a `pwntools` script by importing its functionality. We can then spawn this challenge locally with the `process` function, which returns a handle to the running process. With the process open, we can receive and send data to it, just like we would on the console.

```python
from pwn import *

p = process("./pwntools_example_fgets")
```

```console
[+] Starting local process './pwntools_example_fgets': pid 2915125
[*] Stopped process './pwntools_example_fgets' (pid 2915125)
$ 
```

However, if we run the script above, it just terminates. That's because the Python script finished running and thereby terminates the underlying process, whether or not _it_ is finished. We can hold open the process by connecting an interactive terminal, which effectively gives us a shell which can communicate with the process as we would on the command line:

```python
from pwn import *

p = process("./pwntools_example_fgets")
p.interactive()
```

```
[+] Starting local process './pwntools_example_fgets': pid 2915131
[*] Switching to interactive mode
Give me two numbers that add up to 23!
 > $  
```

Whenever we drop into an interactive shell, the `pwntools` `process` dumps the `stdout` buffer to console. This will not happen automatically during execution, though, as shown in the logging aboveâ€”the output is only logged _after_ dropping to the interactive shell. 

> `pwntools` hooks the `stdin` and `stdout` file descriptors for the process and allows us to communicate with them through various APIs, but will not automatically read from them like running a program on the command line.

At any point during execution, we can read from the process using `p.recv()` or `p.recvline()`. The first reads `stdout` and returns once data is available or the connection terminates. The second parses received data until it finds a newline (`\n`) character. If we instead want to receive until a different character or substring, say the `> ` in the program's prompt, we can use `p.recvuntil()` function. The return value for these functions is a byte string of all `stdout` data received until the condition is met. We can choose to `print` that data or store it in a variable for later use:

```python
from pwn import *

p = process("./pwntools_example_fgets")
print(p.recvuntil(b'> ').decode()) # decode from bytes to a string
p.interactive()
```

```
[+] Starting local process './pwntools_example_fgets': pid 2915152
Give me two numbers that add up to 23!
 > 
[*] Switching to interactive mode
```

> Interaction with running processes in `pwntools` always deals with bytes, not strings. `pwntools` will warn us and generally coerce our input from a string into bytes if we forget, but it is safer to be rigorous and make sure we send and receive bytes and not strings.

Now that we confirmed the process is ready for our input, we can send data with `p.send()` or `p.sendline()`. The latter appends a `\n` character to the end of whatever we supply, which is handy for functions like `fgets` which wait until a newline to finish ingesting input. Let's send our `"10"` and `"13"` input like we did on the command line, and then print whatever we receive from the program:

```python
from pwn import *

p = process("./pwntools_example_fgets")
p.sendline(b"10")
p.sendline(b"13")
print(p.recv())
p.interactive()
```

```
[+] Starting local process './pwntools_example_fgets': pid 2917443
b'Give me two numbers that add up to 23!\n'
[*] Switching to interactive mode
[*] Process './pwntools_example_fgets' stopped with exit code 0 (pid 2917443)
 >  > 
10 + 13 = 23
Yes, you win!
[*] Got EOF while reading in interactive
```

And we see that we do, in fact, win! At this point the program is finished, as indicated by the `Got EOF while reading in interactive` output from `pwntools`, so we can kill the interactive terminal. We just completed our first `pwntools` solver! But let's take a look at a slightly different program which highlights the importance of staying in sync with a running program.

### Syncing Input With a Program

The [[pwntools_example_read.c]] program is nearly identical program to [[pwntools_example_fgets.c]], just with one alteration: the program calls `read` instead of `fgets` to accept user input.

```diff
diff -u pwntools_example_fgets.c pwntools_example_read.c
--- pwntools_example_fgets.c	2024-07-21 17:27:05
+++ pwntools_example_read.c	2024-07-21 17:27:11
@@ -3,16 +3,14 @@
 #include "string.h"
 #include "unistd.h"
 
 // replace newline character at end of input with a null byte
 void replace_nl(char* buf) {
     char* nl = strchr(buf, '\n');
     if (nl) { *nl = '\0'; }
 }
 
 // get number from user and convert to long
 long get_number() {
     char buf[0x10];
-    fgets(buf, 0x10, stdin);
+    read(0, buf, 0x10);
     replace_nl(buf);
     return strtol(buf, NULL, 10);
 }
```

To understand the impact of this decision, we should consult the Linux manual (`man`) pages for each function. On a Linux machine, we run `man 2 read` and `man 3 fgets` to see more about the functions:

```
read(2)                                                         System Calls Manual                                                        read(2)

NAME
       read - read from a file descriptor

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include <unistd.h>

       ssize_t read(int fd, void buf[.count], size_t count);

DESCRIPTION
       read() attempts to read up to count bytes from file descriptor fd into the buffer starting at buf.



fgetc(3)                                                     Library Functions Manual                                                     fgetc(3)

NAME
       fgetc, fgets, getc, getchar, ungetc - input of characters and strings

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include <stdio.h>

       char *fgets(char s[restrict .size], int size, FILE *restrict stream);

DESCRIPTION

       fgets() reads in at most one less than size characters from stream and stores them into the buffer pointed to by s.  Reading stops after an
       EOF  or  a newline.  If a newline is read, it is stored into the buffer.  A terminating null byte ('\0') is stored after the last character
       in the buffer.
```

One striking difference (among others) is that `fgets` waits specifically for a `\n` character (or end of file), whereas `read` simply polls a file until it has input then grabs up to `count` bytes from the available buffer.

What result does this have on our solver? We can test by throwing our previous solver script against the compiled [[pwntools_example_read]] program to see if we can still solve the challenge.

```python
from pwn import *

p = process("./pwntools_example_read")
p.sendline(b"10")
p.sendline(b"13")
print(p.recv())
p.interactive()
```

```
[+] Starting local process './pwntools_example_read': pid 2917461
b'Give me two numbers that add up to 23!\n'
[*] Switching to interactive mode
 >  > $  
```

What we see is that the program seems to hang; there is no output, win or lose. We can try to use the interactive terminal to prod and see what is going on. Submitting `"1234"` on the command line shows the following output:

```
[+] Starting local process './pwntools_example_read': pid 2915255
Give me two numbers that add up to 23!
 > 
b' > '
[*] Switching to interactive mode
$ 1234

10 + 1234 = 1244
Nope, those add to 1244!
[*] Process './pwntools_example_read' stopped with exit code 0 (pid 2915255)
[*] Got EOF while reading in interactive
```

Something is clearly wrongâ€”the program accepts the `"10"` (based on the result), but it seems to be missing the second `"13"` input. How could this be? We clearly sent both in our solver script.

Whenever we find ourselves in a situation where our input seems to be missing or interpreted incorrectly, it is useful to leverage `pwntools` `context.log_level` feature. Specifically, we can turn it on `DEBUG` to log the sending and receiving of data from the process:

```python
from pwn import *

context.log_level = "DEBUG"

p = process("./pwntools_example_read")
p.sendline(b"10")
p.sendline(b"13")
print(p.recv())
p.interactive()
```

```
[+] Starting local process './pwntools_example_read' argv=[b'./pwntools_example_read'] : pid 2915342
[DEBUG] Sent 0x3 bytes:
    b'10\n'
[DEBUG] Sent 0x3 bytes:
    b'13\n'
[*] Switching to interactive mode
[DEBUG] Received 0x2d bytes:
    b'Give me two numbers that add up to 23!\n'
    b' >  > '
Give me two numbers that add up to 23!
 >  > $ 
```

What we see is that we are really out of sync with the process; we send both our inputs back to back, but don't bother processing any of the data from the program until we hit the interactive shell. What ends up happening in this situation is that we fill the process's `stdin` buffer with back to back input: `"10\n13\n"`. When the process attempts to `read` from that file, it ends up ingesting _all six bytes_ instead of just the first three! It converts `"10\n13\n"` to an integer with `strtol`, which rejects everything after the first `\n` since that is an invalid base-10 character. So it does successfully parse `"10"`, but ignores `"13"`. Once that finishes, the process waits for _the next input_. Since we have nothing more to send, it hangs on the second `read` call, awaiting our input. This is why interacting via the interactive shell allowed the program to complete!

We can circumvent this problem by staying in sync with the process using `recvuntil`. Our strategy is:
1. Wait until the server is ready for input with `p.recvuntil(b"> ")`
2. Send our first input
3. Wait until the server is ready for the second input with `p.recvuntil(b"> ")`
4. Send our second input

This should keep us in sync and ensure our inputs are parsed separately. Our updated script is as follows:

```python
from pwn import *

p = process("./pwntools_example_read")
print(p.recvuntil(b" > ").decode()) # decode from bytes to a string
p.sendline(b"10")
print(p.recvuntil(b" > ").decode()) # decode from bytes to a string
p.sendline(b"13")
p.interactive()
```

```console
[+] Starting local process './pwntools_example_read': pid 2915380
Give me two numbers that add up to 23!
 > 
 > 
[*] Switching to interactive mode
[*] Process './pwntools_example_read' stopped with exit code 0 (pid 2915380)

10 + 13 = 23
Yes, you win!
[*] Got EOF while reading in interactive
```

And we see from the output that we successfully solved the example for the `read` call! 

This synchronicity is increasingly important as we get into complex reverse engineering and exploitation, as our payloads may be multi-staged. Ensuring each stage is interpreted singularly can be the difference between success and failure.

### Server Communication

In almost all cases, our challenges will require interacting with a compiled C program running on a remote server. Using `nc` can be useful for simple challenges, but as challenges become more complex and require multiple interactions to make progress or corrupt memory, a command-line utility such as `nc` becomes unwieldy.

Instead, we can create a simple `pwntools` script and use its `remote` utility to connect to a remote server using hostname (or IP) and port. This establishes a TCP connection and handles most of the low-level communication with higher-level APIs. For instance, connecting to a server and receiving a challenge prompt is a simple as:

```python
from pwn import *

p = remote("127.0.0.1", 8888)
print(p.recv().decode())
```

Sending data back is a simple as:

```python
p.send(b"offsec\n")
```

### Other Tools

Note that you are allowed to solve challenges with whatever tools you are comfortable with, for example using Python `socket` instead of `pwntools`, or using another language entirely (writing solvers for compiled C targets in C is sometimes beneficial). However, `pwntools` continues to be a powerful tool in the toolbox of reverse engineers and exploit developers.

## Notes on Emulation

Reverse engineering and exploit development are most often easier when working with the best representation of the target system as possible. Our challenges will run in Ubuntu Linux with versions between 20.04 and 22.04. Any challenges that explicitly require targeting a particular OS or system utilities will be noted. That said, using a Linux machine on bare metal (no emulation) is the best representation of this target system because it does not risk any emulation inaccuracies. Using another Debian-based Linux machine will almost certainly be representative as well.

As mentioned previously, all target binaries in this course are `x86_64`. Emulating a Debian-based system through the use of VM software on an `x86_64` machine should be sufficient, as there is no translation between the host and target architecture. WSL on Windows has proven effective for some as well.

However, if you are nervous about your configuration and want to use a remote emulation option, skip ahead to the Cloud-based Approach section.

### M1/2 Emulation

Many researchers now own Apple M1/2 machines. While these devices are extremely efficient and powerful, they pose a challenge for this course. Their ARM architecture means we cannot run relevant binaries locally without some sort of architecture translation or emulation.

To date, VM software on the M1/2 has been difficult to work with or non-existent. If you can configure Parallels or VMWare Fusion such that it is running the challenge binaries locally, that would be a sufficient approach. QEMU is also a viable option. However, difficulties in emulation software and small emulation inaccuracies may require an alternative approach.

### Cloud-based Approach

If you do not have access to an `x86_64` device or other emulation capabilities, spinning up a small cloud instance of Ubuntu or Debian is a lightweight and effective strategy. Whether it be [AWS](https://aws.amazon.com/free/?all-free-tier.sort-by=item.additionalFields.SortRank&all-free-tier.sort-order=asc&awsf.Free%20Tier%20Types=*all&awsf.Free%20Tier%20Categories=*all), [GCP](https://cloud.google.com/), or [Digital Ocean](https://www.digitalocean.com/), these vendors all offer free or low-cost Debian-based OSs. SSH and SCP are your friends for logging in remotely and transferring files. This is an easy solution for folks who are familiar with the command-line and do not require a GUI to navigate the system. If you do not have this skill already, it may be worthwhile to take this opportunity to practice. Terminal text editors (`nano`, `vim`, `emacs`) work perfectly well in these environments, and Visual Studio Code [can also be configured via SSH](https://code.visualstudio.com/docs/remote/ssh) to edit remote files with a local GUI.

Note that `pwntools` requires a decent amount of memory for some of its functionality (specifically, the `ELF`, `ROP`, and `checksec` utilities we will introduce later). To avoid spinning up a new machine once those features are required, it is recommended to use a virtual instance with at least 4GB of RAM available. If cost is an issue, a cheaper (or free) instance can be used when that functionality is not required, and you can easily spin up and tear down a more powerful server when needed. You can quickly check whether your machine has enough RAM by running:

```sh
pip3 install pwntools
checksec --file=/usr/bin/cat
```

If you receive the following error, the VM does not have enough memory to perform some of the libraryâ€™s functionality (in this case, using `unicorn` to analyze the binary).Â Â 

```sh
$ checksec --file=/usr/bin/cat
Could not allocate dynamic translator buffer
```

If this occurs then check your version of `pwntools`; `pwntools` < v4.13 is likely the root cause of the error. If this is the case, create a new Python virtual environment in the directory of your choice with `python3 -m venv env`. This creates the `./env` directory along with an activation script `env/bin/activate`. Activate the script and install `pwntools` with:

```sh
source env/bin/activate
pip3 install pwntools
```

Note the version with `pip3 list` and searching for `pwntools`. It should be v4.13+. Try the `checksec`  command again or boot up a Python REPL and load a binary with `ELF`. Python should give a warning about not having enough memory but should display the `checksec` output and not fail.

```
$ python3
Python 3.10.12 (main, Sep 11 2024, 15:47:36) [GCC 11.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from pwn import *
>>> e = ELF("/usr/bin/cat")
[!] Could not populate PLT: Cannot allocate 1GB memory to run Unicorn Engine
[*] '/usr/bin/cat'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled
```

You are now free to use `pwntools` with `ELF` and `checksec` while your environment is active! The next time you SSH into your box, run `source env/bin/activate` again and you are good to go. No need to install `pwntools` again, it should remember your dependencies!

## Recitation

Each lesson includes recitation examples to reinforce key concepts and practice the skills learned from the content. Let's demonstrate our growing binary analysis and `pwntools` skills with the following examples:

#### Recitation0

Take a look at some of your Linux native binaries (e.g., `/bin/cat`, `/usr/bin/grep`, etc.) using the aforementioned command line tools. Answer the following questions:

1. Use `file` to investigate these binaries. Do they have PIE on? Are they dynamically or statically linked?
2. Use `readelf` to dump their symbols. Do you recognize any symbol names? Do the values printed for each symbol correspond to absolute addresses or offsets?
3. Many core linux utilities are stripped of symbols by default. Can you find any that are not?

#### Recitation1

Try to reach the `Great!` output condition in the [[recitation1.c]] example (compiled binary [[recitation1]]):

```c
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"
#include "string.h"

void replace_nl(char* buf) {
    char* nl = strchr(buf, '\n');
    if (nl) {
        *nl = '\0';
    }
}

int main() {
    char buf[0x20];
    puts("Hello! Tell me your name");
    read(0, buf, sizeof(buf));
    replace_nl(buf);
    printf("Hi %s! Do you like pwntools so far?\n", buf);
    read(0, buf, sizeof(buf));
    replace_nl(buf);
    if (!strcmp(buf, "y")) {
        puts("Great!");
    } else {
        puts("Bummer! Hopefully you'll grow to like it soon!");
    }
    return 0;
}
```

#### Recitation2

Try to reach the `Yeah, that's it!` output condition in the [[recitation2]] example (compiled binary [[recitation2]]):

```c
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"
#include "string.h"

static long SECRET = 0xdeadbeef;

void replace_nl(char* buf) {
    char* nl = strchr(buf, '\n');
    if (nl) {
        *nl = '\0';
    }
}

int main() {
    char buf[0x20];
    puts("Hello! Can I tell you a secret?");
    read(0, buf, sizeof(buf));
    replace_nl(buf);
    if (!strcmp(buf, "y")) {
        printf("My favorite number is %lx\n", SECRET);
        puts("Can you read that back to me?");
        read(0, buf, sizeof(buf));
        replace_nl(buf);
        long num = strtol(buf, NULL, 16);
        if (num == SECRET) {
            puts("Yeah, that's it!");
        } else {
            printf("Nope, not quite. You entered %lx\n", num);
        }
    } else {
        puts("Ok! Nevermind then");
    }
    return 0;
}
```

#### Recitation3

Try to reach the `Yeah, that's it!` output condition in the [[recitation3.c]] example (compiled binary [[recitation3]]). This example prints out raw bytes, which we can capture using `pwntools` receive functions (doing so on the command line can be a pain). Try capturing the output and using `pwntools`'s `u64(b)` method to convert eight little-endian bytes in `b` into a integer. Or, use the Python built-in `int.from_bytes(b, "little")` to do the same.

```c
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"
#include "string.h"

static long SECRET = 0xdeadbeef;

void replace_nl(char* buf) {
    char* nl = strchr(buf, '\n');
    if (nl) {
        *nl = '\0';
    }
}

int main() {
    char buf[0x20];
    puts("Hello! Can I tell you a secret?");
    read(0, buf, sizeof(buf));
    replace_nl(buf);
    if (!strcmp(buf, "y")) {
        puts("My favorite number is ");
        write(1, &SECRET, 0x8);
        puts("");
        puts("Can you read that back to me?");
        read(0, buf, sizeof(buf));
        replace_nl(buf);
        long num = strtol(buf, NULL, 16);
        if (num == SECRET) {
            puts("Yeah, that's it!");
        } else {
            printf("Nope, not quite. You entered %lx\n", num);
        }
    } else {
        puts("Ok! Nevermind then");
    }
    return 0;
}
```

#### Recitation4

Try to reach the `Yeah, that's it!` output condition in the [[recitation4.c]] example (compiled binary [[recitation4]]). This example requires us to input raw bytes, which we can do using `pwntools` send functions (doing so on the command line can be a pain). Try using `pwntools`'s `p64(i)` method to convert integer `i` into eight little-endian bytes. Or, use the Python built-in `i.to_bytes(8, "little")` to do the same.

```c
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"
#include "string.h"

static long SECRET = 0xdeadbeef;

void replace_nl(char* buf) {
    char* nl = strchr(buf, '\n');
    if (nl) {
        *nl = '\0';
    }
}

int main() {
    char buf[0x20];
    puts("Hello! Can I tell you a secret?");
    read(0, buf, sizeof(buf));
    replace_nl(buf);
    if (!strcmp(buf, "y")) {
        puts("My favorite number is ");
        write(1, &SECRET, 0x8);
        puts("");
        puts("Can you read that back to me?");
        read(0, buf, sizeof(buf));
        replace_nl(buf);
        if (*(long*)buf == SECRET) {
            puts("Yeah, that's it!");
        } else {
            printf("Nope, not quite. You entered %lx\n", *(long*)buf);
        }
    } else {
        puts("Ok! Nevermind then");
    }
    return 0;
}
```

#### Recitation 5

Try connecting to one of the weekly challenges with `nc` to see how it operates. Next, try creating a short `pwntools` script using `remote(ip, port)` to connect to it using Python. Ensure you can send and receive data from the remote server similar to the prior recitation examples that spawned binaries locally on the system.

## Next Steps

This was predominantly a review of operating systems content and a brief introduction into the `pwntools` utility we leverage heavily in this course. In the next lesson, we reinforce our mental model of binary memory layout using GDB, the state-of-the-art dynamical analysis tool for ELF binaries. We also take a look at static analysis tooling on the command line and in decompilers to aid in our reverse engineering efforts.
