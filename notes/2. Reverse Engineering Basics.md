1. goal
2. what's going wrong
3. what have I tried
4. what are my assumptions
5. what do I already know
^ problem-solving framework / Q-asking template



Print out variables in GDB
	h - half word 
	w - word
- short
	- x/1hx &value
		- print out the things stored at the variable "value" (&value is the memory addr), interpret it as one (1) half-word (h), print out the value in hex (x)
- x/8xb 0x12315adeef
		- print 8 bytes (8b) each thing in hex, starting from the memory location 0x12315adeef

x/ is the command for give me the value at this address



[[1. Reverse Engineering Tools|The prior]] lesson covered a handful of reverse engineering tools for static and dynamic analysis. In this lesson we'll increase our understanding of compiled binaries and apply these tools to more complicated examples. First, we'll start by reviewing some data types and then see how these types are referenced in memory in a single example. This lesson concludes with reverse engineering a practical example without access to source code.

Table of Contents:
- [[#What is a Byte?]] 
- [[#What is a Pointer]]
- [[#Decompiling a Simple Program]]
	- [[#Basic clean-up in Ghidra]] 
	- [[#Basic clean-up in Binja]]
- [[#Disassembling a Simple Program]]
	- [[#Basics of Control Flow]]
		- [[#Calling Convention]]
		- [[#Branching Instructions]]
		- [[#Prologue and Epilogue]]
	- [[#Moving Data into Registers]]
- [[#Practical Example]]
- [[#Recitation]]

## What is a Byte?

We are probably all familiar with standard C data types: `char, short, int, long`, etc. But what does that mean in terms of how the data is represented in memory? Philosophically, what is a `short`? Is a `short` always a `short`? Can a `short` also be a `char`? 

C gives us the flexibility to treat any range of memory as any data type by casting data. For example, we can cast a `short` to a `char` to get only the lowest byte.

```c
short b = 0x2120;
printf("0x%x\n", (char)b);
// prints 0x20 - the least significant byte in little-endian 
```

How is this possible? Because binary memory is free from any explicit typing; page permissions control if we can read/write/execute bytes at specific addresses, however permissions do not restrict how the data is interpreted within those permissions. Data types from the higher level (C) programming language impact how the data is interpreted, such as in the example above. This will be even more important for us as we transition into exploitation, as we can force the system to interpret data in a way the program did not intend and generate "weird" behavior.  

Let’s take a look at different ways to interpret data in memory. Say we have an RWX page (which is unrealistic for modern systems, but will reinforce the point) with data as shown below:

```
0x400000: 0x49, 0xC7, 0xC4, 0x37, 0x13, 0x00, 0x00, 0x90
```

These eight bytes could be interpreted a number of ways. Below are some of the possibilities. _Note that this is assumed to be a little-endian architecture, which influences how multi-byte data types are interpreted_:
- `char`: Interpreting the data at address `0x400000` would simply grab the first byte, `0x49`. We can print this as a number (`0x49` or `73`) with format string modifiers `%hhx` or `%hhd`, or as a letter with modifier `%c`, which yields `I`
- `char[8]`: Interpreting this as a byte array yields `[0x49, 0xC7, 0xC4, 0x37, 0x13, 0x00, 0x00, 0x90]`. Note that a `char[]` should be seen as an array of single bytes that contains both printable _and non-printable_ characters
	- an array of bytes - gets printed in order. No endian-ness needs to be considered. 
- `short`: This would grab the first two bytes in little-endian, returning `0xc749`
	- lesson: in memory, the LEAST significant byte gets put first. Therefore, considering the first two bytes, the LEAST significant byte is 0x49 and the MOST significant byte is 0xC7. Therefore, as a number, this short is: 0xC749
- `int`: This would similarly take the first four bytes in little endian: `0x37c4c749`
- `long long`: This would get all eight bytes in little endian: `0x9000001337c4c749`. This is a very large number
- `void*`: If we interpret this as a pointer to some object or primitive, now it is an address `0x9000001337c4c749`, which may (or may not, depending on page mappings) have some data residing there
- Instructions: If this page is executable and we set `RIP` to `0x400000` then these bytes are interpreted as instruction operation codes for the following two instructions: `mov r12, 0x1337; nop`
  
One common error when interpreting bytes is the misconception that a `char` is always a printable character. `man ascii` shows us the ASCII table of printable characters and their "value" in memory. But a `char` data type includes both printable and non-printable characters with values from `0x0-0xff`. It is therefore useful to reframe our perspective for `char` and `unsigned char` and instead think of them as `int8_t` and `uint8_t` data types—that is, they are the primitive representation of a single byte of data. If we want the number `0x31`, we can store it as a `char` or `unsigned char` in memory. Any mathematical operations on that byte will be performed with no issue. And we can always cast it to a printable character (`1`) using the `%c` format string. Similarly, storing `char c = ‘1’` in memory will also store `0x31` in memory, and we could perform math on that value with no issue. 
- not all chars are printable
	- why? 1 char is 8 bits. There are some sequences of 8 bits that don't correspond to any ASCII character

> It’s important to understand that ASCII printable characters (what we typically associate with a `char`) are no different than single-byte integers in memory; all that matters is how we (or the program) interpret that value in memory.

```c
char c = 0x41;                                                                 
printf("0x%hhx\n", c);
printf("%c\n", c);    
// prints the following:
// 0x41
// A
```

## What is a Pointer

def (pointer) = a variable that holds a memory address (pts to this addr)
	 -deref the pointer means access the value housed at that memory addr

Full mastery of reverse engineering and exploiting C programs requires that we be very comfortable with the concept of pointers. Pointers are always `usize` bytes long (eight bytes for 64-bit systems) and have an address as their value. What data resides in that address is defined by how the program uses it, just like our discussion of [[#What is a Byte?]] above. Pointers must be defined with a type, which dictates the default behavior of how they are used:

```c
int my_int = 10;   // in memory: 0x 0a 00 00 00 (little endian)
int* int_ptr = &my_int;
*int_ptr = 20;
printf("My int has value %d\n", my_int);
// prints out "My int has value 20"
```

10 (decimal) = 0xa (big endian) = 0x 0000000a (big endian) = 0x 0a 00 00 00 (little endian)


The above code reserves four bytes on the stack for an integer, `my_int` and eight bytes on the stack for an address, `int_ptr`. We assign the _value of the pointer as the address of our `my_int` variable (a stack address)_. We can then use the unary `*` dereference operator to access the memory _pointed to_ by `int_ptr` and assign it a value of `20`. Because `int_ptr` holds the address of `my_int`, the memory for `my_int` is updated to 20.

Pointers can become a lot more complicated, especially when we get into multiple references (`void** ptrptr;`) and the heap. So long as we are comfortable with understanding that pointers store _an address_ as their value and that address can be accessed by dereferencing the pointer, we have a good foundation for handling pointers in disassembly.

Let's move on to looking at our first program in detail, first through decompilation and then disassembly!

## Decompiling a Simple Program

Consider [[first_example.c||the following first_example.c program]], which is a toy example of a function that takes in a character representation of a number (such as the character `'0'`) from the user and iterates through the ASCII alphabet for 10 characters. The loop breaks when either 10 characters are logged or we reach ASCII symbols with values between `Z` and `a` (`0x5b - 0x61`). For each character, if the iterator is odd it prints the ASCII character, otherwise it prints the hexadecimal value for that character. As discussed in the previous section, these characters exist as single-byte integer values in memory but can be cast as ASCII characters if we so choose.

```c
// first_example.c
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "unistd.h"

int main() {
    char buf[0x10];
    printf("> ");
    fgets(buf, sizeof(buf), stdin);
    char start = (char)atoi(buf);
    char i = start;

    while (1) {
        if (i == start + 10) {
	        puts("\n");
	        return 0;
	    }
        char c = (i + 'A'); // adding a char to a char
        // performing a char to char comparison
        if (c > 'z' || (c < 'a' && c > 'Z')) {
            puts("\n");
            return 1;
        }
        if (i % 2 == 0) { // performing a mathematical operation on a char
	        printf("%x ", c);
	    }
        else {
	        printf("%c ", c);
	    }
        i += 1; // performing a mathmatical operation on a char
    }
    puts("\n");
    return 0;
}
```

For example:

```sh
$ ./first_example 
> 2
43 D 45 F 47 H 49 J 4b L
```

### Basic clean-up in Ghidra

The resulting decompilation of the compiled [[first_example]] in Ghidra is shown below:

```c
undefined8 main(void)

{
  char cVar1;
  int iVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  byte local_2b;
  char local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  printf("> ");
  fgets(local_28,0x10,stdin);
  iVar2 = atoi(local_28);
  local_2b = (byte)iVar2;
  do {
    if ((int)(char)local_2b == (char)(byte)iVar2 + 10) {
      puts("\n");
      uVar3 = 0;
LAB_001012d0:
      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
        __stack_chk_fail();
      }
      return uVar3;
    }
    cVar1 = local_2b + 0x41;
    if (('z' < cVar1) || ((cVar1 < 'a' && ('Z' < cVar1)))) {
      puts("\n");
      uVar3 = 1;
      goto LAB_001012d0;
    }
    if ((local_2b & 1) == 0) {
      printf("%x ",(ulong)(uint)(int)cVar1);
    }
    else {
      printf("%c ",(ulong)(uint)(int)cVar1);
    }
    local_2b = local_2b + 1;
  } while( true );
}
```

Despite being such a simple function, written in C, it is difficult to immediately identify what the function does. Some simple cleanup can help ground our understanding. For example:
1. We know that the return value for `main` is always an integer, so we can change the function signature to reflect that. This is supported by the fact that `uVar3`, which is returned, is assigned either a 0 or 1. Let's name this to something like `retval` since it is the return code. This could mean the function returns a `char` or a `short`, however we know main returns an `int`. Overwriting the function signature will automatically change the type for `retval`. We can also update the arguments for `main` [since those are known as well](https://en.cppreference.com/w/c/language/main_function)
2. `LAB_001012d0` is a bit tricky if you have not seen it before, though the function call in its block gives a hint. It compares a value pulled from the `fs` register to a value placed on the stack. If the comparison is a match, it returns. If not, it calls `__stack_chk_fail`. This is a `canary` check—a measure added by compilers to make sure that there is no stack buffer overflow. This check always occurs at the end of the function, so we can name it something like `canary_check_and_ret`

I THINK THIS WILL BE USEFUL FOR CHALLENGES:
4. User input is placed into a stack buffer through a call to `fgets(local_28,0x10,stdin);`. The second argument to `fgets` is a buffer size, so it’s logical to assume that `local_28` has size `0x10`. This update actually cleans up the stack to show that a `long`representing the canary is stored right after the buffer. This makes sense from a security standpoint, since any overflow to the stack buffer would clobber the next value, the canary, and trigger a failure when the program performs the check
5. It looks like the input is converted into an integer with `atoi` and then cast to a `byte`. Consequently, we can name `local_2b` something like `input_byte`
6. The `cVar1 = input_byte + 0x41` code is a clever trick to convert the counter to the printable letter we desire by offsetting from `0x41`, which is `'A'`. We can call this `printable_byte` for quick reference

These simple updates help make more sense of the program’s entry and exit!

```c
int main(int argc,char **argv,char **envp)

{
  char printable_byte;
  int retval;
  long in_FS_OFFSET;
  char buf [16];
  long canary;
  
  canary = *(long *)(in_FS_OFFSET + 0x28);
  printf("> ");
  fgets(buf,0x10,stdin);
  retval = atoi(buf);
  input_byte = (byte)retval;
  do {
    if ((int)(char)input_byte == (char)(byte)retval + 10) {
      puts("\n");
      retval = 0;
canary_check_and_ret:
      if (canary != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
        __stack_chk_fail();
      }
      return retval;
    }
    printable_byte = input_byte + 0x41;
    if (('z' < printable_byte) || ((printable_byte < 'a' && ('Z' < printable_byte)))) {
      puts("\n");
      retval = 1;
      goto canary_check_and_ret;
    }
    if ((input_byte & 1) == 0) {
      printf("%x ",(ulong)(uint)(int)printable_byte);
    }
    else {
      printf("%c ",(ulong)(uint)(int)printable_byte);
    }
    input_byte = input_byte + 1;
  } while( true );
}
```

### Basic clean-up in Binja

Let's do the same in Binja to see some of the differences in its decompiler and its Pseudo-C representation. The initial decompilation of `main` is below:

```c
int32_t main(int32_t argc, char** argv, char** envp)

{
    void* fsbase;
    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);
    printf(&data_2004);
    void var_28;
    fgets(&var_28, 0x10, __TMC_END__);
    char rax_2 = atoi(&var_28);
    char var_2b = rax_2;
    int32_t rax_6;
    while (true)
    {
        if (((int32_t)var_2b) == (((int32_t)rax_2) + 0xa))
        {
            puts(&data_2007);
            rax_6 = 0;
            break;
        }
        if (((var_2b + 0x41) <= 0x7a && ((var_2b + 0x41) > 0x60 || ((var_2b + 0x41) <= 0x60 && (var_2b + 0x41) <= 0x5a))))
        {
            if ((var_2b & 1) != 0)
            {
                printf(&data_200d, ((uint64_t)((int32_t)(var_2b + 0x41))));
            }
            else
            {
                printf(&data_2009, ((uint64_t)((int32_t)(var_2b + 0x41))));
            }
            var_2b = (var_2b + 1);
            continue;
        }
        puts(&data_2007);
        rax_6 = 1;
        break;
    }
    *(uint64_t*)((char*)fsbase + 0x28);
    if (rax == *(uint64_t*)((char*)fsbase + 0x28))
    {
        return rax_6;
    }
    __stack_chk_fail();
    /* no return */
}
```

Notice that it automatically recognizes the function signature for `main` along with the parameter names for some C-standard function calls. However, some information is convoluted. Let's apply the same modifications as to the Ghidra decompilation, along with the following changes:
* Wherever we see references to the data section (e.g., `&data_200d`), double click and see what their data shows. If it is a short null-terminated string (`data_2007: 0a 00`) we can convert this to a `char[]` data type using the `a` hotkey. Binja does not automatically treat any short strings (less than 3 printable bytes followed by a null terminator) as a string so we must define them ourselves. This cleans up the short strings used in `printf` and `puts`.

```
uint32_t _IO_stdin_used = 0x20001
char data_2004[0x3] = "> ", 0
char data_2007[0x2] = "\n", 0
char data_2009[0x4] = "%x ", 0
char data_200d[0x4] = "%c ", 0
```

* Binja represents the third argument to `fgets` as `__TMC_END__`, which is odd. We would expect this to be a `FILE*` type given the [function signature for `fgets`](https://man7.org/linux/man-pages/man3/fgets.3p.html). Let's use `readelf` to see if there is any other symbol information at this address. It appears that Binja automatically grabs the hidden `tm_clone_table` symbol, but this is also a reference to `stdin` in glibc. We can rename this `_stdin` for our own benefit (Binja won't let us rename to `stdin` because that is a reserved symbol name already).

```sh
$ readelf -Ws first_example | grep 4010
    11: 0000000000004010     8 OBJECT  GLOBAL DEFAULT   26 stdin@GLIBC_2.2.5 (3)
    22: 0000000000004010     8 OBJECT  GLOBAL DEFAULT   26 stdin@GLIBC_2.2.5
    23: 0000000000004010     0 NOTYPE  GLOBAL DEFAULT   25 _edata
    34: 0000000000004010     0 NOTYPE  GLOBAL DEFAULT   26 __bss_start
    37: 0000000000004010     0 OBJECT  GLOBAL HIDDEN    25 __TMC_END__
```

The resulting decompilation is a bit different from Ghidra, but communicates the same information.

```c
int32_t main(int32_t argc, char** argv, char** envp)

{
    void* fsbase;
    int64_t canary = *(uint64_t*)((char*)fsbase + 0x28);
    printf("> ");
    char buf[0x10];
    fgets(&buf, 0x10, _stdin);
    char input_byte_1 = atoi(&buf);
    char input_byte = input_byte_1;
    int32_t retval;
    while (true)
    {
        if (((int32_t)input_byte) == (((int32_t)input_byte_1) + 0xa))
        {
            puts("\n");
            retval = 0;
            break;
        }
        if (((input_byte + 0x41) <= 0x7a && ((input_byte + 0x41) > 0x60 || ((input_byte + 0x41) <= 0x60 && (input_byte + 0x41) <= 0x5a))))
        {
            if ((input_byte & 1) != 0)
            {
                printf("%c ", ((uint64_t)((int32_t)(input_byte + 0x41))));
            }
            else
            {
                printf("%x ", ((uint64_t)((int32_t)(input_byte + 0x41))));
            }
            input_byte = (input_byte + 1);
            continue;
        }
        puts("\n");
        retval = 1;
        break;
    }
    *(uint64_t*)((char*)fsbase + 0x28);
    if (canary == *(uint64_t*)((char*)fsbase + 0x28))
    {
        return retval;
    }
    __stack_chk_fail();
    /* no return */
}
```

## Disassembling a Simple Program

Now that we have a feel for decompilation (Turn 0/1 into src code), let's dive into the disassembly (Turn 0/1 into assembly code) of this program. As mentioned previously, decompilation is just the decompiler and reverse engineer's _best guess_ at a program's source representation. Sometimes decompilation fails to accurately recreate a program's behavior and we need another source of information to understand how it works. This is when we turn to disassembly.

> Assembly instructions are the "ground truth" of a program. These are literally the instructions that the CPU executes and thus are a direct representation of program behavior.

The downside to disassembly is that it is tedious and typically takes longer to understand than a higher level representation. But that shouldn't discourage us from learning it! In fact, we should be very motivated to learn it because we will rely on it more and more heavily the more complicated our target programs become.

Let's now take a look at `main`in disassembly with `objdump`:

```
$ objdump --disassemble=main -M intel first_example
00000000000011c9 <main>:
    11c9:	f3 0f 1e fa          	endbr64
    11cd:	55                   	push   rbp
    11ce:	48 89 e5             	mov    rbp,rsp
    11d1:	48 83 ec 30          	sub    rsp,0x30
    11d5:	64 48 8b 04 25 28 00 	mov    rax,QWORD PTR fs:0x28
    11dc:	00 00 
    11de:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    11e2:	31 c0                	xor    eax,eax
    11e4:	48 8d 05 19 0e 00 00 	lea    rax,[rip+0xe19]        # 2004 <_IO_stdin_used+0x4>
    11eb:	48 89 c7             	mov    rdi,rax
    11ee:	b8 00 00 00 00       	mov    eax,0x0
    11f3:	e8 b8 fe ff ff       	call   10b0 <printf@plt>
    11f8:	48 8b 15 11 2e 00 00 	mov    rdx,QWORD PTR [rip+0x2e11]        # 4010 <stdin@GLIBC_2.2.5>
    11ff:	48 8d 45 e0          	lea    rax,[rbp-0x20]
    1203:	be 10 00 00 00       	mov    esi,0x10
    1208:	48 89 c7             	mov    rdi,rax
    120b:	e8 b0 fe ff ff       	call   10c0 <fgets@plt>
    1210:	48 8d 45 e0          	lea    rax,[rbp-0x20]
    1214:	48 89 c7             	mov    rdi,rax
    1217:	e8 b4 fe ff ff       	call   10d0 <atoi@plt>
    121c:	88 45 de             	mov    BYTE PTR [rbp-0x22],al
    121f:	0f b6 45 de          	movzx  eax,BYTE PTR [rbp-0x22]
    1223:	88 45 dd             	mov    BYTE PTR [rbp-0x23],al
    1226:	0f be 55 dd          	movsx  edx,BYTE PTR [rbp-0x23]
    122a:	0f be 45 de          	movsx  eax,BYTE PTR [rbp-0x22]
    122e:	83 c0 0a             	add    eax,0xa
    1231:	39 c2                	cmp    edx,eax
    1233:	75 19                	jne    124e <main+0x85>
    1235:	48 8d 05 cb 0d 00 00 	lea    rax,[rip+0xdcb]        # 2007 <_IO_stdin_used+0x7>
    123c:	48 89 c7             	mov    rdi,rax
    123f:	e8 4c fe ff ff       	call   1090 <puts@plt>
    1244:	b8 00 00 00 00       	mov    eax,0x0
    1249:	e9 82 00 00 00       	jmp    12d0 <main+0x107>
    124e:	0f b6 45 dd          	movzx  eax,BYTE PTR [rbp-0x23]
    1252:	83 c0 41             	add    eax,0x41
    1255:	88 45 df             	mov    BYTE PTR [rbp-0x21],al
    1258:	80 7d df 7a          	cmp    BYTE PTR [rbp-0x21],0x7a
    125c:	7f 0c                	jg     126a <main+0xa1>
    125e:	80 7d df 60          	cmp    BYTE PTR [rbp-0x21],0x60
    1262:	7f 1c                	jg     1280 <main+0xb7>
    1264:	80 7d df 5a          	cmp    BYTE PTR [rbp-0x21],0x5a
    1268:	7e 16                	jle    1280 <main+0xb7>
    126a:	48 8d 05 96 0d 00 00 	lea    rax,[rip+0xd96]        # 2007 <_IO_stdin_used+0x7>
    1271:	48 89 c7             	mov    rdi,rax
    1274:	e8 17 fe ff ff       	call   1090 <puts@plt>
    1279:	b8 01 00 00 00       	mov    eax,0x1
    127e:	eb 50                	jmp    12d0 <main+0x107>
    1280:	0f b6 45 dd          	movzx  eax,BYTE PTR [rbp-0x23]
    1284:	83 e0 01             	and    eax,0x1
    1287:	84 c0                	test   al,al
    1289:	75 1c                	jne    12a7 <main+0xde>
    128b:	0f be 45 df          	movsx  eax,BYTE PTR [rbp-0x21]
    128f:	89 c6                	mov    esi,eax
    1291:	48 8d 05 71 0d 00 00 	lea    rax,[rip+0xd71]        # 2009 <_IO_stdin_used+0x9>
    1298:	48 89 c7             	mov    rdi,rax
    129b:	b8 00 00 00 00       	mov    eax,0x0
    12a0:	e8 0b fe ff ff       	call   10b0 <printf@plt>
    12a5:	eb 1a                	jmp    12c1 <main+0xf8>
    12a7:	0f be 45 df          	movsx  eax,BYTE PTR [rbp-0x21]
    12ab:	89 c6                	mov    esi,eax
    12ad:	48 8d 05 59 0d 00 00 	lea    rax,[rip+0xd59]        # 200d <_IO_stdin_used+0xd>
    12b4:	48 89 c7             	mov    rdi,rax
    12b7:	b8 00 00 00 00       	mov    eax,0x0
    12bc:	e8 ef fd ff ff       	call   10b0 <printf@plt>
    12c1:	0f b6 45 dd          	movzx  eax,BYTE PTR [rbp-0x23]
    12c5:	83 c0 01             	add    eax,0x1
    12c8:	88 45 dd             	mov    BYTE PTR [rbp-0x23],al
    12cb:	e9 56 ff ff ff       	jmp    1226 <main+0x5d>
    12d0:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
    12d4:	64 48 2b 14 25 28 00 	sub    rdx,QWORD PTR fs:0x28
    12db:	00 00 
    12dd:	74 05                	je     12e4 <main+0x11b>
    12df:	e8 bc fd ff ff       	call   10a0 <__stack_chk_fail@plt>
    12e4:	c9                   	leave
    12e5:	c3                   	ret
```

As expected, assembly takes many more instructions to represent the program's behavior than C (hence why we write C instead of assembly :)). Let's take a look at a couple key components.

### Registers

Registers are special memory units in the CPU that load and store information and are used for computations. Some think of registers as special "variables" in the CPU. Whether you chose to adopt that mental model is up to you, but make sure that you do not convolute registers with local or global variables in C. Sometimes there is a 1:1 correlation between the two, but more often than not a single local variable is handled by multiple registers at various points in execution.

x86_64 defines the following 8-byte "general purpose" CPU registers (total 16, each 8 byte; all registers are 16x8 = 128 bytes total). Not included but extremely important is the `rip` register which maintains the value for the instruction pointer (program counter):
- rax - function return values usually go in here
- rbx
- rcx
- rdx
- rbp - stack base pointer (bp)
- rsp - stack pointer (points to top item on the stack; "points to" means stores the mem. addr of)
- rsi
- rdi - where puts() function gets its argument from 
- r8
- r9
- r10 
- r11 
- r12 
- r13 
- r14 
- r15 

- rip points to the currently executing instruction 
- eax is the bottom (least significant) 4 bytes of rax
	- eax is nested within rax
- 

`rbp` is generally reserved for the stack base pointer and `rsp` for the current stack pointer. Obviously a program may require far more than 16 local variables, which is why functions use stack frames as a "scratch space" to store and load values as needed.

Each general purpose register is capable of storing eight bytes of data. The 'r' prefix in these registers refers to all eight bytes (including leading 0s, if present). However, it is handy to reference subsets of the eight bytes in a register, specifically when considering backwards compatibility with 32-bit systems that only have four-byte registers. We can refer to the lower 32 bits in each register by using the 'e' prefix (e.g., `eax, ebx, ecx, esi`, etc.). Registers can be prefixed to reference the lowest 16 bits and lowest 8 bits, and some can directly reference bits 8-16 (high eight bits of the 16-bit register). Torall Networks has a [good overview here](https://www.tortall.net/projects/yasm/manual/html/arch-x86-registers.html), including the image below to show this concept visually.

![[register_reference_tortall_networking.png]]
_Source: https://www.tortall.net/projects/yasm/manual/html/arch-x86-registers.html_

We'll see how registers are manipulated in the following sections.

### Basics of Control Flow

Understanding control flow is a foundational requirement for recognizing program behavior and leveraging vulnerabilities during binary exploitation. Control flow includes the sequence of execution (the movement of the program counter, register `rip`) and how data flows in and out of registers and memory. Let's take a look at some basic concepts of control flow that we will see time and time again in future lessons.

#### Calling Convention

Functions are imperative to C programming, whether or not [_pure functional programming_](https://en.wikipedia.org/wiki/Functional_programming) is implemented. Functions calculate an output or transform data given some input. The compiler must set up the function's expected state whenever we call it and clean up the state so the program can continue after it returns. These stipulations are defined in an architecture's _calling convention_.

The default [calling convention for x86_64](https://cs61.seas.harvard.edu/site/2018/Asm2/) on Linux is the _System V AMD64 ABI_. There are some specifics we should absolutely be aware of as we reverse engineer programs. The first is how arguments are loaded in preparation for a function call. **

- The first six arguments are stored in registers `rdi, rsi, rdx, rcx, r8, r9`, in that order**. 

Any additional arguments are pushed to the stack in reverse order immediately before the call. For example, consider the call to `fgets(buf, sizeof(buf), stdin);` in our program. The program loads the values for each argument: a pointer to the `FILE* stdin` structure into `rdx`, a stack address relative to `rbp` into `rax` and then `rdi` for our stack-allocated `buf`, and then the size of the buffer `0x10` into `rsi`.

```nasm
    11f8:	48 8b 15 11 2e 00 00 	mov    rdx,QWORD PTR [rip+0x2e11]  # 4010 <stdin@GLIBC_2.2.5>
    11ff:	48 8d 45 e0          	lea    rax,[rbp-0x20]
    1203:	be 10 00 00 00       	mov    esi,0x10
    1208:	48 89 c7             	mov    rdi,rax
    120b:	e8 b0 fe ff ff       	call   10c0 <fgets@plt>
```

Calling convention is how decompilers make educated guesses as to the number of arguments to each function. But they can be wrong, so it is always worth double-checking the disassembly prior to a function call.
- when you see mov right before a function is called, the system is likely moving this upcoming function's arguments into the correct registers
	- This is how decompilers like Binary Ninja make educated guesses about the upcoming function's arguments
	- However, that is not the case always! Things can be moved into register and they may not be used in this upcoming function at all.
		- In this case, Binary Ninja will tell us wrong things about the function

Calling the function occurs through the `call` instruction with an address or offset as its operand. Because this is a PIE binary, the address is simply the `0x10c0` offset from the current instruction. This offset jumps us to a stub in the binary's `plt` section (we'll cover more on the `plt` and `got` sections in later weeks) that then calls `fgets`in glibc.

The calling convention also states that the return value (if there is one) is loaded into `rax` as the function ends. We use the return value from the `atoi` call with the following C code: `char start = (char)atoi(buf);` as an example. The compiler manipulates the return from `atoi` by casting the 64-bit value in `rax` to extract an 8-bit `char` (`al`) that is then stored in a local (stack) variable at `rbp-0x22` (we look more at pointer instructions in the [[#Moving Data into Registers]] section):

```nasm
    1217:	e8 b4 fe ff ff       	call   10d0 <atoi@plt>
    121c:	88 45 de             	mov    BYTE PTR [rbp-0x22],al
```

A function's arguments and return value are key pieces of information used to understand its signature and get a feel for its purpose. We use this information repeatedly over the next weeks, so make sure you feel comfortable with the short snippets of assembly in this section!

There are other calling convention rules, such as caller- and callee-saved registers, stack pointer alignment and base pointer movement that we will cover in later lessons.

#### Branching Instructions

As we continue digging into assembly we see a lot of `jmp`, `jne`, etc. instructions. These are jump instructions which move an address into `rip` that is not the next instruction in the linear disassembly. [Jumps can be conditional](http://www.unixwiz.net/techtips/x86-jumps.html), which is helpful for `if` and `while` statements. Instructions between jumps form a _basic block_—a block of code that is executed linearly because there are no branching instructions that could deviate flow from executing each instruction in order.

We can view a graph representation of a function in our decompilers to help understand the control flow of the program. Ghidra's `Display Function Graph` ![[display_graph_view.png]]   toolbar icon shows this graph, but the output of Ghidra's graph representations are rather ugly. We will leverage Binja for this example instead. Simply open a function and press `<space>` to switch between graph and linear view.

![[binja_graph_view.png]]

_Branches_ in the program flow are represented as arrows that connect basic blocks. Conditional branches are generally preceded by a comparison `cmp` instruction followed by a jump based on the result of the comparison (e.g., jump if not zero, `jnz`). Another form of branching is the end of a loop where program control jumps back to the beginning. We can clearly see the `while` loop represented with a branch from `0x12cb` to `0x1226`. Binja represents the matching condition (passing the `if` condition) with a green branch and the non-matching condition as a red branch. Branches that always execute (like the bottom of a `while` loop) are blue.

Note that there is no branch at the `ret` instruction which ends the function. `ret` is certainly a branching instruction because `rip` is modified. But since the return value depends on the calling function, Binja cannot represent that with certainty (a number of functions may call a single function, so there may be a number of viable return points!).

Similarly, `call` instructions are also branching instructions. They are not shown with branches because the graph would quickly become too complicated. We can always double-click to investigate the call site if we want to dive into the callee function's instructions. `call` instructions are shown within basic blocks because we know that, whenever the sub-function call(s) returns, the next instruction executed will be one pushed during the `call` instruction (the instruction immediately following the call).

> One of the great things about Binja is that it has a higher level graph view for both HLIL and Pseudo-C! This really cleans up the graph. As with all decompilation, it should only be fully trusted after vetting and understanding the function of interest. Still, it is very useful for getting an initial understanding and guiding our investigation as we dive into disassembly.
> ![[binja_graph_view_pseudoc.png]]

#### Prologue and Epilogue
- eye opening
	- functions get loaded into memory when a program runs
	- where is the stack? 
		- it does not exist in a separate memory space
		- it's defined by the rbp and rsp
		- whereever they point to, the area between defines the stack
	- so, the functions stay put, but the stack moves around as we run the program and execute different functions!!
- every time you enter a function (B) from another function (A):
	- rip register points to B
	- store rbp's value (A's stack base pointer; think of as the start of A) somewhere
	- change rbp to start of B
	- push onto the stack the return address (where do we go after B finishes executing)
	- push onto the stack B's locals 
	- change rsp to the top item B's things
- Push onto the stack
	- rmb stack grows downwards 
	- high up there means high memory addresses
	- so, whenever you push something on the stack, you would decrement the stack pointer
- (assembly) leave operation is used when a function finishes. the rsp gets rbp's value, and previous rbp's value gets loaded into rbp


Assembly languages define calling conventions which influence the first and last instructions in a function. These blocks of code are called prologues and epilogues, respectively. We can see them in action in `main`'s decompilation.

Before a function's prologue, the program typically `call`s that function from another function. For instance, `main` is called by a glibc function `__libc_start_call_main`. The `call` instruction in x86_64 pushes the next instruction's address (after the call) to the stack. In the case of `main`, it loads the first address in `main` into `rip` for execution and pushes the address in `__libc_start_call_main` immediately after the call to `main` to the stack.

Then execution begins in the called function, which starts with a prologue
* The prologue starts with `push rbp`, which pushes the existing (calling function's) return base pointer to the stack. This is necessary so the program can restore `rbp` as it leaves the function.
* `rbp` always points to the top of the current function's frame, so it is moved to where `rsp` currently is to mark the top of the stack with `mov rbp, rsp`. Now we have the top of the current function's stack marked and are ready to reserve space for our function.

Though it is not part of the prologue, most functions reserve stack space immediately afterward with `sub rsp, <size>` where `size` is large enough to store all local variables a function requires. Not all functions require space for local variables, so this instruction does not exist if no room is needed.

In [[first_example]], `main` needs `0x30` bytes of space to store local variables including the `canary` and `buf` byte buffer we defined earlier. The prologue and stack space reservation instructions are as follows:

```nasm
endbr64
push   rbp ; push the calling function's base pointer to the stack
mov    rbp,rsp ; base pointer should point to the top of the current function's frame, so copy the current value of rsp
sub    rsp,0x30 ; reserve 0x30 bytes for the current function's frame. Now rsp points to the bottom of the frame and rbp to the top
```

It is sometimes hard to visualize the stack statically. Ghidra precedes each function's instructions with a stack-like view that is convoluted without practice. 

```
                             undefined main()
             undefined         AL:1           <RETURN>
             undefined8        Stack[-0x10]:8 local_10
             undefined1        Stack[-0x28]:1 local_28
             undefined1        Stack[-0x29]:1 local_29
             undefined1        Stack[-0x2a]:1 local_2a 
             undefined1        Stack[-0x2b]:1 local_2b 
                             main 
        001011c9 f3 0f 1e fa     ENDBR64

```

Binja has a helpful stack view that helps reinforce our mental model. For that reason, it is helpful to use Binja whenever we want a clear representation of a function's stack. Binja's stack view clearly shows us where the buffer resides on the stack, the total stack depth, and everything in between. It is an extremely handy visual representation which pays dividends [[5. Introduction to Binary Exploitation|later in exploitation]] for stack buffer overflows. 

![[binja_stack.png]]

But typically the easiest way to visualize the stack is to do so dynamically. Let's boot the program in `gdb` and breakpoint after the prologue. This is a dynamic binary, so we cannot use an absolute address for our breakpoint. Let's set a relative breakpoint at `main+12`, which is the instruction after `sub rsp, 0x30`:

```gdb
gef➤  b *(main+12)
Breakpoint 1 at 0x11d5
gef➤  r
```

Gef's output is extremely helpful, including a (sometimes partial) stack view! 

```
───────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffe1e0│+0x0000: 0x0000000000000000	 ← $rsp
0x00007fffffffe1e8│+0x0008: 0x0000000000000000
0x00007fffffffe1f0│+0x0010: 0x0000000000000000
0x00007fffffffe1f8│+0x0018: 0x0000000000000000
0x00007fffffffe200│+0x0020: 0x0000000000000000
0x00007fffffffe208│+0x0028: 0x0000000000000000
0x00007fffffffe210│+0x0030: 0x0000000000000001	 ← $rbp
0x00007fffffffe218│+0x0038: 0x00007ffff7c28150  →  <__libc_start_call_main+0080> mov edi, eax
```

This communicates a couple key takeaways:
* Since we can see both `rsp` and `rbp` in this view, we know the stack size is the difference between them (`0x30` bytes). We could also discern this using the offset that `rsp` subtracts after the prologue (`sub sp, 0x30`) or by calculating the difference between `rbp` and `rsp`: `gef➤  p/x $rbp-$rsp`
* The return instruction pointer (pushed to the stack by the `call main` instruction in `__libc_start_call_main)` is shown `0x8` bytes above (higher address value) the current `rbp` at `0x00007fffffffe218`. This corresponds to the `__return_addr` label in Binja's stack view
* The return base pointer for the caller's frame (`__libc_start_call_main`) is pointed to by the current `rbp`. This is actually `0x1`, an edge case specific to `main` because it is the entry point of the binary. In any other sub-function call, this would point to a stack address (e.g., `0x00007ffffXXXXXXX)`. This corresponds to the `__saved_rbp` label in Binja's stack view

The epilogue undoes the prologue's operations so that the program returns to the calling function with its stack set as it was at the point of a call. 
* The `leave` instruction moves `rsp` back to where it was when it pushed `rbp` and pops that value into `rbp`. Now, `rbp` points to the top of the prior function's stack like it did when the program entered the function
* The `ret` instruction returns from this function by popping the next value on the stack—for example, the address of the next instruction in `__libc_start_call_main` pushed by the `call` instruction—into `rip`.

```
leave
ret
```

Just like that, the program is ready to continue in the calling function with its stack identical to the point of the `call`!

### Moving Data into Registers

`jmp`, `call`, and `ret` instructions all manipulate the `rip` register, but how are other registers manipulated? Data moves between registers and memory using the aptly named `mov` instruction.

> It is important to remember we use Intel syntax in these lessons. Intel defines `mov` operations so that the destination for the value is on the left and the source of the value is on the right. This follows programming _assignment_ syntax, so you can think of `mov rax, rbx` as `rax = rbx

The [Intel 64 Architecture Manual](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-2b-manual.pdf) defines the `mov` instruction to have different operands based on the instruction's op codes (page 37). This is a lot of dense information to process if unfamiliar with architecture manuals, so we'll focus on some of the common cases.

First, data can move from register to register, indicated when both operands are registers. We see data moved from `rax` to `rdi` at `0x1214` in our example with the `mov rdi, rax` instruction. Whatever value is in `rax` is copied to `rdi`. Pretty self explanatory.

We can also assign constants to registers. In our `fgets` call the number of bytes read is `0x10`. We see the program set the `rsi` register to this value at `0x1203` as it gets ready for the call: `mov esi, 0x10`.

> Note that the above instruction assigns `0x10` to `esi`, not `rsi`. This is because the size argument is a 32-bit integer, per the [fgets man page](https://man7.org/linux/man-pages/man3/fgets.3p.html), so the compiler specifies the 32-bit register representation.

Next, we can use _addresses_ as operands to the `mov` instruction. These are typically paired with the `lea` ([load effective address](https://www.felixcloutier.com/x86/lea)) instruction. As [[#What is a Pointer|reviewed earlier]], pointers are variables that hold addresses. At any point in the program, the memory at some address or the value in a register may be interpreted as an addresses. That may seem a bit convoluted, so let's look at it in practice.

The [printf man page](https://man7.org/linux/man-pages/man3/printf.3.html) shows that its first argument is a `char*`, a pointer to a character buffer in memory that defines the output string's format. A `char*` is a pointer, meaning the value _actually_ passed to `printf` is a _memory address_. The instructions defining this operation, which move the `char*` value into `rdi`, are:

```
000011e4     lea     rax, [rel data_2004]  {"> "}
000011eb     mov     rdi, rax  {data_2004, "> "}
```

`lea` loads the address of `data_2004` into `rax`, which means `rax` now stores an address to the binary's data segment. `rax` is then moved into `rdi` to prepare for the call (technically this could have been done in a single `lea rdi, [rel data_2004]` instruction, but the compiler chose to break it into two instructions). Binja gives us a hint above with the `{"> "}` note. Double-clicking the `data_2004` label takes us to that memory address, and the bytes residing there are, in fact, `"> "` followed by a null terminator `\x00`.

```
.rodata (PROGBITS) section started  {0x2000-0x2011}
00002000  uint32_t _IO_stdin_used = 0x20001
00002004  char data_2004[0x3] = "> ", 0
```

> Note that the address `0x2004` is a _relative_ virtual address—this binary was compiled with PIE so this is an offset resolved by the disassembler. PIE uses _relative addressing_ under the hood to calculate offsets within the binary. We can see this in action in gdb by breakpointing on `main+0x1b`, which shows the following instruction: 
> 
> ```
> 0x5555555551e4 <main+001b>      lea    rax, [rip+0xe19]  # 0x555555556004
> ```
> So, the binary actually indexes based on an offset of `0xe19` from the _next_ `rip` value. Binja and Ghidra already perform this calculation in the static binary, resolving `0x11eb+0xe19=0x2004` to easily cross-reference the data for us.

This is an example of a _load_ operation, and we can also use `mov` instructions in _store_ operations. For example, we retrieve the return value from `atoi` and store it for later use: `char start = (char)atoi(buf);`. `start` is a local variable in C code and will likely be stored on the stack for later use, thereby freeing up our registers to be used in operations until it is needed:

```nasm
mov     byte [rbp-0x22], al
```

This instruction is multifaceted. It first takes the return value in `rax` and only retrieves the bottom byte using the `al` index into the register. This is because we cast `start = (char)...`, so `start` only cares about the smallest byte. Next, it calculates an address within our stack frame, `rbp-0x22`. We know from our decompilation analysis that the stack for `main`'s frame is `0x30` bytes below the current `rbp` so this address falls within that frame. That makes sense, since the stack is used for local variables. Finally, it uses `byte [<address>]` to show how to store the byte. Binja actually abbreviates the instruction, and Ghidra's is perhaps more useful when seeing this for the first time: `0010121c MOV  byte ptr [RBP + local_2a],AL`. We see that the `mov byte ptr [..]` means we treat the value inside the brackets _as a pointer to a single byte_ and store the value at that address.

Taking a look in `gdb` we can see this happen using the stack view and by querying memory:

```
gef➤  b *(main+86)
Breakpoint 1 at 0x121c
gef➤  r
(input your value here to keep the program running, for instance `3`)
> 3
gef➤  p/x $rsp
$1 = 0x7fffffffe1e0
gef➤  p/x $rbp
$2 = 0x7fffffffe210
gef➤  x/xb $rbp-0x22
0x7fffffffe1ee:	0x03
gef➤  context stack
───────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffe1e0│+0x0000: 0x0000000000000000	 ← $rsp
0x00007fffffffe1e8│+0x0008: 0x0003000000000000
...
────────────────────────────────────────────────────────────────────────────────
```

> Other size modifiers for memory _store_ operations are `byte, word, dword, qword` for 1, 2, 4, and 8 bytes, respectively. It is imperative that the source and destination operand size match, otherwise the compiler will fail to compile the assembly. For instance, `byte ptr []` should always be used with one-byte register, such a `al`, `ah`, `dil`, etc.

Loads and stores follow the same syntax, so we can also load a value from memory using `mov al, byte ptr [rbp-0x22]`. This same syntax is applied to other instructions, such as a comparison against a single byte value in memory: `00001258 cmp byte [rbp-0x21], 'z'`.

It is also worth touching on instruction modifiers, such as `movzx` or `movsx`. These are used when we load a smaller value into a larger destination, such as `movzx eax, byte [rbp-0x23]`. Here the operation moves a single byte into a four-byte register, presumably because it will be cast as an `int` later in execution. The compiler needs to instruct the processor what to do with the other three bytes in the register, otherwise the result could be indeterministic. `sx` is a "sign extension", meaning the byte is treated as a signed number (`char`) so the polarity (+/-) will be extended to the top (fourth) byte. That way `-0x0f` translates to `-0x0000000f`. `zx` means to zero-extend the value, meaning `0x8f` (the same bits as `-0x0f`, just treated as an `unsigned char`) will be extended to `0x0000008f`.

## Practical Example

Let's put all our knowledge together to analyze an unknown binary with some *hidden* functionality. The binary we're targeting is [[lesson2_example|lesson2_example]]. 

#### Initial Reconnaissance 

Let's first orient ourselves with some command line tools before we dive into disassembly and decompilation.

```
$ readelf -Wl lesson2_example

Elf file type is DYN (Position-Independent Executable file)
Entry point 0x11e0
There are 13 program headers, starting at offset 64

Program Headers:
  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align
  PHDR           0x000040 0x0000000000000040 0x0000000000000040 0x0002d8 0x0002d8 R   0x8
  INTERP         0x000318 0x0000000000000318 0x0000000000000318 0x00001c 0x00001c R   0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x000970 0x000970 R   0x1000
  LOAD           0x001000 0x0000000000001000 0x0000000000001000 0x0004ed 0x0004ed R E 0x1000
  LOAD           0x002000 0x0000000000002000 0x0000000000002000 0x00022c 0x00022c R   0x1000
  LOAD           0x002d58 0x0000000000003d58 0x0000000000003d58 0x0002b8 0x0002f8 RW  0x1000
  DYNAMIC        0x002d68 0x0000000000003d68 0x0000000000003d68 0x0001f0 0x0001f0 RW  0x8
  NOTE           0x000338 0x0000000000000338 0x0000000000000338 0x000030 0x000030 R   0x8
  NOTE           0x000368 0x0000000000000368 0x0000000000000368 0x000044 0x000044 R   0x4
  GNU_PROPERTY   0x000338 0x0000000000000338 0x0000000000000338 0x000030 0x000030 R   0x8
  GNU_EH_FRAME   0x0020d0 0x00000000000020d0 0x00000000000020d0 0x00004c 0x00004c R   0x4
  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10
  GNU_RELRO      0x002d58 0x0000000000003d58 0x0000000000003d58 0x0002a8 0x0002a8 R   0x1

...

$ readelf -Ws lesson2_example

...

Symbol table '.symtab' contains 53 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS Scrt1.o
...
    22: 0000000000001415    40 FUNC    GLOBAL DEFAULT   16 compare_input
    23: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5
...
    36: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
    37: 0000000000004008     0 OBJECT  GLOBAL HIDDEN    25 __dso_handle
    38: 0000000000002000     4 OBJECT  GLOBAL DEFAULT   18 _IO_stdin_used
    39: 00000000000012c9   188 FUNC    GLOBAL DEFAULT   16 win
    40: 0000000000004050     0 NOTYPE  GLOBAL DEFAULT   26 _end
    41: 00000000000011e0    38 FUNC    GLOBAL DEFAULT   16 _start
    42: 0000000000004010     0 NOTYPE  GLOBAL DEFAULT   26 __bss_start
    43: 000000000000143d   161 FUNC    GLOBAL DEFAULT   16 main
...
    50: 0000000000001000     0 FUNC    GLOBAL HIDDEN    12 _init
    51: 0000000000001385   144 FUNC    GLOBAL DEFAULT   16 get_input
    52: 0000000000004040     8 OBJECT  GLOBAL DEFAULT   26 stderr@GLIBC_2.2.5
```

`readelf -Wl` shows that the section addresses are low and that the binary contains a `DYNAMIC` section, meaning this is a PIE binary; all addresses in the decompiler are relative. `readelf -Ws` shows a number of dynamic imports from glibc (skipped in the output above) as well as a lot of `@GLIBC_2.2.5` stubs in the `symtab` symbol table. This is expected for a dynamically linked library. Scrolling through we also see some program-specific functions, like `main`, `get_input`, `compare_input` and `win`. Those certainly seem interesting!

Next, we run `strings` to see if anything interesting comes up. The function names output in `readelf` show up, along with some debug strings that indicate there is some sort of password required:

```
$ strings lesson2_example
/lib64/ld-linux-x86-64.so.2
mfUa
...
./flag.txt
flag.txt
Error opening file '%s': %s
You win! Here is your flag: %s
Error reading user input: %s
53cr3t_p455w0rd
What is the secret password?
Nope, that's not quite right!
9*3$"
GCC: (Ubuntu 13.2.0-4ubuntu3) 13.2.0
Scrt1.o
__abi_tag
...
```

Let's dive into the decompilation in Binja!

#### Decompilation

`main` is pretty simple—it `memset`s a `0x20` byte buffer on the stack (`var_38`) and then uses that buffer in sequential calls to `get_input` and `compare_input`. It uses the return value from the latter to determine if we `win` or return. 

```c
int32_t main(int32_t argc, char** argv, char** envp)

{
    void* fsbase;
    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);
    void var_38;
    memset(&var_38, 0, 0x20);
    printf("What is the secret password?\n> ");
    get_input(&var_38, 0x20);
    if (compare_input(&var_38) != 0)
    {
        puts("Nope, that's not quite right!");
    }
    else
    {
        win();
    }
    *(uint64_t*)((char*)fsbase + 0x28);
    if (rax == *(uint64_t*)((char*)fsbase + 0x28))
    {
        return 0;
    }
    __stack_chk_fail();
    /* no return */
}
```

Binja guesses the arguments to these functions correctly, but if we want more information on the arguments we can check out the disassembly:

```nasm
; relative offset 0x000143d 
endbr64 
push    rbp {__saved_rbp}
mov     rbp, rsp {__saved_rbp}
sub     rsp, 0x40
; ... snip ...
; relative offset 0x0001458
lea     rax, [rbp-0x30 {var_38}]
mov     edx, 0x20
mov     esi, 0x0
mov     rdi, rax {var_38}
call    memset
lea     rax, [rel data_2090]  {"What is the secret password?\n> "}
mov     rdi, rax  {data_2090, "What is the secret password?\n> "}
mov     eax, 0x0
call    printf
lea     rax, [rbp-0x30 {var_38}]
mov     esi, 0x20
mov     rdi, rax {var_38}
call    get_input
lea     rax, [rbp-0x30 {var_38}]
mov     rdi, rax {var_38}
call    compare_input
mov     dword [rbp-0x34 {var_3c}], eax
cmp     dword [rbp-0x34 {var_3c}], 0x0
jne     0x14b4
```

We see in the prologue that the stack is `0x40` bytes deep and that `var_38` refers to a stack address `rbp-0x30`. Since `memset` includes a buffer length, it is logical to assume this buffer is only `0x20` bytes long. Also, the code immediately following the prologue and preceding the epilogue takes a specific form that is common for setting and checking a _stack canary_ to prevent buffer overflows. We will discuss canaries at length in future exploitation lessons, but for now we can simply rename the value to clean up our decompilation. The result of applying this information to the function is shown below:

```c
{
    void* fsbase;
    int64_t canary = *(uint64_t*)((char*)fsbase + 0x28);
    char buf[0x20];
    memset(&buf, 0, 0x20);
    printf("What is the secret password?\n> ");
    get_input(&buf, 0x20);
    if (compare_input(&buf) != 0)
    {
        puts("Nope, that's not quite right!");
    }
    else
    {
        win(); // our goal!
    }
    *(uint64_t*)((char*)fsbase + 0x28);  // canary check!
    if (canary == *(uint64_t*)((char*)fsbase + 0x28))
    {
        return 0;
    }
    __stack_chk_fail();
    /* no return */
}
```

It is sometimes useful to _think with the end in mind_ to orient our reverse engineering. Understanding what our goal is and working backward can eliminate quite a lot of reverse engineering that is not germane to our goal! Let's take a look at `win` to confirm that it is our goal:

```c
{
    void* fsbase;
    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);
    int32_t fd = open("./flag.txt", 0);
    if (fd >= 0)
    {
        void buf;
        read(fd, &buf, 0x20);
        printf("You win! Here is your flag: %s\n", &buf);
    }
    else
    {
        fprintf(stderr, "Error opening file '%s': %s\n", "flag.txt", strerror(*(uint32_t*)__errno_location()));
    }
    if (rax == *(uint64_t*)((char*)fsbase + 0x28))
    {
        return (rax - *(uint64_t*)((char*)fsbase + 0x28));
    }
    __stack_chk_fail();
    /* no return */
}
```

It looks like this function `open`s a flag file and prints it to us so long as the return from `open` is greater than `0`. We can tell from the `man 2 open` page that:

>  RETURN VALUE**
>   On success, **open**(), **openat**(), and **creat**() return the new file descriptor (a nonnegative integer).  On error, -1 is returned and errno is set to indicate the error.

So this return value check makes sense: if the file opens successfully then its contents are read and printed with `printf`. If it fails to open, then the program logs some debug and failure information.

> If you are unfamiliar with any of these function calls (`memset, puts, open, printf, strchr`, etc.), reading the `man` pages can give us a high-level view of the arguments, how they are used, what the expected return is, and failure codes if things go wrong.

It does appear this is our goal! In order to reach `win` we need `compare_input` to return `0x0`. Let's investigate that function next. We know that a `char []` buffer is passed in, so we can rename that `buf`. Binja guesses the correct type, a `char*`.

```c
int64_t compare_input(char* buf)

{
    return strcmp(buf, "53cr3t_p455w0rd");
}
```

Wow, that is a pretty simple function. _Let's double check we're not missing something in disassembly_:

```nasm
endbr64 
push    rbp {__saved_rbp}
mov     rbp, rsp {__saved_rbp}
sub     rsp, 0x10
mov     qword [rbp-0x8 {var_10}], rdi
mov     rax, qword [rbp-0x8 {var_10}]
lea     rdx, [rel data_207e]  {"53cr3t_p455w0rd"}
mov     rsi, rdx  {data_207e, "53cr3t_p455w0rd"}
mov     rdi, rax
call    strcmp
leave    {__saved_rbp}
retn     {__return_addr}
```

It appears it is just that simple! Since it returns the value from `strcmp` directly, we need to better understand that function. Back to the `man` pages!

```
DESCRIPTION
       The strcmp() function compares the two strings s1 and s2.  The locale is not taken into account (for a locale‐aware comparison, see strcoll(3)).  The comparison is done using unsigned characters.

       strcmp() returns an integer indicating the result of the comparison, as follows:
       •  0, if the s1 and s2 are equal;
       •  a negative value if s1 is less than s2;
       •  a positive value if s1 is greater than s2.

       The strncmp() function is similar, except it compares only the first (at most) n bytes of s1 and s2.

RETURN VALUE
       The strcmp() and strncmp() functions return an integer less than, equal to, or greater than zero if s1 (or the first n bytes thereof) is found, respectively, to be less than, to match, or be greater than s2.
```

So the function performs a string comparison and returns `0x0` if the strings are the same. So, we want the data in `buf` to be `53cr3t_p455w0rd` for this check to pass! Let's see how the data in `buf` is manipulated by investigating `get_input`. We know from our analysis of `main` that the function arguments are an input buffer (`char* buf`) and its assumed length (`int buflen = 0x20`). We can update those names in the decompilation to help guide our analysis:

```c
char* get_input(char* buf, int32_t buflen)

{
    if (buf != fgets(buf, buflen, stdin))
    {
        fprintf(stderr, "Error reading user input: %s\n", strerror(*(uint32_t*)__errno_location()), "Error reading user input: %s\n");
        exit(1);
        /* no return */
    }
    char* rax_7 = strchr(buf, 0xa);
    if (rax_7 != 0)
    {
        *(uint8_t*)rax_7 = 0;
    }
    return rax_7;
}
```

It uses a familiar `fgets` call to populate the buffer with user input from `stdin`, logging an error if the return value for `fgets` (which points to the start of the input buffer if it succeeds, thanks `man` page!) is as expected. So, we just need our input to match the required value to pass the check!

> What is the `strchr` stuff at the end? We can read up on `strchr` to understand the program searches for a `\n` character and replaces it with a `\0` character if it exists. This is important for string comparisons—the definition of a string in C is a series of bytes terminated by a null (`\0`) character. If the user inputs a value via the command line, they will hit `<enter>` to send a `\n` after as expected by the `fgets` call. That means the buffer will be `<input string>\n\0`. This causes an issue when we do the comparison in the next function—no matter what is input it will always end with `\n` which is not in the required password. Without this replacement from `\n` to `\0`, the `strncmp` call will never return a match!
> 
> We can check this understanding in gdb by breakpoint immediately after the `fgets` call and dumping our buffer; the `\n` character has value `0xa`.
> ```
gef➤  b *(get_input + 43)
Breakpoint 1 at 0x13b0
gef➤  r
Starting program: /root/lesson2_example 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
What is the secret password?
> asdfasdf
> Breakpoint 1, 0x00005555555553b0 in get_input ()
> gef➤  x/s $rax
0x7fffffffe180:	"asdfasdf\\n"
gef➤  x/10xb $rax
0x7fffffffe180:	0x61	0x73	0x64	0x66	0x61	0x73	0x64	0x66
0x7fffffffe188:	0x0a	0x00
>```

Let's test our assumption by running and interacting with the binary! We can always debug with `gdb` if our input does not trigger the winning condition, but in this case we understood the assignment and achieved our goal!

```
$ ./lesson2_example 
What is the secret password?
> 53cr3t_p455w0rd
You win! Here is your flag: f1r5T_3x4mp13_w1nn3R!
```

> The flag will appear so long as you have a `flag.txt` file in the same directory as the program. Feel free to make your own to test the winning condition!

## Recitation

#### Recitation 2.0

Open the [[recitation2.0]] example in GDB which is the compiled output of [[recitation2.0.c|the following code]]:

```c
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

// gcc recitation2.0.c -o recitation2.0

long long value = 0xdeadbeef1337c0de;
// 1 char 1 byte (8 bits)
// this has 64 bits or 8 bytes (long long is 4 + 4 bytes)

int main() {
    printf("64 bits prints %llx\n", value);
	    0xdeadbeef1337c0de
    printf("32 bits prints %x\n", (int)value);
	    0xdeadbeef as an integer - so we need to interpret this 0xdeadbeef as little-endian --> (by byte) ef be ad de --> result int: 0x efbeadde
    printf("16 bits prints %hx\n", (short)value);
	    first two bytes in little endian --> 0xadde
    printf("8 bits prints %hhx\n", (char)value);

    printf("Next 8 bits prints %hhx\n", *((char*)(&value) + 1));
    printf("Second 32 bits prints %x\n", *((int*)(&value) + 1));
    return 0;
}
```

Break on `main` and find the address of `value`. _Hint: use `p/x` and a symbol name to display the address of a symbol at runtime_. Use GDB to dump memory with `x/x` at that address. Try the different size modifiers (`g, w, h, b`) along with addresses around `value` to confirm we can interpret the bytes in a similar manner to the program.

#### Recitation 2.1

Open the [[recitation2.1]] binary in GDB, which is compiled from the [[recitation2.1.c|following code]]:

```c
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

// gcc recitation2.1.c -o recitation2.1

long long value = 0xdeadbeef1337c0de;
long long *value_ptr = &value;
long long **value_ptr_ptr = &value_ptr;

int main() {
    printf("The address of value is %p\n", &value);
    printf("The address of value_ptr is %p\n", &value_ptr);
    printf("The address of value_ptr_ptr is %p\n", &value_ptr_ptr);

    puts("");
    printf("The value of value is 0x%llx\n", value);
    printf("The value of value_ptr is 0x%llx\n", (long long)value_ptr);
    printf("The value of value_ptr_ptr is 0x%llx\n", (long long)value_ptr_ptr);

    puts("");
    puts("Let's set the value of value using value_ptr_ptr");
    **value_ptr_ptr = 0x1111111122222222;
    puts("The first * derferences value_ptr_ptr to get its value," \
         "the address of value_ptr");
    puts("The second * derferences value_ptr to get its value, " \
         "the address of value");
    puts("We then assign the value on the right of the = to that "\
         "address, which is value");

    puts("");
    printf("The value of value is 0x%llx\n", value);
    printf("The value of value_ptr is 0x%llx\n", (long long)value_ptr);
    printf("The value of value_ptr_ptr is 0x%llx\n", (long long)value_ptr_ptr);

    puts("This operation does not change either of the pointers");
    return 0;
}
```

Find the address of `value`, `value_ptr` and `value_ptr_ptr`. _Hint, they all follow one another in memory_. Use `x/xg` to dump the values at each address. See how the values of the pointers are just addressees in memory, and how we can follow the chain of addresses to get to some primitive data type (in this case, the `long long value`).

#### Recitation 2.2

Load the [[first_example]] binary in GDB and set the following breakpoints to see different `mov` operations in action:

* `b *(main + 176)`. Instruction `mov eax,0x1`. Print the current value in `rax` with `p/x $eax`. Note that the value should be the same if you print `p/x $rax`, which includes the top 32 bits. Step one instruction with `ni` and confirm the value of `eax` has changed to `0x1`.
* `b *(main + 75)`. Instruction `mov rdi,rax`. Print the value in `rdi` with `p/x $rdi`. This should be a stack address (`rbp-0x20`, as defined in the prior instruction). Print the current value in `rax` with `p/x $rax`. Step one instruction with `ni` and confirm the value of `rax` changed to the value of `rdi`.
* `b *(main + 83)`. Instruction `mov BYTE PTR [rbp-0x22],al`. This moves the byte `al` onto the stack at `rbp-0x22`. Print the address of the destination, `p/x $rbp-0x22`. Print the current value on the stack with `x/xb $rbp-0x22` (this may be uninitialized). Print the value in `al` with `p/x $al`. Step one instruction with `ni` and print the value on the stack again to confirm the update.
* `b *(main + 93)`.  Instruction `movsx edx, BYTE PTR [rbp-0x23]`. Print out the address of `rbp-0x23` with `p/x $rbp-0x23`. This should be one less than the address from the step above. Print the byte at that address with `x/xb $rbp-0x23`. Print the existing value of `edx` with `p/x $edx`. Step one instruction with `ni` and confirm the value of `edx` (and `rdx`) was updated with the value from the stack.

## Next steps

This lesson introduced some core decompilation and disassembly knowledge, but we have only just scratched the surface. We'll continue to build on this knowledge in the coming lessons, but will not comprehensively review every function call and instruction. For references when you come across something new, refer to the [[1. Reverse Engineering Tools#References|References]] section of the [[1. Reverse Engineering Tools|Reverse Engineering Tools]] lesson.