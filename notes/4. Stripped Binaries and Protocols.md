[SUMMARY: Stripped binaries - binaries that lack symbols and protocols(?)]
- entry point of a program in C is the _start_ function, not main
- within start, main() is called

Thus far we've built up our reverse engineering knowledge to better understand assembly, C programming, and tools to aid our efforts. That said, our examples and challenges have been somewhat contrived to teach and test incremental goals. One could argue that these examples are not representative of typical real-world engineering tasks which frequently involve complicated, obfuscated and/or proprietary targets. 

In this, the final reverse engineering lesson, we will push our knowledge further and learn how to reverse engineer more difficult examples. We'll focus on two types of targets that crop up often in the real world: **stripped binaries, which lack symbol information, and protocols.**

Table of Contents
* [[#Stripped Binaries]]
	* [[#Stripped Dynamically-Linked Binaries]]
	* [[#Stripped Statically-Linked Binaries]]
* [[#Protocols]]
	* [[#Practical Example - Protocols]]
	* [[#Initial Packet Processing]]
	* [[#Parsing Packet Bytes]]
	* [[#Writing a Client]]
* [[#Recitation]]
* [[#Next Steps]]

## Stripped Binaries

To this point we worked only with non-stripped binaries. `gcc` does not bother preserving local variable names within a function since they need not be referenced outside that function. But it does include global variable and function names by default, which can aid in quickly understanding what a function or data variable does. However, not all binaries have this metadata in practiceâ€”some vendors choose to strip their binaries of this information.
- symbols are like easy-to-ref, readable aliases to refer to memory addresses
- we can 


Stripping is available using the `-s` flag in `gcc` and `clang` and it effectively removes all user-defined variable and function names in the compiled output. This makes the binary slightly smaller since it does not contain added metadata, and sometimes this occurs to add a layer of obscurity to a system. Let's look at different types of stripped binaries.
- stripping removes user-defined var names and function names in the compiled output 
- we don't necessarily need symbols to refer to functions or vars, because we know the offsets (always same - "static") of the functions and vars 
	- caveat for dynamically 
		- for a function from a shared library dynamically linked in, they MUST retain their symbol because they are dynamically linked in at runtime. They don't have a static offset from the base address, so we MUST use their symbol to reference them.

### Stripped Dynamically-Linked Binaries

Consider the following "Hello World" program in [[stripped.c]] that calls a single function:

```c
#include "stdio.h"

void say_hi() {
    puts("Hello World");
}

int main() {
    say_hi();
    return 0;
}
```

Compiling with default `gcc stripped.c -o not_stripped` shows a reference in [[not_stripped]] to `say_hi` in main:

```console
$ objdump -M intel --disassemble=main not_stripped
0000000000001163 <main>:
    1163:	f3 0f 1e fa          	endbr64
    1167:	55                   	push   rbp
    1168:	48 89 e5             	mov    rbp,rsp
    116b:	b8 00 00 00 00       	mov    eax,0x0
    1170:	e8 d4 ff ff ff       	call   1149 <say_hi>
    1175:	b8 00 00 00 00       	mov    eax,0x0
    117a:	5d                   	pop    rbp
    117b:	c3                   	ret

Disassembly of section .fini:
```

And scanning the output of `readelf -Ws` (which is not a lengthy list, since this is a dynamically linked executable) shows the `say_hi` function as expected. 

```
$ readelf -Ws not_stripped
Symbol table '.symtab' contains 37 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 

# ... snip ... #

__libc_start_main@GLIBC_2.34
    19: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTable
    20: 0000000000001149    26 FUNC    GLOBAL DEFAULT   16 say_hi
    21: 0000000000004000     0 NOTYPE  WEAK   DEFAULT   25 data_start
    22: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5
    23: 0000000000004010     0 NOTYPE  GLOBAL DEFAULT   25 _edata
    24: 000000000000117c     0 FUNC    GLOBAL HIDDEN    17 _fini
    25: 0000000000004000     0 NOTYPE  GLOBAL DEFAULT   25 __data_start
    26: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
    27: 0000000000004008     0 OBJECT  GLOBAL HIDDEN    25 __dso_handle
    28: 0000000000002000     4 OBJECT  GLOBAL DEFAULT   18 _IO_stdin_used
    29: 0000000000004018     0 NOTYPE  GLOBAL DEFAULT   26 _end
    30: 0000000000001060    38 FUNC    GLOBAL DEFAULT   16 _start
    31: 0000000000004010     0 NOTYPE  GLOBAL DEFAULT   26 __bss_start
    32: 0000000000001163    25 FUNC    GLOBAL DEFAULT   16 main
    33: 0000000000004010     0 OBJECT  GLOBAL HIDDEN    25 __TMC_END__
    34: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
    35: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.2.5
    36: 0000000000001000     0 FUNC    GLOBAL HIDDEN    12 _init
```

Let's compile again with `gcc -s stripped.c -o stripped` to strip the binary. Peeking at the symbols list in [[stripped]] shows a troubling output (LMAO TROUBLING):

```console
$ readelf -Ws stripped

Symbol table '.dynsym' contains 7 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.34 (2)
     2: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTable
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 (3)
     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     5: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
     6: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.2.5 (3)

$ objdump -M intel --disassemble=main stripped
# no output ... #
```

- Within the STRIPPED binary's objdump:
	- No main()
	- No function say_hi()



That's it? We don't even see the main function in this binary. Without a main function, how does the binary define its entry point? Remember that the `readelf -Wl` command displayed the program headers, including the entry point:

```console
$ readelf -Wl stripped

Elf file type is DYN (Position-Independent Executable file)
Entry point 0x1060
There are 13 program headers, starting at offset 64

# ... snip ... #
```

- main() is a program's entry point
- it makes sense for us to infer that 0x1060 is main()
	- But as it turns out, 0x1060 is not main(). It's part of the initialization code before main()
- Note: 0x1060 is not the absolute address, but the offset. Why? Because this is a PIE binary

So there is definitely some code at offset `0x1060` in this binary. Let's force `obdjump` to disassemble at this address using the `--start-address` flag:

```console
$ objdump -M intel -d --start-address=0x1060 stripped | head -n 20

stripped:     file format elf64-x86-64


Disassembly of section .text:

0000000000001060 <.text>:
    1060:	f3 0f 1e fa          	endbr64
    1064:	31 ed                	xor    ebp,ebp
    1066:	49 89 d1             	mov    r9,rdx
    1069:	5e                   	pop    rsi
    106a:	48 89 e2             	mov    rdx,rsp
    106d:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
    1071:	50                   	push   rax
    1072:	54                   	push   rsp
    1073:	45 31 c0             	xor    r8d,r8d
    1076:	31 c9                	xor    ecx,ecx
    1078:	48 8d 3d e4 00 00 00 	lea    rdi,[rip+0xe4]        # 1163 <puts@plt+0x113>
    107f:	ff 15 53 2f 00 00    	call   QWORD PTR [rip+0x2f53]        # 3fd8 <puts@plt+0x2f88>
    1085:	f4                   	hlt
```

Those look like valid instructions! However there is an issue here, `objdump` has a bug where these relative offsets are printed as a reference to a single function, which is not true (if we disassemble the entire binary, every relative offset is labeled as `puts`). Let's take a look at what this _should_ look like using the non-stripped binary:

```console
$ readelf -Wl not_stripped

Elf file type is DYN (Position-Independent Executable file)
Entry point 0x1060
There are 13 program headers, starting at offset 64

$ objdump -M intel -d --start-address=0x1060 not_stripped | head -n 20

not_stripped:     file format elf64-x86-64


Disassembly of section .text:

0000000000001060 <_start>:
    1060:	f3 0f 1e fa          	endbr64
    1064:	31 ed                	xor    ebp,ebp
    1066:	49 89 d1             	mov    r9,rdx
    1069:	5e                   	pop    rsi
    106a:	48 89 e2             	mov    rdx,rsp
    106d:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
    1071:	50                   	push   rax
    1072:	54                   	push   rsp
    1073:	45 31 c0             	xor    r8d,r8d
    1076:	31 c9                	xor    ecx,ecx
    1078:	48 8d 3d e4 00 00 00 	lea    rdi,[rip+0xe4]        # 1163 <main>
    107f:	ff 15 53 2f 00 00    	call   QWORD PTR [rip+0x2f53]        # 3fd8 <__libc_start_main@GLIBC_2.34>
    1085:	f4                   	hlt
```

So the entry point to the program is the `_start` function which is responsible for loading the address of `main` into `rdi` and calling `__libc_start_main`. We see the same instruction sequence in the stripped binary, just without the symbol names. Thus, we can conclude that the argument in `rdi` at the function call, address `0x1163` from the stripped binary's disassembly above, is the address of `main`. Disassembling at this address shows the `main` function:

```console
$ objdump -M intel -d --start-address=0x1163 stripped | head -n 16

stripped:     file format elf64-x86-64


Disassembly of section .text:

0000000000001163 <.text+0x103>:
    1163:	f3 0f 1e fa          	endbr64
    1167:	55                   	push   rbp
    1168:	48 89 e5             	mov    rbp,rsp
    116b:	b8 00 00 00 00       	mov    eax,0x0
    1170:	e8 d4 ff ff ff       	call   1149 <puts@plt+0xf9>
    1175:	b8 00 00 00 00       	mov    eax,0x0
    117a:	5d                   	pop    rbp
    117b:	c3                   	ret
```

Note that the call to `puts` is not obfuscated; we might have expected otherwise given the inability to find `_start` and `main` symbols. This is because `puts` is an external symbol and this is a dynamically linked binary. Since glibc exports `puts`, the binary still contains symbol information for all imported functions that it calls. _This is a huge advantage to us when reverse engineering stripped binaries!_ We can look for common glibc functions like `read` and `fgets` to quickly identify functions which accept user input. We can find output functions like `write`, `puts`, and `printf` to see where the binary logs debug information or responds to a connected client. From the imported functions we can expand our understanding to fingerprint calling functions, thereby providing a strong foothold for reverse engineering the entire binary.

> It is worth noting that Binja and Ghidra automatically find `_start` and `main`â€”in the same way we did aboveâ€”without any user intervention. As an example, simply loading the file in Binja shows the `_start` symbol with automatically generated function signature and resolution of the `main` function.
> ![[stripped_start_binja.png]]

### Stripped Statically-Linked Binaries
[SUMMARY: bad news.]

Imports provide a significant advantage when dealing with stripped, dynamically-linked libraries. But what happens for statically linked libraries? Let's take the same example as above and compile it statically, in the resulting file [[stripped_static]]:

```shell
gcc stripped.c -o stripped_static -s --static
```

Again, running `objdump` to disassemble `main` fails, which is not surprising. What happens if we dump symbols with `readelf`?
- Why? Is it because the file is simply too large to be parsed? 
	- in statically-linked binaries, everything is in one monolithic block of code
	- 


```console
$ readelf -Ws stripped_static
# no output ...
```

We get absolutely nothing. Again, we could go through the entry point and find `main` like we did above, or we can have Binja do the heavy lifting for us. However, loading us show something horrifying: hundreds of unnamed functions:

![[stripped_static_binja.png]]

Similarly, disassembling the entire binary with `objdump` has an output of 971950 lines!

```console
$ objdump -M intel -d stripped_staticÂ | wc
Â 129479Â  971950 6690478
```

Worse, imported symbols like `__libc_start_main` and `puts` do not exist. This makes sense because there is no external dependency in a static executableâ€”all the imported functionality is compiled directly into the binary. **`gcc` can then strip the symbol names and refer to every function call with a static address or relative offset.** This appears to be a much harder target than the dynamically linked library above.


[STRATEGIES TO TACKLE statically-stripped binaries]
- Conclusion: will not encounter durin 

When faced with so many functions, we really need a plan of attack to avoid wasting our time reversing things that don't matter. **Remember that statically linked binaries import _all_ the functionality from the imported libraries.** We have no way of knowing, at first glance, which functions are used. Consider the example binaryâ€”only `puts` (and the functions it calls) is used once the program enters `main`! So starting from the top of Binja's function list and working our way down could result in a lot of time spent reversing functions that are never called and get us no closer to understanding the program.

[STRATEGY: "function taint analysis"]
A strategy to easily focus our attention on relevant functions would be to do a sort of function _taint analysis_. Taint analysis is the process of determining the reach of our inputs within a system, which is important to consider when performing vulnerability analysis. If we know we can only reach a target through a particular socket or entry point then it's worth focusing on where that input is used to look for bugs. To visually grasp this concept, think of the program as a complex river system of branching streams. If we "taint" the location where our input is received, say with a colored dye, and let it flow downward, tracking where its data is used, we have a very clear representation of our influence on the system's state.

For this example, we could use a function-level taint analysis to pick out only functions called by `main`, and the functions those functions call. We would end up with a tree of functions that is a small subset of the overall function space, drastically reducing and helping focus our efforts. This is easiest to do with scripting using [Binary Ninja's API](https://api.binary.ninja/) or [Ghidra scripting](https://ghidra.re/ghidra_docs/api/ghidra/app/script/GhidraScript.html?external_link=true). This is out of the scope of this course but provided here for the curious.

Another opportunity to quickly hone our focus is to look for `syscall` instructions, which is detailed in the next section.

### Hand-rolling Functionality

- What is hand-rolling?
	- write a function that achieves the same functionality than using standard lib functions
		- e.g. puts function that prints things out 
			- Instead of using the glibc function, by understanding that the glibc puts function really just makes a syscall, we can achieve the same result by writing the syscall ourselves
	- I'm thinking of this as "reinventing the wheel", coding from the ground-up

Occasionally we might come across a binary or system that includes hand-rolled code which obfuscates our initial understanding of its purpose. For instance, some high-performance systems might choose to write their own data structures and associated methods to optimize performance versus off-the-shelf library code. Others might hand-roll standard library functionality to avoid linking and jumping to dynamic code. An example of this is shown below, in [[stripped_no_imports.c]]:

AT&T Syntax Assembly Code
- move the value 1 into rax
	- syscalls are defined by numbers. Syscall number 1 is the write() syscall
- make a sys call - call functionality directly to the kernel
	- Operations handled by the kernel
		- sockets
		- read write (e.g. "puts") functions
			- glibc function is really just a nice API, and under the hood, it calls a syscall
		- ask for more memory
```c
int mywrite() {
    __asm__ ("movq $1, %rax\n\t" // mov rax, 1; convention: when making a syscall, look at RAX regiter to determine the syscall number
             "syscall");
}

int main() {
    mywrite(1, "Hello World\n", 12); // 12 includes \n char
    return 0;
}
```
- by calling convention and which registers arguments - in order - get moved into registers
	- when mywrite() is called, the arguments are moved into their respective registers
		- first six arguments (in order): **%rdi, %rsi, %rdx, %rcx, %r8, and %r9**
	- then, when the syscall is made, the arguments - raw materials the syscall executes on - are already in the registers where they should be


This is the exact same program as the one in the previous sections, except that the call to `puts` was replaced with in-line assembly to make a direct `syscall`. This is _substantially_ less code than `puts`.

> In comparison, the glibc `puts` call uses ~1000 instructions, not counting the sub-function calls it makes. This is because `puts` [adds functionality](https://elixir.bootlin.com/glibc/latest/source/libio/ioputs.c#L32) including acquiring and releasing locks to ensure sequential output.
> 
> ```
> objdump -M intel --disassemble=_IO_puts /lib/x86_64-linux-gnu/libc.so.6 | wc
Â  Â  151Â  Â  1090Â  Â  8022
Â  Â  ```

Let's compile with dynamic linking and take a look at the hand-rolled `puts` function in [[stripped_no_imports]]:

```shell
gcc stripped_no_imports.c -o stripped_no_imports -s
```

Tracing the calls from `_start` to `main` to `mywrite` like we did above, we find that it is at address `0x1129`. The disassembly is very short:

```console
$ objdump -M intel -d --start-address=0x1129 stripped_no_imports

stripped_no_imports:     file format elf64-x86-64


Disassembly of section .text:

0000000000001129 <.text+0xe9>:
    1129:	f3 0f 1e fa          	endbr64
    112d:	55                   	push   rbp
    112e:	48 89 e5             	mov    rbp,rsp
    1131:	48 c7 c0 01 00 00 00 	mov    rax,0x1
    1138:	0f 05                	syscall
    113a:	90                   	nop
    113b:	5d                   	pop    rbp
    113c:	c3                   	ret
```

All it seems to do is the prologue (with no allocated stack space) and perform a move into `rax` followed by a `syscall`. There is no adjustment to `rax` after the call, so the function directly returns the result of the `syscall`. How do we know what syscall this performs?

As a brief refresher, syscalls, short for system calls, are an API for a user-space process to request some functionality from the kernel. User space processes are not allowed to modify the file system, write or read from files, change permissions, etc. without intervention from the operating system. User space libraries provide a nice programming abstraction around the syscalls, so most of the time we do not even see them. In fact, all functions with manual 2 (`man 2`) entries are system calls (e.g., `man 2 write`, `man 2 read`, etc.). 

x64 syscalls are defined by number. A good resource to bookmark is the [Chromium documentation](https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86_64-64_bit) which includes the syscall number and its associated arguments. As you can see, the syscall arguments follow the same convention as a normal call. The only difference is that the syscall number is moved into `rax` prior to the call. Therefore, `mov rax, 0x1` in the code above means the program makes a `write` syscall using the arguments already placed in `rdi`, `rsi`, and `rdx` from the calling function's signature. Since we have no `stdout` file contention, this is essentially the same as a call to `puts`!

The other big difference between this binary and the dynamically-linked stripped binary in the preceding section is that there is no `puts` dependency since we make the syscall ourself. 

Without knowing the `syscall` API, we might be lost as to what this `mywrite` function does. But with this knowledge we can easily figure out its use. When dealing with hand-rolled binaries that make syscalls directly, it's handy to do a global search for the hex string `0f05`â€”this is the `syscall` instruction's op code. Searching and comparing the `rax` value to the table of syscall numbers helps easily determine the purpose of a function. Once you name that function based on its purpose, it is easy to quickly reference from calling functions just like the libc functions we normally leverage while reverse engineering.

## Protocols
Goal
- Understand what the data looks like
- what is inside the data packet that we received 

[SUMMARY]
- when you define a struct for packets, you can either define it as a struct only for packet header, and a separate struct for payload, then define a struct for the entire packet by using these 2 structs
- or you can define a struct for the entire packet (header + payload) and fill it in

- build a client (sends correctly formatted packets to the target endpoint) using pwn-script
	- Should have separate functions to populate header, populate payload etc.



One of the most important skills in reverse engineering real-world targets is understanding and replicating protocols. Let's review a handful of common protocols and their format.

| Protocol | Purpose                      | Format                                                     |
| -------- | ---------------------------- | ---------------------------------------------------------- |
| HTTP     | Web requests                 | ASCII printable data (perhaps including binary blobs)      |
| JSON     | Serializing dictionaries     | ASCII printable                                            |
| XML      | Formatting arbitrary data    | ASCII code                                                 |
| Protobuf | Structured data transmission | Serialized data (turn data into BYTES) to be sent/received |
| plist    | Apple data bundles           | Serialized data stored on disk                             |

The first two protocols listed, HTTP and JSON, feel very comfortable. They're ASCII printable and thus easy to read, debug, and follow. But think about how wasteful these protocols are. 
- why wasteful?

[SUMMARY: minimize how many bytes are used to represent the same info]
If we want to communicate that we're sending 1234 bytes of data in the [`Content-Length`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length) - HTTP header value, that requires four bytes of data ("1" takes one byte, "2" takes another byte...)â€”one byte for each ASCII character. However, if we communicated that value in binary then we could represent it in two bytes: `0x4d 0x02` (interpret these 2 bytes as a short would equal the value 1234).  This is why many protocols focused on data transmission, such as UDP, TCP, Ethernet, Bluetooth, etc. all pack data into serialized binary protocols. Some even break up a single byte into multiple fields (e.g., TCP's `version` and `header length` are both four-bit values packed into the same byte: 4 bits for version, 4 bits for header length).

Many proprietary targets also implement their own protocols, either for obscurity or performance. One motivating reason is inter-process communication, or IPC. `Binder`is a service on Android that sits between the kernel and user processes to [manage system-wide IPC](https://blog.hacktivesecurity.com/index.php/2020/04/26/android-ipc-part-2-binder-and-service-manager-perspective/). Meanwhile, MikroTik routers use a [custom message protocol](https://margin.re/2022/06/pulling-mikrotik-into-the-limelight/) for transferring state and data between processes on device. To understand these messages we need to reverse engineer the parsing logic and follow different branching cases to reason about how different bytes in a payload are used. This can be very daunting at first, however when the protocol comes together it helps reveal a ton of information about the system (and potential attack vectors, too!).

The general strategy for reverse engineering protocols involves a few steps, mainly:
* Isolating the header from the payload
* Understanding header and payload members
* Testing understanding by writing a client

This is best understood through practice, so let's demonstrate these tactics with the following practical example!

## Practical Example - Protocols

Let's practice reverse engineering protocols using the practical example, [[deserialize]]. Taking a quick look at `main` we see the entire scope of the program is tied up in a `do-while` loop that accepts data from `stdin` until some data is read, and then the input is processed in `handle_packet`. We see that the return value from `handle_packet` is compared against `0x99`. If it matches the program logs a winning message, otherwise it repeats. Some basic massaging is done to update `main`'s signature and local variable names:

```c
int main(int argc,char **argv,char **envp)

{
  int handle_return;
  char *buf;
  ulong len;
  
  buf = (char *)malloc(0x400);
  memset(buf,0,0x400);
  do {
    do {
      len = read(0,buf,0x400);
    } while ((int)len < 1);
    handle_return = handle_packet(buf,len & 0xffffffff);
  } while (handle_return != 0x99);
  puts("You Win!");
  return 0;
}
```

### Initial Packet Processing 

Let's take a look at the `handle_packet` function, which takes in the populated buffer and the length read by `read`. A quick scan of the program shows that it returns a value that is set to `-1` at various spots within the function, so presumably the function signature looks something like `int handle_packet(byte *buf,uint len)`.

The first instructions in this function are very important. It is a very common practice to parse a packet while maintaining two or three pointers within the data buffer: either a `current` and `end` pointer or a `start`, `current`, and `end` pointer. The `end` pointer is used to ensure that parsing terminates when done with the data and is used to detect invalid or partial packets. The `current` pointer is used to keep track of what bytes are currently being processed. Any bytes between `start` and `current` are already processed and bytes at and between `current` and `end` are pending processing.

The first instructions in the disassembly show the program storing the function's arguments on the stack at `local_30` and `local_34`, respectively. Next, it fetches the length, extends it to eight bytes using a sign extension with the `MOVSXD` instruction, and then adds it to the buffer's start address. The resulting value, stored in `local_18`, stores the `end` of the received packet.

```nasm
MOV        qword ptr [RBP + -0x28]=>local_30,RDI
MOV        dword ptr [RBP + -0x2c]=>local_34,ESI
MOV        EAX,dword ptr [RBP + -0x2c]=>local_34
MOVSXD     RDX,EAX
MOV        RAX,qword ptr [RBP + -0x28]=>local_30
ADD        RAX,RDX
MOV        qword ptr [RBP + -0x10]=>local_18,RAX
MOV        EAX,dword ptr [RBP + -0x2c]=>local_34
```

The next check, correctly identified in decompilation, shows a length check:

```c
 if (len < 5) {
  retval = -1;
 }
```

This is also a common practice. It is expected that some number of bytes are present in the packet, otherwise we don't bother iterating through the data. The minimum length for a packet is typically either the _packet header length_ or the _packet header length + required data length_. We cannot be certain which one it is at this point, but we know that at least five bytes must be present in the packet we send otherwise it is immediately dropped.

### Parsing Packet Bytes

It's useful to keep a close eye on disassembly during packet parsing, because many times the source code casts the buffer to different data types for fetches and comparisons. This can result in jumbled decompilation that is hard to follow, whereas the disassembly will clearly tell us what sizes are fetched in the dereference instructions (e.g., `mov rax, dword ptr [rdi]`).  The next instruction fetches data from an address stored on the stack at `local_10`, and we need to trace the access up a few instructions to see that it's stored during the length comparison:

```nasm
MOV        RAX,qword ptr [RBP + -0x28]=>_buf
MOV        qword ptr [RBP + -0x8]=>local_10,RAX
ADD        qword ptr [RBP + -0x28]=>_buf,0x5

MOV        RAX,qword ptr [RBP + -0x8]=>local_10
MOVZX      EAX,byte ptr [RAX]
MOVZX      EAX,AL
CMP        dword ptr [RBP + -0x2c]=>_len,EAX
```

Since it is set to the start of the buffer, a reasonable guess at this point is that it is (another) `start` pointer or the `current` pointer. Since the next instruction updates `_buf` by adding five, that is likely the `current` pointer and thus `local_10` preserves the starting address. We see that the program fetches a byte with `byte ptr` using the starting address, meaning we take a single byte from the front of the packet. This is immediately assessed if equal the length of the packet, and the `else` condition in the comparison is very telling:

```c
 else {
	 printf("Fragmented packet, got len %d, expected len %d\n",(ulong)*buf,(ulong)len);
	retval = -1;
 }
```

This debug symbol helps us very clearly understand that the first byte in the packet should be the total packet length, _including header_. At this point, it's worthwhile to define a temporary `packet_header` struct in Ghidra where we can record this information. Let's make it five bytes for the time being, to match the minimum packet length. We can always adjust it downward if the header is smaller.
![[packet_header_struct_1.png]]
Another strategy for quickly filling in these fields is to temporarily change the type of `buf` (the incoming argument) from a `char*` to a `packet_header*`. This will likely create some problems, specifically when the program indexes past the header into packet data. But it can also help us easily identify accesses to the packet header, like shown in the decompilation below:

```c
 else if (len == buf->len) {
  printf("sequence: %d\n",(ulong)*(uint *)&buf->field_0x1);
  if (end < buf + 1) {
   retval = -1;
  }
```

This next access is one byte into the packet header, but the casting makes it a bit confusing to see what is actually happening. Let's double check the disassembly for more specifics:

```nasm
MOV        RAX,qword ptr [RBP + -0x8]=>local_10
MOV        EAX,dword ptr [RAX + 0x1]
MOV        dword ptr [RBP + -0x14]=>local_1c,EAX
MOV        EAX,dword ptr [RBP + -0x14]=>local_1c
MOV        ESI,EAX
LEA        RAX,[s_sequence:_%d_00102040]                    = "sequence: %d\n"

MOV        RDI=>s_sequence:_%d_00102040,RAX                 = "sequence: %d\n"
MOV        EAX,0x0
```

`local_10` here is still set to the buffers's start, so the program is treating the next bytes in the packet as a `dword ptr` and moving the value at that address into `eax`. This is then transferred to `rsi` as the second argument in a `printf("sequence: %d\n", val)` command. We know that the next four bytes of the packet header therefore correspond to a sequence number! Making that update, our `packet_header` struct is seemingly complete. The decompilation reflects this update nicely:

```c
 else if (len == buf->len) {
  printf("sequence: %d\n",(ulong)buf->seq);
  if (end < buf + 1) {
   retval = -1;
  }
  else {
   bVar2 = buf[1].len;
   pdVar1 = &buf[1].seq;
```

The update works nicely for the packet header data accesses, but things get weird after. The `[1]` array index in the `else` statement means we're indexing past the end of the header into packet data, so we should take this opportunity to define a packet structure. It's helpful to make the packet structure longer than shorter, to avoid similar "out-of-bounds" accesses like what occurred above.

![[packet_structure.png]]
> Defining the `packet_header` as a separate struct from the header is nice if we end up with different packet types that share the same header. Each packet type can include the header struct as its first member, as shown above, so any updates to the header will cascade to all packet types!

Refining the buffer argument type to a `packet*` struct now shows the header accesses and also placeholders for accesses to other data in its payload:

```c
 else if (len == (buf->header).len) {
  printf("sequence: %d\n",(ulong)(buf->header).seq);
  if (end < &buf->field_0x5) {
   retval = -1;
  }
  else {
   type = buf->field_0x5;
   puVar1 = &buf->field_0x6;
   printf("type: %d\n",(ulong)type);
```

Again, debug symbols show that the first byte in the payload, `field_0x5`, is the packet type. Double-checking the disassembly shows that this is a single byte. The `type` is then immediately used in a series of `if-else` statements, which looks a lot like it might be an `enum` used in a `case` statement in the source code. 

```c
	if (type == 2) {
		retval = handle_array(puVar1,end);
	}
	else {
	if (type < 3) {
		if (type == 0) {
			retval = handle_int(puVar1,end);
			return retval;
		}
		if (type == 1) {
			retval = handle_char(puVar1,end);
			return retval;
		}
	}
	retval = -1;
```

It is easy to tell which type is which based on the function names, so we can define an enum with a size of one byte:

```c
enum type : uint8_t {
	TYPE_INT = 0,
	TYPE_CHAR = 1,
	TYPE_ARRAY = 2,
}
```

The decompilation looks much better aside from the weird `TYPE_CHAR|TYPE_ARRAY`, which is how Ghidra resolved the program checking if the enum is valid (less than 3).

```c
   if (type == TYPE_ARRAY) {
    retval = handle_array(puVar1,end);
   }
   else {
    if (type < (TYPE_CHAR|TYPE_ARRAY)) {
     if (type == TYPE_INT) {
       retval = handle_int(puVar1,end);
       return retval;
     }
     if (type == TYPE_CHAR) {
       retval = handle_char(puVar1,end);
       return retval;
     }
    }
    retval = -1;
   }
```

In each of the function calls the program passes in a reference to the byte following the type. Presumably the remainder of the buffer contains type-specific data for each of the packet types. Let's reverse the most complicated one, the array.

#### Reversing the Array Packet Data

This function has some semi-complicated logic, so let's pick some key takeaways:

```c
int handle_array(byte *start,byte *end)

{
	byte bVar1;
	void *__dest;
	byte *local_30;
	int local_20;
	int local_1c;
	void *local_18;
	
	bVar1 = *start;
	start = start + 1;
	if (end < start + bVar1) {
		local_20 = -1;
	}
	else {
		__dest = malloc((ulong)bVar1);
		memcpy(__dest,start,(ulong)bVar1);
		local_30 = start + bVar1;
		if (local_30 + bVar1 <= end) {
			local_18 = malloc((ulong)bVar1);
			memcpy(local_18,local_30,(ulong)bVar1);
			local_30 = local_30 + bVar1;
		}
		if (local_30 == end) {
			local_20 = 0;
			for (local_1c = 0; local_1c < (int)(uint)bVar1; local_1c = local_1c + 1) {
			local_20 = local_20 +
				   (uint)*(byte *)((long)local_18 + (long)local_1c) *
				   (uint)*(byte *)((long)__dest + (long)local_1c);
			}
		}
		else {
			local_20 = -1;
		}
	}
	return local_20;
}
```

* We `malloc` two buffers, both of the same size. The value passed to malloc comes from the first byte of the packet data, meaning it is likely a size or length of some sort
* This makes sense with the `if` statements, which use this value and the buffer's `start` and `end` in some sort of length check
* The created buffers are used together in a `for` loop which iterates according to the length
* The loop's iterator indexes into both buffers and performs a multiplication
* The indexing is done a byte at a time, as shown by the `EAX,byte ptr [RAX]` instructions, where `RAX` points to an offset into the buffers. This means the buffers are likely treated as `char*`s (or `byte*`s, as Ghidra tends to default)

Let's take this info and rename and retype some variables to help aid or visual reversing:

```c
len = *start;
start = start + 1;
if (end < start + len) {
	retval = -1;
}
else {
	buf1 = (byte *)malloc((ulong)len);
	memcpy(buf1,start,(ulong)len);
	local_30 = start + len;
	if (local_30 + len <= end) {
		buf2 = (byte *)malloc((ulong)len);
		memcpy(buf2,local_30,(ulong)len);
		local_30 = local_30 + len;
	}
	if (local_30 == end) {
		retval = 0;
		for (i = 0; i < (int)(uint)len; i = i + 1) {
			retval = retval + (uint)buf2[i] * (uint)buf1[i];
		}
	}
	else {
		retval = -1;
	}
}
return retval;
```

This looks a lot better! We can now clearly see that the loop is performing a multiplication and adding the result to an accumulator, which looks a lot like a [dot product](https://builtin.com/data-science/dot-product-matrix).  The length checks ensure that there is enough data to populate both arrays and that there is no trailing data after the last byte. In either event, the function would return an error code, `-1`. Otherwise it returns the final result of the dot product.

> You may have been tempted to declare a new `array` packet type for the packet passed into this function. That is always a good idea! However, this packet type contains dynamically sized fields, which are hard to represent in static structure definitions. In this case, the `array` packet structure definition would not add much info. However, this strategy would be very useful for other targets with well-defined packet formats.

### Writing a Client

The final step to understanding a protocol is writing a client to interact with it. This is extremely valuable in reverse engineering for two reasons. First, it confirms that we understand the protocol well enough to recreate itâ€”the process of creating a client can sometimes illuminate incorrect assumptions that then improve our understanding. Second, client programs are useful for advanced reverse engineering and exploitation. If we decide it worthwhile to create a fuzzer for this program, it is more useful to have a _structure aware_ fuzzer. A structure aware fuzzer is a fuzzer that understands some structure about the data it's generating. In this case, knowing valid values for the packet type, correct payload formats, and appropriate header values will significantly improve coverage and minimize "wasted" packets when fuzzing. Finally, if we find a vulnerability in this parsing function or that is reachable from input, we will need a client to assist in throwing the exploit payload.

Clients can be as robust or lean as needed depending on the goal. Since we have a very specific goal in this situation, let's simply create a short throwing script in Python with `pwntools`.

We start by importing `pwntools` and running the `deserialize` binary as a `process`. We add our trusty `process.interactive()` at the end of the script to keep the socket open. This is very helpful for this example because the binary contains debug messages. Should our data be incorrectly formatted, we can then debug messages returned to understand why.

```python
from pwn import *

p = process("./deserialize")

# code goes here

p.interactive()
```

When dealing with structured packet data, including headers that have values dependent on the total packet size (e.g., the packet length field), it is useful to start by assembling the body first and later prepend the header. Let's focus on the body that is passed to `handle_array`. We know we need a dot product result that equals `0x99` or 153. There are a variety of solutions here, and one such answer is `0x3 * 0x7 + 0x4 * 0x8 + 0xa + 0xa = 0x99`. Based on our understanding of how the arrays are used, we can separate them and assert that the dot product matches our goal:

```python
from pwn import *

p = process("./deserialize")
# assemble packet body first, then prepend header values
# need an array that results in a dot product of 0x99
array1 = [0x3, 0x8, 0xa]
array2 = [0x7, 0x4, 0xa]

assert sum(x * y for x, y in zip(array1, array2)) == 0x99

p.send(packet)
p.interactive()
```

Finally, we can prepend header values to pass all the checks. Remember we have a leading `0x2` to indicate this is an array type. Next, we're ready to prepend the packet header. The sequence number has no check, so any four-byte number will do. Finally, we prepend the length of the packet to make our final payload:

```python
from pwn import *

p = process("./deserialize")
# assemble packet body first, then prepend header values
# need an array that results in a dot product of 0x99
array1 = [0x3, 0x8, 0xa]
array2 = [0x7, 0x4, 0xa]

assert sum(x * y for x, y in zip(array1, array2)) == 0x99

body = p8(len(array1)) + b''.join(map(p8, array1)) + b''.join(map(p8, array2))

# prepend header values
# packet array type
packet = b'\x02' + body
# sequence number
packet  = p32(0xdeadbeef) + packet
# len
packet = p8(len(packet)) + packet

p.send(packet)
p.interactive()
```

And when we throw it, we unfortunately get an error!

```python3
[+] Starting local process './deserialize': pid 2397481
[*] Switching to interactive mode
Fragmented packet, got len 12, expected len 13
$  
```

This is where leveraging debug information is so helpfulâ€”we clearly see that the script did not account for the size of the length byte itself! Let's add `1` to the length and try again:

```python
from pwn import *

p = process("./deserialize")
# assemble packet body first, then prepend header values
# need an array that results in a dot product of 0x99
array1 = [0x3, 0x8, 0xa]
array2 = [0x7, 0x4, 0xa]

assert sum(x * y for x, y in zip(array1, array2)) == 0x99

body = p8(len(array1)) + b''.join(map(p8, array1)) + b''.join(map(p8, array2))

# prepend header values
# packet array type
packet = b'\x02' + body
# sequence number
packet  = p32(0xdeadbeef) + packet
# len
packet = p8(len(packet) + 1) + packet

p.send(packet)
p.interactive()
```

And we get a winning result!

```
[+] Starting local process './deserialize': pid 2397539
[*] Switching to interactive mode
[*] Process './deserialize' stopped with exit code 0 (pid 2397539)
sequence: -559038737
type: 2
You Win!
[*] Got EOF while reading in interactive
```

## Recitation

#### Recitation 4.0

Reverse engineer the syscalls in [[recitation4.0]] to better understand the program's functionality. Start by finding the entry point and identifying the address of `main`.

#### Recitation 4.1

Some programs or systems will hand-roll their own glibc functions (implemennt same behaviour themselves without using glibc functions; using syscall directly instead), either for increased performance or obscurity. Practice reversing some common glibc function utilities in [[recitation4.1]].

#### Recitation 4.2

Try defining structures for the `INT` and `CHAR` payload structures in [[deserialize]]. These have fixed lengths and thus work well for structure definitions.

## Next Steps

This is our final lesson in reverse engineering, though we will continue to use these tools and skills extensively in the binary exploitation sections. We covered everything from how to open a binary in Ghidra to reverse engineering complex targets like stripped binaries and serialized binary protocols.

The current software landscape is so diverse that picking up a random binary will probably teach us something new. Next steps for those craving a challenge include reversing C++ classes, systems with heavy IPC or shared memory regions like routers, and heavily obfuscated code bases. CTFs always offer new and fun challenges, and Mandiant's annual [Flare-on](https://flare-on.com/) challenge is one of the more rigorous reverse engineering exercises around.