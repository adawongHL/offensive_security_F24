We continue building upon our reverse engineering skills in this lesson by looking at a couple different strategies for understanding and exploring compiled binaries. This lesson covers reverse engineering structures and using SAT solvers to reach targeted program code.

Table of Contents
* [[#Structures]]
	* [[#Array of Structs]]
		* [[#Recognizing Structures]]
		* [[#Defining Structures in Binja]]
		* [[#Defining Structures in Ghidra]]
	* [[#Practical Example]]
* [[#SAT Solvers]]
	* [[#Simple Z3 Use Case]]
	* [[#Tweaked Z3 Use Case]]
	* [[#Z3 and Functions]]
* [[#Recitation]]
* [[#Next Steps]]

## Structures

The C programming language is full of structures. Identifying and reverse engineering these structures is often the difference between fuller understanding of a system and a surface-level grasp. This is even more true in higher level languages like C++, Rust, etc. which are heavily dependent upon classes and structs with methods. Let's take a look at how we can identify structures by investigating an *array* of simple structures.

### Array of Structs

Say we have a simple structure (with `enum`!) to maintain a static 10-student roster:

```c
enum grade {
    FRESHMAN = 1,
    SOPHOMORE = 2,
    JUNIOR = 3,
    SENIOR = 4
};

struct student {
    char* name;
    unsigned int age;
    enum grade grade;
} students[10];

unsigned char num_students = 0;
```

We can write a simple command-line utility to add and lookup students from this list (full source code in [[structs.c]]):

```c
/* helper function to replace a newline character with null terminator */
void null_terminate(char* buf) {
    char* nl = strchr(buf, '\n');
    if (nl) { *nl = '\0'; }
}

/* helper function to get a one-digit int from user */
int get_int() {
    char buf[8];
    fgets(buf, 8, stdin);
    null_terminate(buf);
    return atoi(buf);
}

void add_student() {
    char* name = malloc(0x10); // allocated on heap
    int age;
    int g;
    enum grade grade;
    if (num_students == 10) {
        printf("Student roster full!\n");
        return;
    }
    printf("Enter a name (less than 16 characters)\n > ");
    fgets(name, 0x10, stdin);
    null_terminate(name);
    printf("Enter an age\n > ");
    age = get_int();
    printf("Enter a grade (FRESH=1, SOPH=2, JUN=3, SEN=4)\n > ");
    g = get_int();
    if (g > (int)SENIOR || g < (int)FRESHMAN) {
        puts("Invalid grade!");
        return;
    }
    grade = (enum grade)g;
    students[num_students++] = (struct student){ name, age, grade };
}

void lookup_student() {
    int idx;
    struct student c;
    printf("Enter a student number (1-10)\n > ");
    idx = get_int();
    if (idx < 0 || idx >= num_students) {
        puts("Invalid index!");
        return;
    }
    c = students[idx];
    printf("Student %d\n", idx);
    printf(" Name: %s\n", c.name);
    printf(" Age: %d\n", c.age);
    printf(" Grade: ");
    switch (c.grade) {
        case FRESHMAN:
            puts("Freshman");
            break;
        case SOPHOMORE:
            puts("Sophomore");
            break;
        case JUNIOR:
            puts("Junior");
            break;
        case SENIOR:
            puts("Senior");
            break;
    }
}

void menu() {
    puts("Please enter a choice:");
    puts(" 1. Enter a student");
    puts(" 2. Look up a student");
    puts(" 3. Quit");
    printf(" > ");
}

int main() {
    char choice;
    int ichoice;
    while (1) {
        menu();
        ichoice = get_int();
        switch (ichoice) {
        case 1:
            add_student();
            break;
        case 2:
            lookup_student();
            break;
        default:
            return 0;
        }
    }
}
```

Understanding this program clearly revolves around understanding that it maintains a list of students and the students have metadata associated with them (in the form of a structure).

Let's take a look at the problem in disassembly/decompilation.

### Recognizing Structures

The `main` function is very simple, so let's investigate the two handling functions it calls.

```c
int32_t main(int32_t argc, char** argv, char** envp)

    while (true)
        menu()
        int32_t rax_3 = get_int()
        if (rax_3 == 1)
            add_student()
        else
            if (rax_3 != 2)
                break
            lookup_student()
    return 0
```

We first see some weird decompilation behavior in `add_student`. The first handful of lines are rather familiar (with the exception of `malloc`—we'll discuss the heap more in [[8. Attacking the Heap (glibc <2.32)|later lessons]]); there are some comparisons, calls to `printf` and a helper function which just calls `strchr` to null terminate a console-input string.

```c
    char* buf = malloc(bytes: 0x10)
    int32_t rax_1
    if (num_students == 0xa)
        rax_1 = puts(str: "Student roster full!")
    else
        printf(format: "Enter a name (less than 16 chara…")
        fgets(buf, n: 0x10, fp: stdin)
        null_terminate(buf)
        printf(format: "Enter an age\n > ")
        int32_t rax_7 = get_int()
        printf(format: "Enter a grade (FRESH=1, SOPH=2, …")
        int32_t rax_10 = get_int()
        if (rax_10 s> 4 || (rax_10 s<= 4 && rax_10 s<= 0))
            rax_1 = puts(str: "Invalid grade!")
        if (rax_10 s<= 4 && rax_10 s> 0)
            uint8_t num_students_1 = num_students
            num_students = num_students_1 + 1
            uint32_t num_students_2 = zx.d(num_students_1)
            *((sx.q(num_students_2) << 4) + &students) = buf
            *((sx.q(num_students_2) << 4) + &data_4048) = rax_7
            rax_1 = rax_10
            *((sx.q(num_students_2) << 4) + &data_404c) = rax_1
    return rax_1
```

The last conditional, `if (rax_10 s<= 4 && rax_10 s> 0)` is where the interesting behavior begins. We see a lot of left shifts and references to `&students` and addresses in the `data_` section (specifically the `.bss` section where read/write data exists). This section presents some key indicators for a structure.

First, we need to understand why we're referencing `&students` and `&data_404X`. Following the reference to `students` shows that it is a named variable residing at `0x4040`. So, the three accesses are grouped together at `0x4040`, `0x4048`, and `0x404c`. _Data which is grouped together (and potentially tightly packed) is a decent indicator of a structure_.

Let's look at how the data is fetched in `lookup_student`:

```c
int32_t lookup_student()

{
    printf("Enter a student number (1-10)\n …");
    int32_t rax_2 = get_int();
    int32_t rax_5;
    if ((rax_2 < 0 || (rax_2 >= 0 && rax_2 >= ((uint32_t)num_students))))
    {
        rax_5 = puts("Invalid index!");
    }
    if ((rax_2 >= 0 && rax_2 < ((uint32_t)num_students)))
    {
        int64_t rax_9 = *(uint64_t*)((((int64_t)rax_2) << 4) + &students);
        int64_t rdx_3 = *(uint64_t*)((((int64_t)rax_2) << 4) + &data_4048);
        printf("Student %d\n", ((uint64_t)rax_2));
        printf(" Name: %s\n", rax_9);
        printf(" Age: %d\n", ((uint64_t)rdx_3));
        printf(" Grade: ");
        rax_5 = *(uint32_t*)((char*)rdx_3)[4];
	// snip //
```

Here again we see references to a left shift added to `students` and `data_4048`. We don't see `data_404c`, because Binja has instead accessed the third address by indexing four bytes after the `data_4048` result using `rax_5 = *(uint32_t*)((char*)rdx_3)[4];`. We know this is a four-byte offset because of the cast to a `char*`, with a unit size of one byte, followed by a dereference as a `uint32_t*` cast. This is a bit convoluted and easier to see in disassembly:

```nasm
shl     rax, 0x4 ; rax holds the index choice
mov     rdx, rax
lea     rax, [rel students] ; get address of students
lea     rdx, [rdx+rax] ; rdx now holds the address of students + some offset
mov     rax, qword [rdx]
mov     rdx, qword [rdx+0x8] ; interesting! fetches from 0x8 bytes after student address + offset
mov     qword [rbp-0x10 {var_18_1}], rax
mov     qword [rbp-0x8 {var_10_1}], rdx ; store this value for later
mov     eax, dword [rbp-0x14 {var_1c}]
mov     esi, eax
lea     rax, [rel data_20d9]  {"Student %d\n"}
mov     rdi, rax  {data_20d9, "Student %d\n"}
mov     eax, 0x0
call    printf
mov     rax, qword [rbp-0x10 {var_18_1}]
mov     rsi, rax
lea     rax, [rel data_20e5]  {" Name: %s\n"}
mov     rdi, rax  {data_20e5, " Name: %s\n"}
mov     eax, 0x0
call    printf
mov     eax, dword [rbp-0x8 {var_10_1}] ; using this value again, must be age!
mov     esi, eax
lea     rax, [rel data_20f0]  {" Age: %d\n"}
mov     rdi, rax  {data_20f0, " Age: %d\n"}
mov     eax, 0x0
call    printf
lea     rax, [rel data_20fa]  {" Grade: "}
mov     rdi, rax  {data_20fa, " Grade: "}
mov     eax, 0x0
call    printf
mov     eax, dword [rbp-0x4 {var_10_1+0x4}] ; now load the stored address, add 4, and fetch the dword at that address
cmp     eax, 0x4
je      0x1506
```

So the same "setting" operations in `add_student` are performed as "getting" operations in `lookup_student`. Also, the logging statements give us a clue as to what data is contained in each offset—a name, an age, and a grade.

The last piece of information to fully understand these operations is knowing that `students` holds an array. We can arrive at this conclusion by noticing the offset added to each address is the same: `<some value> << 4`.  A four-bit left shift results in multiplying the value by 16. Let's plug in a couple numbers to understand this operation better. A value of 0 results in 0, meaning we directly access the data at `students, &(students + 8), &(students+0xc)`. Plugging in a 1 means we access values at `&(students+0x10), &(students+0x18), &(students+0x1c)`. So this looks like we're indexing into "chunks" of data, where each chunk is a struct. It logically follows that this is probably a static array of chunks, starting from the `students` address in the bss!

### Defining Structures in Binja

The process of defining a structure given our initial assumptions can be iterative, and it is useful to start defining a struct when we see one even if we do not know everything about it. The first step is getting a feel for its size. This can either be very explicit or difficult depending on how the structure is allocated and referenced. For example, heap-allocated structures will generally be allocated using a call to `malloc(sizeof(struct X))`, which explicitly gives us the size of the struct in the `malloc` call! However here we deal with a static length array, so the answer is not so obvious. Through our previous reverse engineering we saw that the array indexes 16 bytes at a time, due to the left shift of four. This means the struct is 16 bytes (or slightly smaller, and rounded up to 16 to maintain alignment). Let's declare a blank structure in Binja of `0x10` bytes using the `t` hotkey to bring up the `Types` menu followed by the `s` hotkey to create a new type by size. We'll name it `student` and set the guessed size of `0x10` bytes.

As a test, let's declare the address at `student` (`0x4040`) as a `struct student` type. Highlight the named variable in decompilation or navigate to the address and change its type. We see the `bss` format change:

```
struct student students = 
{
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
}
```

The decompilation update immediately gives us a hint that we're probably dealing with an array of `student`s, as it changed the left shift addition into an array index!

```c
    if ((rax_2 >= 0 && rax_2 < ((uint32_t)num_students)))
    {
        int64_t rax_9 = *(uint64_t*)((char*)(&students)[((int64_t)rax_2)] + 0);
        int64_t rdx_3 = *(uint128_t*)((char*)(&students)[((int64_t)rax_2)] + 8);
        printf("Student %d\n", ((uint64_t)rax_2));
        printf(" Name: %s\n", rax_9);
        printf(" Age: %d\n", ((uint64_t)rdx_3));
        printf(" Grade: ");
        rax_5 = *(uint32_t*)((char*)rdx_3)[4];
        if (rax_5 == 4)
```

Let's go ahead and redefine the `students` memory to a `struct student students[10]` type:

```c
    if ((rax_2 >= 0 && rax_2 < ((uint32_t)num_students)))
    {
        int64_t rax_9 = *(uint64_t*)((char*)students[((int64_t)rax_2)] + 0);
        int64_t rdx_3 = *(uint128_t*)((char*)students[((int64_t)rax_2)] + 8);
        printf("Student %d\n", ((uint64_t)rax_2));
        printf(" Name: %s\n", rax_9);
        printf(" Age: %d\n", ((uint64_t)rdx_3));
        printf(" Grade: ");
        rax_5 = *(uint32_t*)((char*)rdx_3)[4];
        if (rax_5 == 4)
```

This is where decompilers tend to struggle—recovering type information for primitives can be easy, but more complex types (especially references and pointers) become much harder. We need to help the decompiler to make better sense of these operations. First, we know that the type of `rax_9` is almost certainly an eight byte `char*` since it is printed with the `%s` formatter. Similarly `rdx_3` is actually a four byte integer since it uses the `%d`parameter. The last member, `rax_5` is also a `*(uint32_t*) == uint32_t` type, or a four-byte unsigned integer. Let's modify our structure by navigating to the `Types` menu and double-clicking on it. Define it as follows:

```c
struct student __packed
{
    char* name;
	unsigned int age;
	int grade;
};
```

Save that format and use the toolbar's `Analysis -> Reanalyze` to force Binja into propagating those changes. The output is much better!

```c
    if ((rax_2 >= 0 && rax_2 < ((uint32_t)num_students)))
    {
        int64_t rax_9 = students[((int64_t)rax_2)].name;
        int64_t rdx_3 = students[((int64_t)rax_2)].age;
        printf("Student %d\n", ((uint64_t)rax_2));
        printf(" Name: %s\n", name);
        printf(" Age: %d\n", ((uint64_t)rdx_3));
        printf(" Grade: ");
        rax_5 = *(uint32_t*)((char*)rdx_3)[4];
        if (rax_5 == 4)
        {
```

Now we have a better understanding that the operations fetch the name and age from the struct for printing. We still have some type inconsistencies in the local variable definitions, but we can clean these up and name them. The only curious thing is how the grade is accessed—the CPU fetches a quadword (eight bytes) at the `student.age` offset, prints the first four bytes, and stores the last four bytes in `rax_5`. This is simply a compiler optimization as we saw in the disassembly. We can double-check our structure is correct by looking at other uses, such as the `add_student` function:

```c
int32_t add_student()

{
    char* buf = malloc(0x10);
		// snip //
		if ((rax_10 <= 4 && rax_10 > 0))
        {
            uint8_t num_students_1 = num_students;
            num_students = (num_students_1 + 1);
            uint32_t num_students_2 = ((uint32_t)num_students_1);
            students[((int64_t)num_students_2)].name = buf;
            students[((int64_t)num_students_2)].age = rax_7;
            rax_1 = rax_10;
            students[((int64_t)num_students_2)].grade = rax_1;
        }
    // snip //
```

That looks much better! We can go an extra step and define an enum for the grade if we choose—this is not explicitly necessary given the short menu of options, but it is useful when a program uses longer enums such as [file modes](https://elixir.bootlin.com/glibc/glibc-2.39.9000/source/io/fcntl.h) and [error numbers](https://elixir.bootlin.com/glibc/glibc-2.39.9000/source/sysdeps/mach/hurd/bits/errno.h). We define this in the `Types` menu using the `e` hotkey (instead of `s`). It is important here to set the size of the enum, though the default `uint32_t` is appropriate because we know it is accessed as a four byte value. We should also update the `student` struct to reflect the new `enum` while we are at it.

```c
enum grade : uint32_t
{
	FRESHMAN = 1,
	SOPHOMORE = 2,
	JUNIOR = 3,
	SENIOR = 4
};

struct student __packed
{
    char* name;
    uint32_t age;
    enum grade grade;
};
```

This is really handy for switch statements. Changing the type for `rax_5` in `lookup_student` to the `enum grade` type will automatically match the cases to the enum values, presenting a very nice decompilation view!

```c
    enum grade rax_5;
    if ((rax_2 < 0 || (rax_2 >= 0 && rax_2 >= ((uint32_t)num_students))))
    {
        rax_5 = puts("Invalid index!");
    }
    if ((rax_2 >= 0 && rax_2 < ((uint32_t)num_students)))
    {
        int64_t name = students[((int64_t)rax_2)].name;
        int64_t rdx_3 = students[((int64_t)rax_2)].age;
        printf("Student %d\n", ((uint64_t)rax_2));
        printf(" Name: %s\n", name);
        printf(" Age: %d\n", ((uint64_t)rdx_3));
        printf(" Grade: ");
        rax_5 = *(uint32_t*)((char*)rdx_3)[4];
        if (rax_5 == SENIOR)
        {
            rax_5 = puts("Senior");
        }
        else if (rax_5 == JUNIOR)
        {
            rax_5 = puts("Junior");
        }
        else if (rax_5 == FRESHMAN)
        {
            rax_5 = puts("Freshman");
        }
        else if (rax_5 == SOPHOMORE)
        {
            rax_5 = puts("Sophomore");
        }
```

### Defining Structures in Ghidra

The process for defining a structure in Ghidra is similar but a bit more painstaking. In the `Data Type Manager` pane, right click on the project name (in this case, `structs`) and navigate to `New -> Structure` (or `enum`, for the grade field).

![[ghidra_structure.png]]

The `struct` GUI is a bit clunky, and it is sometimes easiest to first declare your structure's size to automatically create placeholder data:

![[ghidra_blank_struct.png]]
Now we're free to start defining `DataType`s and `Name`s, and Ghidra will automatically update the structure as we go. The toolbar icons are also useful for quickly deleting or adding new fields, and navigating through existing ones. We can always modify the structure later by finding it in the `Data Type Manager` window, right clicking, and choosing `Edit`. The two structs look as follows.

![[ghidra_structs.png]]

> Note that the default `enum` size in Ghidra is 1, and this should be updated to 4 to match the compiled structure's layout in memory.

We can similarly update the `students` type in memory by navigating to its address in the bss and using the `t` hotkey to apply a `student[10]` type. The resulting decompilation is updated to be much more digestible:

![[ghidra_struct_application.png]]

### Practical Example

Identifying structures is a key skill that gets better with practice, so we will focus our practical example for this week on reverse engineering a common data structure in [[lesson3_example]]. Our goal for this demonstration is to better understand the underlying structure and functionality of the program and trace the different operations performed.

#### Initial Observations

```c
int32_t main(int32_t argc, char** argv, char** envp)

{
    int32_t var_14 = 0;
    get_data("./data");
    puts("Satisfy the conditions to win!");
    char* rax_3 = get_h(get_num());
    int32_t rax_21;
    if (rax_3 == 0)
    {
    label_18c5:
        puts("Nope! Sorry!");
        rax_21 = 1;
    }
```

The initial decompilation from Binja gives us a couple good hints. First, we see a prompt stating that we have some end goal of fulfilling conditions correctly to satisfy the program. We also see what looks like a failure condition, at `label_18c5`, that looks like a failure condition. This label is referenced in a handful of conditional checks, which we presumably want to avoid failing. We also see a function that presumably ingests some data.

```c
fail:  // renamed to fail
    puts("Nope! Sorry!");
    rax_21 = 1;
}
else
{
    if (strcmp("Alien", rax_3) != 0)
    {
        goto fail;
    }
    if (get_num() != idx_h(0x13))
    {
        goto fail;
    }
    delete(0);
    if (get_num() != idx_h(0x13))
    {
        goto fail;
    }
    char* rax_15 = get_t(get_num());
    if (rax_15 == 0)
    {
        goto fail;
    }
    // .... //
```

We have a decision to make here on how we spend our time, and it is beneficial to be a bit thoughtful so we orient our efforts in the best way possible. There are a handful more functions referenced in the rest of the code, so we could attempt to dive into those first. But if the data we're operating on is complex or not clearly formatted, we could struggle to understand the point of the functions. For example, let's look at `get_h`:

```c
int64_t get_h(int32_t arg1)

{
    uint64_t h_1 = h;
    int64_t rax_5;
    while (true)
    {
        if (*(uint64_t*)(h_1 + 0x10) == ((int64_t)arg1))
        {
            rax_5 = *(uint64_t*)(h_1 + 0x18);
            break;
        }
        h_1 = *(uint64_t*)h_1;
        if (h_1 == h)
        {
            rax_5 = 0;
            break;
        }
    }
    return rax_5;
}
```

This function depends on `h` and `h_1`, and some data that is based off of its _structure_. But without knowing what `h` is, we cannot understand much. `h` has a lot of cross references where it is used elsewhere in the program, including the `insert` function which is called from `get_data`. 

![[Pasted image 20240914175322.png]]

So we really need to understand `h` and the data it contains. Let's then start with the `get_data` function.

#### Structure of Data

The first thing the `get_data` function does is open a file with `fopen` and handles error cases by logging and returning. It uses the argument to the function, `./data`, as the path.

> Make sure to copy the [[data]] file to the same directory as [[lesson3_example]] for any dynamic analysis.

```c
int64_t get_data(char* arg1)

{
    void* fsbase;
    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);
    FILE* rax_2 = fopen(arg1, &data_2011);
    if (rax_2 == 0)
    {
        perror("Error opening file");
    }
    else
```

Parsing of the data in the file seems a bit complocated and contains calls to `getdelim` and `getline` and performs a number of operations on arrays. Understanding the structure of the data file can tell us a lot about how it is intended to be used and how to build our mental model of the program. We could reverse engineer the sequence of operations in the decompiled code, but it is useful to first orient ourselves by inspecting the data file (if we have access to it). 

```console
$ cat data/lesson3/data 
1 Sarah Connor
12 Neo
58 Paul Atreides
97 E.T.
19 Alien
0 Predator
80 Spock
14 Han Solo
67 Rick Deckard

```

Dumping the data in [[data]] gives us an edge in understanding the decompilation. It seemingly contains some sort of integer-string pair broken up to a single pair per line. 

This translates well to the high-level decompilation, which shows a call to `ssize_t rax_17 = getdelim(&var_48, &n, ' ', rax_2);`, where the third argument can be represented as `0x20`, or as `' '` (the ASCII character for `0x20`). Reading the `man` page briefly indicates this is used to ingest bytes from a file until a chosen delimiter—`' '`, in our case—is reached. This presumably fetches the integer characters at the beginning of each line and terminates when reading the space character. Next, `getline` reads until the end of the line, which ingests the rest of the line containing the name. Both return the number of characters read or -1 on error. That count is used to index into the buffers and null-terminate them. Next, the integer string, presumably representing some type of key, is converted into its corresponding integer value with `strtol`. Finally, the integer and name are passed to an `insert` function. With some naming and light reverse engineering, we get the following function:

```c
    char* getdelim_buf = nullptr;
    char* getline_buf = nullptr;
    uint64_t n = 0;
    while (true)
    {
        ssize_t getdelim_n = getdelim(&getdelim_buf, &n, ' ', rax_2);
        if (getdelim_n == -1)
        {
            break;
        }
        ssize_t getline_n = getline(&getline_buf, &n, rax_2);
        if (getline_n == -1)
        {
            break;
        }
        if (getdelim_buf[(getdelim_n - 1)] == ' ')
        {
            getdelim_buf[(getdelim_n - 1)] = 0;
            int64_t var_28_1 = (getdelim_n - 1);
        }
        int64_t key = strtol(getdelim_buf, nullptr, 10);
        if (getline_buf[(getline_n - 1)] == '\n')
        {
            getline_buf[(getline_n - 1)] = 0;
            int64_t var_20_1 = (getline_n - 1);
        }
        insert(key, getline_buf);
```

#### Defining our Struct

Knowing the arguments are a key-name pair is helpful, however the `insert` function is still a bit complicated on first glance.

```c
uint64_t insert(int64_t key, char* name)

{
    uint64_t rax = malloc(0x20);
    *(uint64_t*)(rax + 0x10) = key;
    *(uint64_t*)(rax + 0x18) = name;
    if ((h != 0 || (h == 0 && t != 0)))
    {
        *(uint64_t*)(h + 8) = rax;
        **(uint64_t**)&t = rax;
    }
    if ((h == 0 && t == 0))
    {
        t = rax;
        h = rax;
    }
    *(uint64_t*)rax = h;
    *(uint64_t*)(rax + 8) = t;
    h = rax;
    return rax;
}
```

We see `0x20` bytes allocated by `malloc` on the heap, and then references to offsets from the beginning of the returned pointer, `rax`, such as `rax + 0x10` and `rax + 0x18`. Whenever we see assignments and fetches to addresses at offsets from the beginning of a `malloc`ed buffer, it is likely that this is a structure.

Before we go on, it is helpful to define a structure even if we do not populate it with its member variables. For now we can call this structure `pair` and define it as `0x20` bytes per the `malloc` call.
![[pair.png]]
Defining the return from the `malloc` call as a `pair*` does not help out much in the decompilation, but Binja automatically informs us that the `pair` struct has references at 8, 16, and 24 byte offsets into the structure in its Types pane:

![[pair_definition.png]]

Even just defining each offset as an eight-byte quadword (even if it is not correct) quickly cleans up the decompilation!

![[pair_definition2.png]]

Now the knowledge of arguments comes in handy, as we can define `field_10` to be a `long key` and `field_18` to be `char* name`. We still need help for the first and second eight bytes in the structure, though. We need to look for other context, such as the fact that both `t` and `h` are set equal to the `pair*` structure in certain control flows. We can jump to both symbols by double-clicking and redefine both as `struct pair*` types.

```
.bss (NOBITS) section started  {0x4010-0x4030}
00004010  uint64_t* const __TMC_END__ = nullptr
00004018  uint8_t completed.0 = 0x0

00004019                             00 00 00 00 00 00 00           .......

00004020  struct pair* h = nullptr
00004028  struct pair* t = nullptr
```

The result really helps us reason about the purpose of the two remaining quadwords. We see that those types must _also_ be `struct pair*`, because `h->field_8` and `tail->field_0` are also assigned to `p` in the other control flow. Presumably this is some sort of linked list, where `h` points to the head and `t` to the tail.

![[pair_definition3.png]]

We see that aggressively defining a structure, its members, and typing variables in the program helps us more quickly reason about the function and underlying data. Assuming `field_0` is the `next` (or `fw`) pointer and `field_8` the `prev` (or `bk`), our result is a very nice looking linked list `insert` function!

![[pair_definition4.png]]

#### Reversing Functions and Satisfying Conditions

We have a good mental model of the data now: `h` and `t` point to the head and tail of a linked list of key-value pairs. The `pair`s have linked list pointers as well as an integer (key) and name (value). Let's jump back to `main` and focus on how this data is used:

```c
    char* rax_3 = get_h(get_num());
    int32_t rax_21;
    if (rax_3 == 0)
    {
    fail:  // renamed to fail
        puts("Nope! Sorry!");
        rax_21 = 1;
    }
```

We're asked for a number (in the `get_num` function) which is used as an argument to `get_h`. Now that we understand `h`, let's focus on `get_h`—specifically how we can get it to return a non-null value so we do not hit the failure condition.

```c
char* get_h(int32_t arg1)

{
    struct pair* var_10 = h;
    char* name;
    while (true)
    {
        if (var_10->key == ((int64_t)arg1))
        {
            name = var_10->name;
            break;
        }
        var_10 = var_10->next;
        if (var_10 == h)
        {
            name = nullptr;
            break;
        }
    }
    return name;
}
```

Our structure definition has propagated! Notice how `var_10` is now known to be a `struct pair*` type as it is initially assigned to `h`. Further, we can clearly see that `pair->key` is used in the comparison to the input argument that we supply on the command line. If it matches then `pair->name` is returned. If not, then `var_10` is updated to the next item in the list. If `var_10 == h` then `nullptr` (0) is returned, which is what we want to avoid. What does this condition mean? It means that `var_10` has circled back around to the point where it points to the head of the list again. This means there was no match for the given key in the list.

So, we just need to provide any key that matches a `key` in the data file. That should be easy! But unfortunately it's not _quite_ that simple; if we find a match in the list, the returned value is immediately compared to  `"Alien"` in `main`:

```c
    char* rax_3 = get_h(get_num());
    int32_t rax_21;
    if (rax_3 == 0)
    {
    fail:  // renamed to fail
        puts("Nope! Sorry!");
        rax_21 = 1;
    }
    else
    {
        if (strcmp("Alien", rax_3) != 0)
        {
            goto fail;
        }
```

So we need to supply a _specific_ key—the key associated with `"Alien"`. Quickly scanning the data, that key should be 19. Let's briefly test that theory by spinning up the binary:

```console
$ ./lesson3_example 
Satisfy the conditions to win!
19

```

We didn't get failure output and the terminal is waiting for another input! Great, this means we are on the right track.

Let's reverse the next condition, which involves `idx_h`:

```c
        if (get_num() != idx_h(0x13))
        {
            goto fail;
        }
```

At first glance, `idx_h` looks similar in that it takes a key and iterates from the head of the list, checking `var_10->key` against the input. The termination condition looks similar, but this time it appears to return some sort of counter which is incremented each loop iteration:

```c
uint64_t idx_h(int32_t arg1)

{
    int32_t var_14 = 0;
    struct pair* var_10 = h;
    uint64_t rax_4;
    while (true)
    {
        if (var_10->key == ((int64_t)arg1))
        {
            rax_4 = ((uint64_t)var_14);
            break;
        }
        var_14 = (var_14 + 1);
        var_10 = var_10->next;
        if (var_10 == h)
        {
            rax_4 = 0xffffffff;
            break;
        }
    }
    return rax_4;
}
```

Let's test some basic cases to understand what the counter represents. If we input the key value for the head of the list then `rax_4` is immediately returned with value 0. Otherwise it increments to 1. If the key matches the second item in the list then the value 1 would be returned, otherwise it's incremented to 2. We can conclude this counter represents the index in the linked list, starting from the head of the list.

The function call in main inputs value `0x13`, or 19 in decimal. We need to match the output of `idx_h` with our input here, so we need to see where the node with key 19 is in the list. Quickly dumping the data, we see that is the key for `"Alien"` again. It is the fifth item from the top of the list, meaning it is index 4.

```
1 Sarah Connor
12 Neo
58 Paul Atreides
97 E.T.
19 Alien
0 Predator
80 Spock
14 Han Solo
67 Rick Deckard

```

We can input that value into the running program to again check our understanding, and it indeed passes! Great, on to the next condition.

Here we have a `delete` function prior to another call to the same `get_num(), idx_h(0x13)` calls we just passed.

```c
        delete(0);
        if (get_num() != idx_h(0x13))
        {
            goto fail;
        }
```

Dumping the `delete function` shows another scan through the list based on the input `key` value. If we hit a match, then we update pointers from the `prev` and `next` node to point to one another, essentially eliminating the chosen node from the linked list. It also `free`s the data associated with the linked list `pair` now that it is not needed. This should fit our mental model of the linked list we previously established. Again, understanding the structure of `h` pays dividends here.

```c
struct pair* delete(int32_t arg1)

{
    struct pair* var_10 = h;
    struct pair* h_1;
    do
    {
        if (var_10->key == ((int64_t)arg1))
        {
            var_10->next->prev = var_10->prev;
            var_10->prev->next = var_10->next;
            free(var_10->name);
            h_1 = free(var_10);
            break;
        }
        var_10 = var_10->next;
        h_1 = h;
    } while (var_10 != h_1);
    return h_1;
}
```

This means the program removes the `pair` associated with key `0`, or `"Predator"`. The links before and after this `pair` are updated, meaning `idx_h` changes for all nodes after. However, our target is the `"Alien"` node again, which is above the deleted node. Presumably, our index from the head (4) does not change.

```console
$ ./lesson3_example 
Satisfy the conditions to win!
19
4
4
Nope! Sorry!
```

Confirmation of this fails. This means something about our mental model of the program or understanding of a function is incorrect. Instead of reviewing the static decompiled code and looking for a mistake, let's dynamically analyze the program to gain a different perspective and assess what is wrong.

#### Debugging Our Understanding in GDB

We should try and focus our debugging just like we focus our static reverse engineering. The breakdown in our mental model occurs after we delete a node, so it would be wise to focus on the delete operation or the system state right after.

One quick check could be to traverse the list, just like the program does. Further, we can watch the program traverse the list when it's performing the second `idx_h` call. A quick way to get to that point is with the following gdb commands:

```gdb
gef➤  b delete
Breakpoint 1 at 0x16a3
gef➤  r
< enter 19 >
< enter 4 >
gef➤  b idx_h # set breakpoint at idx_h when we hit the delete breakpoint
gef➤  c       # continue to idx_h
< enter any value >
Breakpoint 2, 0x0000555555555551 in idx_h ()
 → 0x555555555551 <idx_h+0008>     mov    DWORD PTR [rbp-0x14], edi
   0x555555555554 <idx_h+000b>     mov    DWORD PTR [rbp-0xc], 0x0
   0x55555555555b <idx_h+0012>     mov    rax, QWORD PTR [rip+0x2abe]        # 0x555555558020 <h>
   0x555555555562 <idx_h+0019>     mov    QWORD PTR [rbp-0x8], rax
   0x555555555566 <idx_h+001d>     mov    rax, QWORD PTR [rbp-0x8]
   0x55555555556a <idx_h+0021>     mov    rdx, QWORD PTR [rax+0x10]
```

Let's step a couple instructions to see the `h` value loaded into `rax`.  Next, let's dump the `pair` at `rax` to confirm we see the head of the list. The `idx` and `name` are in the third and fourth quadword based on our definition of the struct.

```
gef➤  x/4xg $rax
0x55555555ab10:	0x000055555555aa60	0x000055555555a590
0x55555555ab20:	0x0000000000000043	0x000055555555aa90
gef➤  x/s 0x000055555555aa90
0x55555555aa90:	"Rick Deckard"
```

We see `0x43` and `"Rick Deckard"` in the pair, which doesn't match the top of the data list (`1, "Sarah Connor"`)! In fact, `"Rick Deckard"` is the end of the data list. Let's double check the `insert` method:

```c
struct pair* insert(int64_t key, char* name)

{
    struct pair* p = malloc(0x20);
    p->key = key;
    p->name = name;
    if ((h != 0 || (h == 0 && t != 0)))
    {
        h->prev = p;
        t->next = p;
    }
```

`h` is non-null for any node inserted after the first. For the second, third, etc. `pair`, the new node is _added at the head of the list, pushing the other items backward_. This is an implementation of a _stack_, which is _last in, first out_ model. Counting from the top of the list assumed a _queue_, or _first in, first out_ model. 

So why did our count from the top work prior to the `delete` function? Well, it just so happens that `"Alien"` is in the _middle of the list_, so counting from the head or tail returns the same value. That is a very nuanced error, and it's no surprise it slipped by! With our new understanding, we can count from the bottom of the list and skip the deleted `"Predator"` pair to get a new index of 3:

```console
$ ./lesson3_example 
Satisfy the conditions to win!
19
4
3

```

Now we're back on track!

#### Final Answers

We can now see the finish line; two more comparisons and we're presumably done. We're dealing with new functions, but they feel familiar:

```c
        char* rax_15 = get_t(get_num());
        if (rax_15 == 0)
        {
            goto fail;
        }
        if (strcmp("Spock", rax_15) != 0)
        {
            goto fail;
        }
        if (get_num() != idx_t(0xc))
        {
            goto fail;
        }
        puts("You got it!");
        rax_21 = 0;
```

Quick assessment of the `get_t` and `idx_t` functions show that they employ the same logic as their pair `get_h` and `idx_h` functions, just that they start from the tail instead of the head. We can distill the remaining checks into the following:
1. Enter the key of `"Spock"`
2. Enter the index of the `pair` with index 12 (`0xc`) counting from the tail

```
1 Sarah Connor     <-- tail
12 Neo
58 Paul Atreides
97 E.T.
19 Alien
80 Spock
14 Han Solo
67 Rick Deckard    <-- head

```

Quick review of the data—with `"Predator"` removed—shows the key for `"Spock"` is 80 and the index for `"Neo"` (key `0xc`) is 1 from the tail.

Our final attempt shows that our reverse engineering was correct, and we have successfully passed the challenge!

```console
$ ./lesson3_example 
Satisfy the conditions to win!
19
4
3
80  
1
You got it!
```

#### Reflections

Starting reverse engineering on a new target is generally arduous, especially when dealing with structures. It can be tempting to say "I'll deal with this structure later when I have more context," but this is actually generally not wise. Sometimes definition and first attempts at a structure's composition, even if wildly incorrect, can add essential context—context necessary for deeper understanding of the program and for the structure itself!

We saw this in this problem. The `get_data` and `insert` functions seemed mystifying at first without any context. But better understanding of the data gave us a starting point for the `pair` structure. And with the `pair` structure defined we were able to gain context about the type of `h` and `t`. With that context we finalized the understanding of the linked list that underpinned all the other functions in the binary.

Once things clicked into place, our mental model helped us quickly progress through initial checks. We did run into an issue with our mental model, but our understanding of large pieces of the program helped quickly debug this error and correct our assumptions. Then, the final pieces quickly snapped into place.

## SAT Solvers

Once we understand more about a system, we might identify an interesting piece of code that we want to explore. Reaching areas of code, whether to obtain a flag or investigate a potential vulnerability, can be very convoluted in complex programs with meandering control flow. In such situations, SAT solvers are useful for quickly solving controlling checks or branching conditions.

A particularly useful tool for solving constraints is Z3, a Microsoft tool which markets itself as a [high performance theorem prover](https://ericpony.github.io/z3py-tutorial/guide-examples.htm). Z3 has a Python API which makes it extremely easy to spin up for even complex problems. Their [example guide](https://ericpony.github.io/z3py-tutorial/guide-examples.htm) has some useful references, however we will go through our own shortly.

Z3 is easy to install in your Python environment, simply `pip3 install z3-solver` to add it to your requirements. Importing it is slightly tricky—Z3 is actually composed of two Python modules, `z3` and `z3solver`. Pay attention to the import lines in the following snippets, and when in doubt, try one and pivot to the other if the import fails.

### Simple Z3 Use Case

Z3 is effective right out of the box for solving constrained problems without a system of equations. Consider the [[simple_z3.c]]:

```c
#include "stdio.h"
#include "stdlib.h"
#include "unistd.h"
#include "string.h"

int get_int() {
    char buf[0x10];
    fgets(buf, 0x10, stdin);
    char* nl = strchr(buf, '\n');
    if (nl) { *nl = '\0'; }
    return atoi(buf);
}

int main() {
    int x, y, z;
    puts("Give me the three secret numbers: ");
    x = get_int();
    y = get_int();
    z = get_int();
    if (x < 2 || y < 2 || z < 2) { goto fail; }
    if (x > 0x100 || y > 0x100 || z > 0x100) { goto fail; }
    if (x > y || y > z) { goto fail; }
    if (x * y * z != 778910) { goto fail; }
    if (z % x != 37) { goto fail; }
    puts("Those are the correct answers!");
    puts("You win!!");
    return 0;
fail:
    puts("Nope! Those numbers are not correct!!");
    return 1;
}
```

We can write a very simple Z3 solver by defining `Int`s that represent each of the user inputs. We then create a `Solver` instance which allows us to plainly specify the constraints that must be upheld to reach the winning condition. Finally, we check that the model is satisfiable and print the winning output!

```python
from z3 import Int, Solver, sat

# declare three integers, the goal of our solver
x = Int('x')
y = Int('y')
z = Int('z')

# create solver and enforce constraints per the program control flow
s = Solver()
s.add(x > 2, y > 2, z > 2)
s.add(x < 0x100, y < 0x100, z < 0x100)
s.add(x <= y, y <= z)
s.add(x * y * z == 778910)
s.add(z % x == 37)

# solve!
assert s.check() == sat, "Error, not satisfiable!"
print(s.model())
# prints
# [x = 73,
#  z = 110,
#  y = 97,
#  div0 = [else -> 1],
#  mod0 = [else -> 0]]
```

### Tweaked Z3 Use Case

The prior example is pretty simple; we might be able to work it out on our own by assembling a system of equations because the sample space is so small. But what happens if we tweak these constraints and sample space? Now, we leverage the modulo and division operator, and incorporated signedness into the product in [[tweaked_z3.c]].

> Signedness is extremely important when the most significant bit is set by an operation. For example `0x8000 * 0x10000 = 0x80000000`, which is `0b10000000000000000000000000000000`. As an unsigned integer, this is just `MAX_INT / 2 = 2147483648`, but if it is signed then it is `-MAX_INT / 2 = -2147483648` 

```c
#include "stdio.h"
#include "stdlib.h"
#include "unistd.h"
#include "string.h"

int get_int() {
    char buf[0x10];
    fgets(buf, 0x10, stdin);
    char* nl = strchr(buf, '\n');
    if (nl) { *nl = '\0'; }
    return atoi(buf);
}

int main() {
    int x, y, z;
    puts("Give me the three secret numbers: ");
    x = get_int();
    y = get_int();
    z = get_int();
    if (x < 0 || y < 0 || z < 0) { goto fail; }
    if (x > 0x10000 || y > 0x10000 || z > 0x10000) { goto fail; }
    if (x * y != -1508619901) { goto fail; }
    if (z % 73 != 28) { goto fail; }
    if (y / z != 9 || y + z != 53798) { goto fail; }
    puts("Those are the correct answers!");
    puts("You win!!");
    return 0;
fail:
    puts("Nope! Those numbers are not correct!!");
    return 1;
}
```

This is significantly harder to solve by hand and requires understanding bit-wise operations like two's complement representation of signed integers. In this situation we can use Z3's machine operations types, specifically `BitVec`, which contains a bitwise representation of an integer. We can tweak our solver script for the new constraints.

```python
from z3 import Solver, BitVec, sat

# declare three integers, the goal of our solver
x = BitVec('x', 32)
y = BitVec('y', 32)
z = BitVec('z', 32)

# create solver and enforce constraints per the program control flow
s = Solver()
s.add(x > 0, y > 0, z > 0)
s.add(x < 0x10000, y < 0x10000, z < 0x10000)
s.add(x * y == -1508619901)
s.add(z % 73 == 28)
s.add(y / z == 9, y + z == 53798)

# solve!
assert s.check() == sat, "Error, not satisfiable!"
print(s.model())
# prints [x = 57005, y = 48879, z = 4919], x = 0xdead, y = 0xbeef, z = 0x1337
```

Z3 solves the problem for us in fractions of a second! This shows some of the power of Z3.

> We can check the default sign representation of `BitVec` by creating one with the value -1 (with `BitVecVal`):
> ```python
> from z3 import BitVecVal
> y = BitVecVal(-1, 16)
> print(y)
># prints 65535, which in binary is 0b1111111111111111
>```
>
>If we instead want an unsigned representation, we can use the functions `ULT, ULE, UGT, UGE, UDiv, URem and LShR` representing unsigned `<, <=, >, >=, /, % and >>` operators. This is particularly useful for solving integer overflow scenarios, as shown below!
>
>```python
>from z3 import UGT, BitVec, solve
>x = BitVec('x', 16)
>solve(UGT(x, 0), x + 1 == 0)
># prints [x = 65535]
>```
### Z3 and Functions

The last piece of Z3 functionality we'll cover is enforcing function constraints. This is a logical extension of what we already covered, so consider the slightly modified tweaked use case from above, in [[functions_z3.c]].

```c
#include "stdio.h"
#include "stdlib.h"
#include "unistd.h"
#include "string.h"
#include "stdbool.h"

int get_int() {
    char buf[0x10];
    fgets(buf, 0x10, stdin);
    char* nl = strchr(buf, '\n');
    if (nl) { *nl = '\0'; }
    return atoi(buf);
}

int perform_mod(int a, int b) {
    return a % b;
}

bool check(int x, int y, int z) {
    if (x * y != -1508619901) { return false; }
    if (perform_mod(z, 73) != 28) { return false; }
    if (y / z != 9 || y + z != 53798) { return false; }
    return true;
}

bool check_bounds(int x, int y, int z) {
    if (x < 0 || y < 0 || z < 0) { return false; }
    if (x > 0x10000 || y > 0x10000 || z > 0x10000) { return false; }
    return true;
}

int main() {
    int x, y, z;
    puts("Give me the three secret numbers: ");
    x = get_int();
    y = get_int();
    z = get_int();
    if (!check_bounds(x, y, z)) { goto fail; }
    if (!check(x, y, z)) { goto fail; }
    puts("Those are the correct answers!");
    puts("You win!!");
    return 0;
fail:
    puts("Nope! Those numbers are not correct!!");
    return 1;
}
```

This is simply a slightly more verbose representation of the prior example where checks are compartmentalized into functions. This is more representative of real-world applications, as checks are normally abstracted away so they can be unit tested for assurance.

We again want to use `BitVec`s to represent our input based on signedness considerations. We can use the boolean `And` function from Z3 to literally replicate the functions in Python, passing `BitVec`s back and forth:

```python
from z3 import Solver, BitVec, And, sat

def perform_mod(a, b):
    return a % b

def check_bounds(x, y, z):
    return And(x < 0x10000, y < 0x10000, z < 0x10000)

def check(x, y, z):
    return And(x * y == -1508619901,
               perform_mod(z, 73) == 28,
               y / z == 9,
               y + z == 53798)

# declare three integers, the goal of our solver
x = BitVec('x', 32)
y = BitVec('y', 32)
z = BitVec('z', 32)

# create solver and enforce constraints per the program control flow
s = Solver()
s.add(x > 0, y > 0, z > 0)
s.add(check_bounds(x, y, z) == True)
s.add(check(x, y, z) == True)

# solve!
assert s.check() == sat, "Error, not satisfiable!"
print(s.model())
# prints [x = 57005, y = 48879, z = 4919], x = 0xdead, y = 0xbeef, z = 0x1337
# same as above!
```

Pretty cool! Z3 abstracts away all the bitwise operations, logical comparisons, etc., and the result is an extremely readable and easily debuggable script. It is a powerful tool in the reverse engineer's toolbox whenever pathfinding and condition solving are the goal!

## Recitation

#### Recitation 3.0

Disassemble and decompile [[recitation3.0]] to reverse the struct leveraged in `main` and other functions. What type of structure does this represent? What are its fields? *No source!*

#### Recitation 3.1

Disassemble and decompile  to reverse the struct in the shared library [[librecitation3.1.so]]. The entry point for the library, which accepts the structure of interest, is `handle_response(struct ??)`. What is your best guess of the structure and its fields? *No source!*

#### Recitation 3.2

Write a solver for the [[recitation3.2]] using Z3. _No source!

## Next Steps

Identifying structures in code is an essential skill for reverse engineering real-world code, and Z3 is a handy tool for solving non-trivial constraints. We will continue to build upon these skills in our next and final reverse engineering lesson.