
```markdown
> [!OVERVIEW]
> Goal: 
> Reverse-engineer a program (in its compiled binary form) we hackers get our hands on, i.e. figure out how it works under the hood without accessing the source code

> Tools:
> 	Static
> 		def: tools that analyse a program w/o running it
> 		e.g. `file, strings, readelf, objdump`
> 	Dynamic
> 		def: apply these tools while program runs
> 		e.g. GNU debugger

```


Reverse engineering is the process of understanding how a system works. The amount of information given (black box vs gray box vs white box) affects how difficult it is to understand the target. It also may dictate the choice of tools used in the reverse engineering process.

In this course we focus on black-box engineering—that is, we want to understand a system without relying (or having) source code. We must leverage tooling and our knowledge of computer systems to illuminate the target’s inner workings (and, later in the course, vulnerabilities). 

This lesson’s focus is introducing some common tools in a reverse engineer’s toolbox. These tools will assist us in solving challenge problems ahead, allow us to reverse engineer simple binaries, and form a foundation to quickly build upon in future lessons!



Table of Contents:
* [[#References]]
* [[#Static Analysis Tooling]]
	- [[#Command Line Tools]]: `file, strings, readelf, objdump`
	- [[#Disassemblers and Decompilers]]: Ghidra and Binary Ninja
	- [[#`pwntools.ELF`]]
- [[#Dynamic tooling]]
	- [[#GDB]]
	- [[#`pwnlib.gdb()`]]
- [[#Recitation]]

There are two flavors of tools introduced in this lesson: static and dynamic. Static tooling operates on the binary without invoking it. That is, it uses the bytes in the binary to provide information about its functionality. This tooling is generally fast and can provide good preliminary insight, however static analysis may fall short when analyzing complex systems, in particular when trying to identify vulnerabilities that rely on specific state transitions such as race conditions or heap state. 

Dynamic tooling invokes the target, either directly or through emulation, and provides information during execution. This tends to come with a cost; generally the amount of information provided is linearly tied to the overhead imposed on the executed target. However, these tools are invaluable for understanding more complex targets, such as the compiled binaries we will investigate in this course.

## References (Guides to Help Us)

Before going any further, it is useful to highlight some reference materials for if and when we inevitably get stuck. We cannot cover everything there is to know about Linux systems, reverse engineering, and exploitation in this course. Therefore it is always useful to have guides, manuals, etc. in our back pocket when we run into something we do not know.

Here is a (non-exhaustive) list of useful references for various topics:
* Linux manual (`man`) pages: these describe core Linux and C-standard functionality, including functions and syscalls. _Useful for when we into an unknown or unfamiliar function during reverse engineering, and for fully understanding side effects of a function when leveraging it during exploitation_. The pages are available online (simply Google `man X`) or through the Linux command line (`man <manual number> X`). Sometimes it is helpful to Google if not familiar with the [manual numbers](https://man7.org/linux/man-pages/man1/man.1.html) (yes—there is a `man` page for `man` :))
* The [Intel x64 Architecture Manual](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html): the foremost authority on the instructions we work with in this course and _can_ be useful for understanding unknown instructions. That said, it is bulky, tedious, and extremely low level. It is therefore worth _a quick Google when running into an unknown instruction_ to better understand its functionality
* The [`pwntools`](https://docs.pwntools.com/en/stable/) Python manual: useful for _understanding all the functionality at our fingertips when using `pwntools`_ for reverse engineering and exploitation

With that out of the way, let’s dive into static analysis tools!

## Static Analysis Tooling

As mentioned, static analysis tooling operates on the bytes in the target without actually invoking it. There are a number of Linux command line tools to provide static information, and we will look at a few of them now.

### Command Line Tools
- initial bytes "magic bytes" may indicate the file type
- 

We used the `file` command in the last lesson, though we did not discuss how it works. `file` parses the file’s first bytes, called "magic bytes," to determine the file type. From that type, it can infer more information by parsing headers and other info. As shown previously, `file` can tell us the type of file, the architecture, whether it is statically/dynamically linked, and whether it has symbols.  --> how can a program not have symbols?
These are all crucial pieces of information as we prepare to analyze an executable.
- command file
	- parses the first bytes

The `strings` command is an underrated utility for getting a quick understanding of what a program does. Its function is simple—it scans the binary for sequences of ASCII printable characters and logs any that are longer than four bytes (by default). For small programs this might not seem super useful—but many large programs include a slew of debug strings to make triaging crashes easier. `strings` captures these debug strings to help us glean potential functionality. This is especially helpful for stripped binaries, because dumping symbols does not provide much information.
- command strings
	- purpose: captures debug strings
	- syntax: 
	- terms
		- debug strings
			- sequences of ASCII-printable chars 
			- gets logged by default if >= 4 bytes

We can add to our knowledge of the binary using the `readelf` command. We explored this command last week using the `-Ws` flags to dump an executable's symbols. This utility has a number of other options, which you are encouraged to explore on your own. One use case is dumping program header and segments using the `-Wl` flag. Let's a look at the [[static]] and [[dynamic]] binaries from the [[0. Operating Systems Refresher & Pwntools|previous lesson]].

```console
$ readelf -Wl static 

Elf file type is EXEC (Executable file)
Entry point 0x401720
There are 10 program headers, starting at offset 64

Program Headers:
  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align
  LOAD           0x000000 0x0000000000400000 0x0000000000400000 0x0004f8 0x0004f8 R   0x1000
  LOAD           0x001000 0x0000000000401000 0x0000000000401000 0x07e081 0x07e081 R E 0x1000
  LOAD           0x080000 0x0000000000480000 0x0000000000480000 0x027b40 0x027b40 R   0x1000
  LOAD           0x0a82f0 0x00000000004a82f0 0x00000000004a82f0 0x0057d0 0x00b058 RW  0x1000
  NOTE           0x000270 0x0000000000400270 0x0000000000400270 0x000030 0x000030 R   0x8
  NOTE           0x0002a0 0x00000000004002a0 0x00000000004002a0 0x000044 0x000044 R   0x4
  TLS            0x0a82f0 0x00000000004a82f0 0x00000000004a82f0 0x000018 0x000058 R   0x8
  GNU_PROPERTY   0x000270 0x0000000000400270 0x0000000000400270 0x000030 0x000030 R   0x8
  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10
  GNU_RELRO      0x0a82f0 0x00000000004a82f0 0x00000000004a82f0 0x003d10 0x003d10 R   0x1

 Section to Segment mapping:
  Segment Sections...
   00     .note.gnu.property .note.gnu.build-id .note.ABI-tag .rela.plt 
   01     .init .plt .text .fini 
   02     .rodata .stapsdt.base rodata.cst32 .eh_frame .gcc_except_table 
   03     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data .bss 
   04     .note.gnu.property 
   05     .note.gnu.build-id .note.ABI-tag 
   06     .tdata .tbss 
   07     .note.gnu.property 
   08     
   09     .tdata .init_array .fini_array .data.rel.ro .got 


$ readelf -Wl dynamic

Elf file type is DYN (Position-Independent Executable file)
Entry point 0x1060
There are 13 program headers, starting at offset 64

Program Headers:
  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align
  PHDR           0x000040 0x0000000000000040 0x0000000000000040 0x0002d8 0x0002d8 R   0x8
  INTERP         0x000318 0x0000000000000318 0x0000000000000318 0x00001c 0x00001c R   0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x000628 0x000628 R   0x1000
  LOAD           0x001000 0x0000000000001000 0x0000000000001000 0x000175 0x000175 R E 0x1000
  LOAD           0x002000 0x0000000000002000 0x0000000000002000 0x0000f4 0x0000f4 R   0x1000
  LOAD           0x002db8 0x0000000000003db8 0x0000000000003db8 0x000258 0x000260 RW  0x1000
  DYNAMIC        0x002dc8 0x0000000000003dc8 0x0000000000003dc8 0x0001f0 0x0001f0 RW  0x8
  NOTE           0x000338 0x0000000000000338 0x0000000000000338 0x000030 0x000030 R   0x8
  NOTE           0x000368 0x0000000000000368 0x0000000000000368 0x000044 0x000044 R   0x4
  GNU_PROPERTY   0x000338 0x0000000000000338 0x0000000000000338 0x000030 0x000030 R   0x8
  GNU_EH_FRAME   0x002010 0x0000000000002010 0x0000000000002010 0x000034 0x000034 R   0x4
  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10
  GNU_RELRO      0x002db8 0x0000000000003db8 0x0000000000003db8 0x000248 0x000248 R   0x1

 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 
   03     .init .plt .plt.got .plt.sec .text .fini 
   04     .rodata .eh_frame_hdr .eh_frame 
   05     .init_array .fini_array .dynamic .got .data .bss 
   06     .dynamic 
   07     .note.gnu.property 
   08     .note.gnu.build-id .note.ABI-tag 
   09     .note.gnu.property 
   10     .eh_frame_hdr 
   11     
   12     .init_array .fini_array .dynamic .got 
```

One thing that jumps out is the `Entry Point` and `VirtAddr/PhysAddr` addresses. The static binary has larger numbers, which look to be absolute addresses. However, the dynamic binary’s addresses and entry point are much smaller. This is because, as `readelf` reports, `Elf file type is DYN (Position-Independent Executable file)`. [[dynamic]]'s address values match the `offset` values, meaning the binary is loaded at a dynamic address and each section is mapped relative to that _base address_. For example, if the base address is `0x8041000`, then the first section will start at `0x8041000`, the second at `0x8042000`, etc. In contrast, the [[static]] binary is not position independent (no-PIE), so its base address will _always_ be `0x0400000`. This confirms the tests covered last lesson when we reviewed symbol addresses—they were either absolute or relative to a randomized base address.

If we want to take a more detailed look at any program function, we can use `objdump`. We can disassemble a function of interest to see its instructions using the `--disassemble=<function name>` flag. Or, we can disassemble all functions using `-D`. We will use intel disassembly syntax in this course (instead of AT&T), so it is useful to use the `-M intel` flag to ensure consistency with our lessons if you are new to x86 assembly. However, this decision of Intel vs AT&T syntax is a matter of personal preference/experience, so feel free to use AT&T if you would like. 

```console
$ objdump -M intel --disassemble=main static

static:     file format elf64-x86-64


Disassembly of section .init:

Disassembly of section .plt:

Disassembly of section .text:

0000000000401845 <main>:
  401845:	f3 0f 1e fa          	endbr64
  401849:	55                   	push   rbp
  40184a:	48 89 e5             	mov    rbp,rsp
  40184d:	48 8d 05 bc e7 07 00 	lea    rax,[rip+0x7e7bc]        # 480010 <__rseq_flags+0xc>
  401854:	48 89 c7             	mov    rdi,rax
  401857:	e8 b4 33 00 00       	call   404c10 <_IO_puts>
  40185c:	b8 00 00 00 00       	mov    eax,0x0
  401861:	5d                   	pop    rbp
  401862:	c3                   	ret

Disassembly of section .fini:

  

$ objdump -M intel --disassemble=main dynamic

dynamic:     file format elf64-x86-64


Disassembly of section .init:

Disassembly of section .plt:

Disassembly of section .plt.got:

Disassembly of section .plt.sec:

Disassembly of section .text:

0000000000001149 <main>:
    1149:	f3 0f 1e fa          	endbr64
    114d:	55                   	push   rbp
    114e:	48 89 e5             	mov    rbp,rsp
    1151:	48 8d 05 ac 0e 00 00 	lea    rax,[rip+0xeac]        # 2004 <_IO_stdin_used+0x4>
    1158:	48 89 c7             	mov    rdi,rax
    115b:	e8 f0 fe ff ff       	call   1050 <puts@plt>
    1160:	b8 00 00 00 00       	mov    eax,0x0
    1165:	5d                   	pop    rbp
    1166:	c3                   	ret

Disassembly of section .fini:
```

Taking a look at the `main` function of a static and dynamic binary, we see that both are in the `.text` section. This makes sense, as the `text` section is where we expect executable code to reside. We also note that the disassembly is the same. That makes sense, since it is the same program and thus should compile to the same bytes (so long as it is compiled with the same compiler and flags). The only difference is the addresses for each instruction. The first instruction (`endbr64`) exists at address `0x401845` in the static binary, and will exist at address `base_address + 0x1149` in the dynamic binary.

`objdump` disassembly is nice when performing a quick check or if the command line is the only tool available. However, when reverse engineering a more complex system, we need the ability to make notes and quickly jump between different parts of code. This is where disassemblers and decompilers come into play.

## Disassemblers and Decompilers
- Context: you have access to the program in binary form
- Goal: dissect specific **functions** within a program

- def (disassemble) = turn into assembly code 
- def (decompile) = (attempt to...) turn into source code 

Before moving on, we should note the difference between disassemblers and decompilers. Disassembly is a translation of bits in the binary into the assembly language instructions to which they correspond. Assuming a well-documented architecture manual (such as `x86_64`), this process is 100% correct. There is no possible way for a CPU to misconstrue one instruction for another—the result would be indeterminism, which is unacceptable for a computer program. Therefore, reading assembly instructions is a perfect view into what the system is doing at any given time.

However, reading disassembly is tedious. Every line of C code can generate dozens of instructions, and this ratio only increases as we move to more feature-rich languages like Rust and C++. For this reason, tool developers have worked tirelessly to create decompilers. A decompiler uses the assembly instructions, an understanding of compilers, heuristics, and programming expertise to attempt to generate pseudo-C code for the function of interest. The effectiveness of a decompiler fluctuates per function and also across tools. Simple C functions using a standard compiler will generally decompile into very nice C code. More complex functions or programs compiled with obscure compilers may require a lot of massaging. The good news is that these tools generally allow the user to edit variable types and function signatures to assist the decompiler in improving its output. The impact can be substantial and greatly aid in our ability to understand a complex system. 

The world of disassemblers and decompilers has changed a lot in recent years, and typically three tools are considered state-of-the-art when it comes to reverse engineering. Those tools are IDA Pro, Ghidra, and Binary Ninja (sorry Radare).

IDA has the longest track record of success and has accumulated a very extensive set of architecture decompilers. The downside to IDA is cost. We will not teach IDA in this course for that reason, however if you or your company happens to own a license then you are free to use it!
- we don't use IDA here because it costs $

Ghidra is new as of 2019 and free open source software. It is maintained by the National Security Agency and routinely releases updates, including the long-anticipated Dark Mode theme in 2023 and Swift (iOS) support in 2024. It is a tool written in Java and thus any extensions or scripts to automate analysis must also be written in Java or Jython (ew).
- Ghidra
	- can decompile
	- can disassembly

Binary Ninja is a tool that dates back to 2016, though it has gained a lot of traction in the past few years. Originally developed by CTF players with CTFs in mind, it is a tool that offers unique extensions and analysis options that are not default to IDA and Ghidra. Binary Ninja (or "Binja") is known for its pleasing UI and ease in adding and creating plugins. It exposes both a Python and Rust API for scripting and offers a variety of license options. Binary Ninja Free is a free version of the tool which offers more than enough functionality to complete the challenges in this course. Vector35, the creator of Binja, offers substantial discounts to full-time students, which is something to consider should you qualify and enjoy it.
- Binary Ninja
	- why use? Cuz pretty UI and free (well, at least the free version)
	- 

Summary Table of Decompile/Disassembly Tools:

| Tool   | Cost                  | Scripting Language            | Advantages                                                               |
| ------ | --------------------- | ----------------------------- | ------------------------------------------------------------------------ |
| IDA    | Steep                 | IDAC (C) / IDAPython (Python) | Loads of decompilers (for an added fee...), state of the art for decades |
| Ghidra | Free                  | Java / Jython                 | Free and actively developed                                              |
| Binja  | Variable (incl. Free) | Python/Rust                   | New and unique features released frequently, UI, great bang-for-buck     |

We will cover both Binja and Ghidra in this course and show use cases for each. You are free to use whatever tools you find most convenient. We will incrementally introduce functionality of each tool as we progress, but if you are itching to learn more about the tools, please see these tutorials and guides!

* [Ghidra Homepage with Getting Started Video](https://ghidra-sre.org/)
* [Ghidra Quick Reference Guide](https://htmlpreview.github.io/?https://github.com/NationalSecurityAgency/ghidra/blob/stable/GhidraDocs/CheatSheet.html) from Ghidra
* [Binary Ninja Getting Started](https://docs.binary.ninja/getting-started.html) from Vector35
* [Binary Ninja User Guide](https://docs.binary.ninja/guide/index.html) from Vector35

# Sample Uses of Decompile/Disassembly Tools

### Binary Ninja

Binary Ninja now has a cloud and a [free version](https://binary.ninja/free/) available for download! Paid versions offer scripting support and other architecture decompilers, but the free version is perfect for this course. Let’s look at a [[decompiler_example]], which is compiled output of [[decompiler_example.c|the following code]]:

```c
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#define BUFLEN 0x20  

// gcc decompiler_example.c -o decompiler_example

void say_hello(char* buf) {
    char hello[6] = "Hello\0";
    printf("%s %s\n", hello, buf);
}

void get_name(char* buf) {
    printf("What is your name?\n > ");
    fgets(buf, BUFLEN, stdin);
    char* newline = strchr(buf, '\n');
    if (newline) { *newline = '\0'; }
}

int main() {
    char buf[BUFLEN];
    memset(buf, 0, BUFLEN);
    get_name(buf);
    say_hello(buf);
    return 0;
}
```

Open Binja and drop the file into the tool to trigger automatic analysis and decompilation:

![[binja.png]]
The default view shows program symbols in the upper left, similar to `readelf`! We can easily tell from the symbol addresses that this is most likely dynamically linked, given they look like small offsets. The right-hand view is configurable and changeable—above it shows decompiled functions in Binary Ninja’s high-level intermediate language (HLIL) as indicated in the top toolbar. The free version also offers disassembly, low-level IL and medium-level IL (in its paid versions), and Pseudo-C. Each of these intermediate languages (ILs) is a step further from decompilation, which makes it more readable but also at risk for losing granularity. Switching to disassembly is often useful as it is the "ground truth" of information—Binja should disassemble x86, x86_64, and ARM64 programs flawlessly. What we see in this view is the same as what `objdump` would show!

![[binja_disassembly.png]]

We can easily see the power in this tool—flipping between layers of abstraction is useful for quickly understanding what a program does at a high level, while still offering lower level abstractions for understanding the program at the register/memory level.

We also see the first example of where reverse engineering comes into play due to loss of information from the compiler. We know from the source code that the buffer `buf` in `main` is a character array of `0x20` bytes. But `gcc` does not store debug information (unless otherwise instructed) to show that level of information—instead we get a relative stack variable void `var_38` that is used in the function calls (when viewed in HLIL). Binary Ninja guesses the `void` type when it cannot determine the variable’s types through its analysis passes. 

```
0000128d  int32_t main(int32_t argc, char** argv, char** envp)
00001299      void* fsbase
00001299      int64_t rax = *(fsbase + 0x28)
000012b9      void var_38
000012b9      memset(&var_38, 0, 0x20)
000012c5      get_name(&var_38)
000012d1      say_hello(&var_38)
000012df      *(fsbase + 0x28)
000012e8      if (rax == *(fsbase + 0x28))
000012f0          return 0
000012ea      __stack_chk_fail()
000012ea      noreturn

```

We need to use contextual information to determine its length. Because the `memset` length is `0x20` bytes, we can reasonably expect that the memory at `var_38` is an array or structure of `0x20` bytes. It is passed by reference to the `get_name` function, which we can enter by double-clicking on the symbol name.

![[binja_get_name.png]]

We see that it is used in an `fgets` call, which implies this is a character buffer. Let's jump back to `main` and use that information to define its type and rename it. Pressing the `<ESC>` key jumps back to a prior view. We can redefine the type and rename `var_38` using the `y` shortcut or right clicking and choosing `Change Type`.

![[binja_change_type.png]]
![[binja_after_change_type.png]]

Specifying a name in the type definition will automatically rename the variable, otherwise we can manually do that with the `n` shortcut. That output looks much nicer! 

We can do the same thing for arguments and function return types—here is the result of defining the function signature correctly for `say_hello` (since we assumed `buf` is a character array in `main` and it’s passed to `say_hello`, it stands to reason it is a `char*` in this function signature). 

![[binja_say_hello.png]]

Binja also shows its usefulness when handling common functions like `printf`. It knows the type signature for the variadic C function (`int printf(const char* format, …)`) and automatically shows that in the HLIL view. If it did not recognize a function or we want to define the signature for local functions, we can also use the `y` shortcut to define return type, argument types, and argument names:

![[binja_function_signature.png]]

Pretty cool! With just a few changes, we can easily see what the program’s intent is. Let’s take a look at how to do the same thing in Ghidra:

### Ghidra

Follow the instructions on [Ghidra’s GitHub page](https://github.com/NationalSecurityAgency/ghidra) to get up and running with Ghidra. Once running, it gives us an opportunity to create a project (`File -> New Project`) to store all related files. Organizing all binaries for a single project (e.g., independent binaries in a single firmware image) is a useful way of sharing structure and function definitions across files, and is one of Ghidra’s biggest strengths for real-world research. For the sake of this course, you can organize your challenges however you desire. Once a project is created, drag and drop a file into the browser and double click on it to open up analysis.

> Note: you can also configure Dark Mode in the project browser using `Edit -> Theme -> Switch`!

![[ghidra_project_browser.png]]

Double clicking asks us if we want to analyze (we do) and what analysis passes to run. For the sake of our course we can always use the default options. 

> Clicking `analyze` might bring up a pop-up like shown below on macOS. Close out of Ghidra and open the Privacy & Security settings on your Mac, looking for the notification that an application from an "unidentified developer" was run. Click `Allow Anyway` and retry. You may need to do this more than once for different analysis binaries.

![[ghidra_security_warning.png]]
![[ghidra_security_approval.png]]

Ghidra’s default layout shows a symbol tree on the left which is useful for searching for function names, a linear disassembly view in the middle (like `objdump`), and a C-like decompiled view on the right. Unlike Binary Ninja, it only offers two layers of abstraction for our purposes—disassembly and C decompilation. Clicking anywhere in a function body in the middle pane brings up the associated decompilation on the right.

![[ghidra_main_view.png]]

Just like Binary Ninja, we can rename and redefine types with the `l` and `Ctrl/Cmd + l` options, respectively. We see that Ghidra also fails to define `buf` correctly in `main`. Here, it correctly identifies it as a character buffer, but guesses 40 bytes instead of 32. This is because the compiler leaves padding between the end of the buffer and the return values pushed onto the stack, so there are an extra eight (unused) bytes.

This is our first instance of the decompiler giving us incorrect information! Decompilation is great, and for simple C programs it's relatively flawless. But it is only a tool’s best guess as to the function’s high level representation!

Refining the `buf` type cleans up the decompilation a bit:

```c
undefined8 main(void)

{
  long lVar1;
  long in_FS_OFFSET;
  char buf [32];
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  memset(buf,0,0x20);
  get_name(buf);
  say_hello(buf);
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```

We can make the same changes to the sub-functions to clean up the decompilation even more and confirm our understanding of each!

#### An Important Observation

You might have noticed a discrepancy between Binja and Ghidra in `main`—the address for `main` is different! Binja shows `0x128d` while Ghidra shows `0x10128d`. What gives? Using `objdump` as a sanity check shows that Binja uses the correct address:

```
$ objdump --disassemble=main -M intel decompiler_example

decompiler_example:     file format elf64-x86-64

Disassembly of section .text:

000000000000128d <main>:
    128d:	f3 0f 1e fa          	endbr64
    1291:	55                   	push   rbp
    1292:	48 89 e5             	mov    rbp,rsp
    1295:	48 83 ec 30          	sub    rsp,0x30
```

So it appears that Ghidra adds a large constant value to the binary addresses. Navigating to `Window -> Memory Map` shows that Ghidra in fact automatically sets an `Image Base` for the binary as `0x100000`, hence why the addresses are all offset.

![[ghidra_memory_map.png]]
This is a side effect of Ghidra attempting to load the binary at the expected address—but because this is a PIE binary it only has a virtual address. Ghidra therefore defines its own base address, `0x100000`, and calculates the "virtual" addresses accordingly.

> This is potentially dangerous behavior if we ever use the tool to calculate relative offsets like we did in the previous lesson. We can undo this by clicking on the house icon in `Memory Map`
>'s toolbar and setting the offset to 0, then saving to return to our analysis.

### `pwntools.ELF`

One last static analysis tool that you may find extremely useful as we progress through the course is `pwntools`’s `ELF` function. If you pass in a binary file path, `pwntools` automatically runs static analysis passes on it to provide information and determine the addresses of symbols. It exposes a dictionary through which we can easily access addresses for use in our solver scripts. For example, let’s print out some information about the [[static]] binary:

```console
$ python3
Python 3.8.10 (default, May 26 2023, 14:05:08) 
[GCC 9.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from pwn import *
>>> e = ELF("./static")
[*] '/root/static'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

Simply using the `ELF` command prints out a lot of information we gathered through `readelf` and `objdump`! We see this is a no-PIE binary and the base address for the binary is always `0x400000`. We also see some useful information about other security mitigations, specifically whether the binary has stack canaries and what type of `relro` is applied. We will cover the impact of these in future lessons. Also note that what the `ELF` command prints is an output from `checksec`, a tool that `pwntools` installs by default. We can get the same information without the Python interface on the command line using `checksec` directly (or `pwn checksec`):

```console
$ pwn checksec --file=./static
[*] '/root/static'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

Using the ELF dictionary, we can easy print out the address of symbols such as `main`, and can even perform disassembly programmatically as we did with `objdump`:

```console
$ python3
>>> from pwn import *
>>> e = ELF("./static")
[*] '/root/static'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
>>> e.symbols["main"]
4200517
>>> hex(_)
'0x401845'
>>> e.functions["main"]
Function(name='main', address=0x401845, size=0x1e, elf=ELF('/root/static'))
>>> d = e.disasm(e.functions["main"].address, e.functions["main"].size)
>>> print(d)
  401845:       f3 0f 1e fa             endbr64
  401849:       55                      push   rbp
  40184a:       48 89 e5                mov    rbp, rsp
  40184d:       48 8d 05 bc e7 07 00    lea    rax, [rip+0x7e7bc]        # 0x480010
  401854:       48 89 c7                mov    rdi, rax
  401857:       e8 b4 33 00 00          call   0x404c10
  40185c:       b8 00 00 00 00          mov    eax, 0x0
  401861:       5d                      pop    rbp
  401862:       c3                      ret
```

There is a lot more functionality available that we will discuss throughout the semester; feel free to read about it more [in `pwntools`'s docs]([https://docs.pwntools.com/en/stable/elf.html](https://docs.pwntools.com/en/stable/elf.html)).





## Dynamic tooling 

As previously discussed, static tooling is great for getting our bearings and providing some preliminary information about a binary. However, many times we need to inspect a process’s state during execution to better understand its functionality and behavior. This is where dynamic tooling comes into play. 

### GDB

The most ubiquitous Linux dynamic reverse engineering tool is `gdb`. We will spend some time introducing this tool now, and you will no doubt become experts in its use over the course of the semester. Let’s start by loading and running a binary. Loading a target binary is as simple as invoking gdb with an argument. Take last lesson's [[dynamic]] binary, for instance. `gdb dynamic` gives us a `gdb` shell before execution starts. We then run the binary with `r` or `run`. This invokes the binary just as we would on the command line, and allows us to interact with it via `stdin` and `stdout`.

```console
$ apt install -y gdb # install gdb if not already installed
[ ... snip ... ]

$ gdb dynamic 
GNU gdb (Ubuntu 14.0.50.20230907-0ubuntu1) 14.0.50.20230907-git
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from dynamic...

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.ubuntu.com>
Enable debuginfod for this session? (y or [n]) n
Debuginfod has been disabled.
To make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.
(No debugging symbols found in dynamic)
(gdb) r
Starting program: dynamic 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Hello world
[Inferior 1 (process 2918566) exited normally]
(gdb) 
```

Ok, this does not seem to add any functionality to the normal command line. But we can confirm the binary runs, as expected, within `gdb`. 

Quit out of `gdb` with quit and restart it with `gdb dynamic`. Before running, we can set a breakpoint at the entry to the `main` function using `b main` or `breakpoint main`. We can confirm the breakpoint is set using `i b` or `info breakpoints`. 

```gdb
(gdb) b main
Breakpoint 1 at 0x1151
(gdb) i b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000001151 <main+8>
(gdb) 
```

We see the breakpoint is set at `0x1151`, which is not the actual virtual memory address assigned. `gdb` will automatically resolve the correct address after the binary is loaded into memory by the loader/linker. Run the binary with `r` and we hit the breakpoint at `0x0000555555555151` and await further commands. [There are a number of `gdb` commands]([https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf](https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf)), a couple of which we will show here. We can dump register information using `info registers` or `i r`. Similar to `objdump- --disassemble=main`, we can disassemble the current function with `disass` or disassemble any function with `disassemble <function name>`.

```gdb
(gdb) r
Breakpoint 1, 0x0000555555555151 in main ()
(gdb) i r
rax            0x555555555149      93824992235849
rbx            0x7fffffffe2d8      140737488347864
rcx            0x555555557dc0      93824992247232
rdx            0x7fffffffe2e8      140737488347880
rsi            0x7fffffffe2d8      140737488347864
rdi            0x1                 1
rbp            0x7fffffffe1c0      0x7fffffffe1c0
rsp            0x7fffffffe1c0      0x7fffffffe1c0
r8             0x0                 0
r9             0x7ffff7fcb180      140737353920896
r10            0x7ffff7fc68e8      140737353902312
r11            0x7ffff7fe0cc0      140737354009792
r12            0x0                 0
r13            0x7fffffffe2e8      140737488347880
r14            0x555555557dc0      93824992247232
r15            0x7ffff7ffd000      140737354125312
rip            0x555555555151      0x555555555151 <main+8>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
fs_base        0x7ffff7fb5740      140737353832256
gs_base        0x0                 0
(gdb) disass
Dump of assembler code for function main:
   0x0000555555555149 <+0>:	endbr64
   0x000055555555514d <+4>:	push   %rbp
   0x000055555555514e <+5>:	mov    %rsp,%rbp
=> 0x0000555555555151 <+8>:	lea    0xeac(%rip),%rax        # 0x555555556004
   0x0000555555555158 <+15>:	mov    %rax,%rdi
   0x000055555555515b <+18>:	call   0x555555555050 <puts@plt>
   0x0000555555555160 <+23>:	mov    $0x0,%eax
   0x0000555555555165 <+28>:	pop    %rbp
   0x0000555555555166 <+29>:	ret
End of assembler dump.
```

We see that the disassembly instructions are AT&T syntax, which we can change with `set disassembly-flavor intel`:

```gdb
(gdb) set disassembly-flavor intel
(gdb) disass
Dump of assembler code for function main:
   0x0000555555555149 <+0>:	endbr64
   0x000055555555514d <+4>:	push   rbp
   0x000055555555514e <+5>:	mov    rbp,rsp
=> 0x0000555555555151 <+8>:	lea    rax,[rip+0xeac]        # 0x555555556004
   0x0000555555555158 <+15>:	mov    rdi,rax
   0x000055555555515b <+18>:	call   0x555555555050 <puts@plt>
   0x0000555555555160 <+23>:	mov    eax,0x0
   0x0000555555555165 <+28>:	pop    rbp
   0x0000555555555166 <+29>:	ret
End of assembler dump.
```

Quit out of `gdb` and reload, again setting a breakpoint on `main`. Run the binary and check the address. The output is surprising...the starting address is the same (`0x0000555555555151`)! This is not expected, since it is a dynamically loaded PIE binary. The binary’s base address _should_ be different for each invocation.

```gdb
(gdb) b main
Breakpoint 1 at 0x1151
(gdb) r
Starting program: dynamic 

Breakpoint 1, 0x0000555555555151 in main ()
```

This is because `gdb`, by default, turns off address randomization for binaries and libraries. The benefit of this is we can perhaps spot patterns in program behavior when symbols and data reside at the same address between runs. This is especially useful when deep in the weeds during reverse engineering. However, it poses a significant issue when developing exploits. There could be a situation where your exploit is sensitive to the address at which the binary is loaded—this is actually a common occurrence. When running and debugging locally, you might observe a 100% exploit reliability because `gdb` is always loading memory at the same addresses. On a target system which uses ASLR, reliability might drop substantially or it might not work at all, especially if we hard-code addresses into our exploit. Therefore, it is useful to toggle this functionality on and off as needed. We can do so using `set disable-randomization off`. We can also check what the current configuration of this (or any) variable is using `show`:

```gdb
(gdb) show disable-randomization
Disabling randomization of debuggee's virtual address space is on.
(gdb) set disable-randomization off
(gdb) show disable-randomization
Disabling randomization of debuggee's virtual address space is off.
```

Restart the binary using `r` and we see randomization taking place.

```gdb
(gdb) b main
Breakpoint 1 at 0x1151
(gdb) set disable-randomization off
(gdb) r
Starting program: dynamic 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, 0x00005602c18e2151 in main ()
(gdb) 
```

We can easily calculate the binary’s `base address` by subtracting out the function’s offset (which we determined earlier using `readelf` as `0x1151`)

```
base_address = symbol virtual address - symbol offset
base_address = 0x00005602c18e2151 - 0x1151
base_address = 0x5602c18e1000
```

Knowing the base address, we could deterministically calculate the address of any other symbol using its offset! This will be especially important in future homework challenges to bypass the ASLR and PIE protections discussed in last lesson’s material.

Note that turning randomization requires setting breakpoints differently. We can always set a breakpoint at the beginning of a function symbol by breaking on its name: `b main`. However, when randomization is off we could also use its address: `0x0000555555555151`. This will always work because `gdb` loads the binary at the same address. However, with randomization on, it will break—the address `0x0000555555555151` might not even be a valid virtual address in this runtime environment! So using the function name is always the safe bet. However, what if we want to set a breakpoint on the 6th instruction in `main` (`call <puts@plt>`)? We can determine its address using `disass`, but that address will change between invocations. 

```gdb
(gdb) disass main
Dump of assembler code for function main:
   0x0000555555555149 <+0>:	endbr64
   0x000055555555514d <+4>:	push   rbp
   0x000055555555514e <+5>:	mov    rbp,rsp
   0x0000555555555151 <+8>:	lea    rax,[rip+0xeac]        # 0x555555556004
   0x0000555555555158 <+15>:	mov    rdi,rax
=> 0x000055555555515b <+18>:	call   0x555555555050 <puts@plt>
   0x0000555555555160 <+23>:	mov    eax,0x0
   0x0000555555555165 <+28>:	pop    rbp
   0x0000555555555166 <+29>:	ret
End of assembler dump.
```

We can set a dynamic breakpoint and make `gdb` resolve the address using the offset from the function’s start. In this case, the 6th instruction is at an offset, as shown above, of `+18`. We can break on this instruction using `b *(main + 18)`. Note the `*` in the statement, we need this or the breakpoint will not work. We can check to see if the breakpoint works by re-running the binary, which still breaks at the beginning of `main`, and then `continue`-ing (`c`) to hit the new breakpoint six instructions in.

```gdb
(gdb) b *(main+18)
Breakpoint 2 at 0x5602c18e215b
(gdb) c
Continuing.

Breakpoint 2, 0x00005602c18e215b in main ()
(gdb) 
```

Even though the command’s output shows an absolute address, it is set as a dynamic breakpoint and will automatically resolve each run.

```gdb
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /root/dynamic 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
c

Breakpoint 1, 0x00005590396c9151 in main ()
(gdb) c
Continuing.

Breakpoint 2, 0x00005590396c915b in main ()
(gdb) 
```

### GDB Extensions

The `gdb` output shown previously is a bit...sparse. Running "vanilla" gdb requires a lot of interaction to show useful state information. In response, there are a number of open source `gdb` extensions that provide a standard interface upon each breakpoint, and provide extra commands to facilitate debugging and reverse engineering. The three most common are:

* [gef](https://github.com/hugsy/gef)
* [pwndbg](https://github.com/pwndbg/pwndbg)
* [peda](https://github.com/longld/peda)

Taking a look at `gef` after installing, it is obvious that this extension provides a lot more information upon first glance. Having register information, the next couple instructions, and the stack at our fingertips after every breakpoint is extremely helpful and drastically cuts down on debugging time.


![[gef.png]]

Each extension adds its own functionality to `gdb`, some of which might suit your interests depending on the situation. We will introduce some of this functionality later in the semester, but certainly keep the extension’s documentation handy. 

### `pwnlib.gdb()`

A powerful extension for debugging is being able to spawn `gdb` through `pwntools`. This allows us to dynamically spin up a `gdb` debugging instance, set breakpoints, and interact with the debugee via `pwntools` commands shown in last week’s material. This significantly short circuits our reverse engineering and exploit development process. 

To set some breakpoints, run the binary, and interact with the binary, we can use a script such as below. This sets a breakpoint at `main`, another breakpoint in the middle of the loop after printing with `puts`, and then `recv`s and `send`s information. For instance, consider the [[pwntools_example_read]] binary from last lesson. We can load the binary in `gdb` and set a breakpoint on `main` with the following script:

```python
from pwn import *
context.log_level = "DEBUG"
p = gdb.debug('./pwntools_example_read', '''
break main
continue
''')

print(p.recvuntil(b" > ").decode()) # decode from bytes to a string
p.sendline(b"10")
print(p.recvuntil(b" > ").decode()) # decode from bytes to a string
p.sendline(b"13")
p.interactive()
```

> Note `pwntools.gdb` automatically turns randomization on, which is helpful for ensuring our exploit is reliable. Running the script automatically spawns a new shell containing the `gdb` process if run on a Linux OS with GUI interface.

If you happen to use a terminal-only OS (e.g., Ubuntu Server) or a cloud instance (e.g., a Digital Ocean droplet via SSH), you can use `tmux` to split the terminal when spawned. `tmux` is [a terminal multiplexer]([https://github.com/tmux/tmux/wiki](https://github.com/tmux/tmux/wiki)) which we will not cover in this course, however it is relatively quick to learn and there are plenty of cheat sheets and resources online. Simply:

* Run `tmux` to start the multiplexer
* Add `context.terminal = ["tmux", "splitw", "-h", "-f"]` to your script after importing `pwntools` (or use `-v` instead of `-h` if you would rather split in the vertical direction)
* Run the script and enjoy your side-by-side terminals!

![[tmux_gdb.png]]

## Recitation

#### Recitation 1.0

Use `pwntools.ELF` to fetch binary and symbol information in the Linux utilities you investigated last week in Recitation 0. Confirm that the symbol addresses match the output of `readelf`. Try using `ELF` in your solver scripts from last lesson's homework instead of hard-coded values from the `readelf` output.

#### Recitation 1.1

Open last lesson's [[pwntools_example_read]] example in GDB and break on the call to `get_number`. Step through the function with `ni` until you get to the `read` call. What are the arguments to the `read` call? Continue past the read call and dump bytes at the address passed in the second argument (the `buf` character buffer). Confirm that you see the ASCII bytes corresponding to your input. Use GDB to print the bytes individually (`x/b`) and as a string (`x/s`) using that address.

#### Recitation 1.2

Continue from the example above until `get_number` finishes. What is the return value from the function? Does it differ from the values input into the buffer from [[#Recitation 1.1]]? _Hint: what register holds the return value?_

#### Recitation 1.3

Open [[pwntools_example_read]] in Binary Ninja or Ghidra. Determine the address in `main` where our two inputs are added together. While we're here, try renaming and retyping variables in the decompilation according to the source code in [[pwntools_example_read]]. _Hint: it's an `add` instruction_.

#### Recitation 1.4

Open [[pwntools_example_read]] in GDB and set a breakpoint on the address from [[#Recitation 1.3]]. This is the point at which we add our two numbers together. Use the instruction's _operands_ (~arguments) to determine which registers these values are in. Print the values in each of those registers (`p/x <register name>`). _Hint: this is a dynamic binary, so you may need to set a relative breakpoint with `b *(<symbol name> + <offset>)` to break on the desired address_.

#### Recitation 1.5

Spawn [[pwntools_example_read]] and break on the `read` call with the following solver. This is the solver that failed initially because it is out of sync with the server. `finish` the `read` call and investigate the buffer to confirm the root cause. _Hint: print the buffer after the call returns and check the bytes in it_.

```python
from pwn import *

context.log_level = "DEBUG"
context.terminal = ["tmux", "splitw", "-h", "-f"]

p = gdb.debug("./pwntools_example_read", '''
b read
continue
''')
p.sendline(b"10")
p.sendline(b"13")
print(p.recv())
p.interactive()
```

## Next Steps

This lesson just scratched the surface with static and dynamic tooling, and we will quickly continue building our familiarity and skill using the tools presented. Next lesson, we introduce reverse engineering strategies that will leverage the tools' capabilities.